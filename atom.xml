<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pRism</title>
  
  
  <link href="https://www.pri87.vip/atom.xml" rel="self"/>
  
  <link href="https://www.pri87.vip/"/>
  <updated>2025-05-31T14:22:16.457Z</updated>
  <id>https://www.pri87.vip/</id>
  
  <author>
    <name>pRism</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WinUI3-简介与使用</title>
    <link href="https://www.pri87.vip/posts/779bcfa0.html"/>
    <id>https://www.pri87.vip/posts/779bcfa0.html</id>
    <published>2025-05-31T12:59:45.000Z</published>
    <updated>2025-05-31T14:22:16.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WinUI3"><a href="#WinUI3" class="headerlink" title="WinUI3"></a>WinUI3</h2><p>WinUI3是当前微软开发的最新的UI框架，之前我只会win32的时候，需要处理令人讨厌的消息回调，如今，使用WinUI3和写前后端一样方便，甚至后端还是C#，好写，爽。不过缺点就是编译出来文件很大，而且并不是一个单独的exe。当然可以用MSIX打包就是了。</p><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><p><img src="https://s2.loli.net/2025/05/31/H6v9NbCQxmZoB4W.png" alt="image-20250531212907488"></p><p>选择这里面的空白应用，已打包（桌面版中的WinUI 3）</p><p><img src="https://s2.loli.net/2025/05/31/m6wf3HTI5KeSYB9.png" alt="image-20250531212950045"></p><p>左边的App.xaml是入口点，下面的MainWindows.xaml是主类</p><p>xaml中可以设置控件的基本属性，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;Grid&gt;</span><br><span class="line">    &lt;Grid Grid.Row=&quot;2&quot; Margin=&quot;12&quot;&gt;</span><br><span class="line">        &lt;Grid.ColumnDefinitions&gt;</span><br><span class="line">            &lt;ColumnDefinition Width=&quot;*&quot;/&gt;</span><br><span class="line">            &lt;ColumnDefinition x:Name=&quot;MiddlePaddingColumn&quot; Width=&quot;10&quot;/&gt;</span><br><span class="line">            &lt;ColumnDefinition Width=&quot;80&quot;/&gt;</span><br><span class="line">        &lt;/Grid.ColumnDefinitions&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextBox</span><br><span class="line">        x:Name=&quot;FileInputTextBox&quot;</span><br><span class="line">        Grid.Row=&quot;1&quot;</span><br><span class="line">        Height=&quot;32&quot;</span><br><span class="line">        Margin=&quot;12,8,12,8&quot;</span><br><span class="line">        VerticalContentAlignment=&quot;Center&quot;</span><br><span class="line">        PlaceholderText=&quot;拖曳文件或双击打开文件...&quot;</span><br><span class="line">        AllowDrop=&quot;True&quot;</span><br><span class="line">        Drop=&quot;FileInputTextBox_Drop&quot;/&gt;</span><br><span class="line">        &lt;Grid Grid.Column=&quot;2&quot;&gt;</span><br><span class="line">            &lt;Button Click=&quot;Button_Click&quot;&gt;点击&lt;/Button&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/Grid&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">&lt;/Grid&gt;</span><br></pre></td></tr></table></figure><p>先创建了一个横向(ColumnDefinitions)的Grid，然后创建不同的控件放入，其中Drop事件绑定了FileInputTextBox_Drop函数，Click绑定了Button_Click这个函数，这个函数在该xaml所属的cs文件中定义，打开cs文件</p><p><img src="https://s2.loli.net/2025/05/31/6XdlWJv7tgFRjir.png" alt="image-20250531215705446"></p><p>可以看到入口点</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WinUItest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> An empty window that can be used on its own or navigated to within a Frame.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过在InitializeComponent之后添加更多内容实现窗口属性的修改，比如这样：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line">    DriverControl.DriverService.LogEvent += LogHandler;</span><br><span class="line">    <span class="comment">// 实现主题栏高亮</span></span><br><span class="line">    ExtendsContentIntoTitleBar = <span class="literal">true</span>;</span><br><span class="line">    Activated += MainWindow_Activated;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置大小</span></span><br><span class="line">    IntPtr hWnd = WindowNative.GetWindowHandle(<span class="keyword">this</span>);</span><br><span class="line">    WindowId windowId = Win32Interop.GetWindowIdFromWindow(hWnd);</span><br><span class="line">    AppWindow appWindow = AppWindow.GetFromWindowId(windowId);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">uint</span> dpi = DpiHelper.GetDpiForWindow(hWnd);</span><br><span class="line">    <span class="built_in">double</span> scaleFactor = dpi / <span class="number">96.0</span>;</span><br><span class="line">    <span class="built_in">int</span> logicalX = <span class="number">500</span>;</span><br><span class="line">    <span class="built_in">int</span> logicalY = <span class="number">500</span>;</span><br><span class="line">    <span class="built_in">int</span> logicalWidth = <span class="number">616</span>;</span><br><span class="line">    <span class="built_in">int</span> logicalHeight = <span class="number">248</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> physicalX = (<span class="built_in">int</span>)(logicalX * scaleFactor);</span><br><span class="line">    <span class="built_in">int</span> physicalY = (<span class="built_in">int</span>)(logicalY * scaleFactor);</span><br><span class="line">    <span class="built_in">int</span> physicalWidth = (<span class="built_in">int</span>)(logicalWidth * scaleFactor);</span><br><span class="line">    <span class="built_in">int</span> physicalHeight = (<span class="built_in">int</span>)(logicalHeight * scaleFactor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建物理像素的大小矩形</span></span><br><span class="line">    RectInt32 newSize = <span class="keyword">new</span> RectInt32(physicalX, physicalY, physicalWidth, physicalHeight);</span><br><span class="line">    appWindow.MoveAndResize(newSize);</span><br><span class="line">    <span class="keyword">if</span> (appWindow.Presenter <span class="keyword">is</span> OverlappedPresenter presenter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 锁定大小</span></span><br><span class="line">        presenter.IsResizable = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将输入框双击事件重载</span></span><br><span class="line">    FileInputTextBox.AddHandler(TextBox.DoubleTappedEvent, <span class="keyword">new</span> DoubleTappedEventHandler(FileInputTextBox_DoubleTapped), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面绑定的函数直接定义即可</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> path;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">FileInputTextBox_Drop</span>(<span class="params"><span class="built_in">object</span> sender, DragEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查拖放进来的数据是否包含文件项</span></span><br><span class="line">    <span class="keyword">if</span> (e.DataView.Contains(StandardDataFormats.StorageItems))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取拖放进来的 StorageItems</span></span><br><span class="line">        <span class="keyword">var</span> items = <span class="keyword">await</span> e.DataView.GetStorageItemsAsync();</span><br><span class="line">        <span class="keyword">if</span> (items.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (items[<span class="number">0</span>] <span class="keyword">is</span> StorageFile file)</span><br><span class="line">            &#123;</span><br><span class="line">                FileInputTextBox.Text = file.Path;</span><br><span class="line">                path = file.Path;</span><br><span class="line">                name = Path.GetFileNameWithoutExtension(file.Name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e.Handled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FileInputTextBox_DragOver</span>(<span class="params"><span class="built_in">object</span> sender, DragEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 指定系统接受复制操作，否则拖放不会被允许</span></span><br><span class="line">    e.AcceptedOperation =</span><br><span class="line">        Windows.ApplicationModel.DataTransfer.DataPackageOperation.Copy;</span><br><span class="line"></span><br><span class="line">    e.Handled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就好了</p><p>click同理</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">click</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ContentDialog dialog = <span class="keyword">new</span> ContentDialog</span><br><span class="line">    &#123;</span><br><span class="line">        Title = name,</span><br><span class="line">        Content = path,</span><br><span class="line">        CloseButtonText = <span class="string">&quot;关闭&quot;</span>,</span><br><span class="line">        XamlRoot = <span class="keyword">this</span>.Content.XamlRoot</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ContentDialogResult result = <span class="keyword">await</span> dialog.ShowAsync();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概就是这样，总之就是写回调+系统API就好了</p>]]></content>
    
    
    <summary type="html">WinUI3,好！</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="开发" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/"/>
    
    <category term="UI应用" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/UI%E5%BA%94%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>驱动开发0</title>
    <link href="https://www.pri87.vip/posts/ce07a058.html"/>
    <id>https://www.pri87.vip/posts/ce07a058.html</id>
    <published>2025-05-29T09:54:23.000Z</published>
    <updated>2025-05-31T12:53:02.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WDM与KMDF"><a href="#WDM与KMDF" class="headerlink" title="WDM与KMDF"></a>WDM与KMDF</h2><p>WDM是微软一开始发布的驱动开发模型，全都是底层内容。在开发时，既要处理硬件，也要处理驱动程序与操作系统内核的交互。</p><p>WDF模型，为了降低驱动的开发难度，WDF中对WDM进行了多次封装，比如实现了对象，事件，自动排队等等，同时封装了一下驱动程序中的共同行为。不用再关心IRP分发，调度等问题</p><p>KMDF和UMDF是基于WDF的模型，一个是内核模式，一个是用户模式。</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>虽然标题是开发，但是实际上是逆向，中断，服务例程之类的东西还是需要学的，所以这里还是用WDM开发</p><p>之前那篇博客疑似是用KMDF写的，所以从这里开始重来吧。</p><h2 id="推荐教程"><a href="#推荐教程" class="headerlink" title="推荐教程"></a>推荐教程</h2><p><a href="https://space.bilibili.com/348612384">https://space.bilibili.com/348612384</a></p><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wdm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICENAME <span class="string">L&quot;\\DEVICE\\DeviceTest&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMNAME <span class="string">L&quot;\\??\\SymboilcLinkTest&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DrvUnload</span><span class="params">(PDRIVER_OBJECT pdriver)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pdriver-&gt;DeviceObject)</span><br><span class="line">&#123;</span><br><span class="line">IoDeleteDevice(pdriver-&gt;DeviceObject);</span><br><span class="line">UNICODE_STRING symname = &#123;&#125;;</span><br><span class="line">RtlInitUnicodeString(&amp;symname, SYMNAME);</span><br><span class="line">IoDeleteSymbolicLink(&amp;symname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DbgPrint(<span class="string">&quot;Driver Unloaded\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义对应的回调函数</span></span><br><span class="line">NTSTATUS <span class="title function_">myCreate</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pirp)</span></span><br><span class="line">&#123;</span><br><span class="line">NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">DbgPrint(<span class="string">&quot;my divice has be opened\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Status = status;</span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS <span class="title function_">myClose</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pirp)</span></span><br><span class="line">&#123;</span><br><span class="line">NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">DbgPrint(<span class="string">&quot;my divice has be closed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Status = status;</span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS <span class="title function_">myCleanup</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pirp)</span></span><br><span class="line">&#123;</span><br><span class="line">NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">DbgPrint(<span class="string">&quot;my divice has be cleaned\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Status = status;</span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 驱动入口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">PDRIVER_OBJECT driver,<span class="comment">//驱动对象</span></span></span><br><span class="line"><span class="params">PUNICODE_STRING reg_path<span class="comment">//unicode字符串，指明注册表位置</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">driver-&gt;DriverUnload = DrvUnload;<span class="comment">//设置卸载函数，卸载时调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建设备对象</span></span><br><span class="line"><span class="comment">// 步骤为生成unicode字符串作为名字，然后使用IoCreateDevice来获取传出的pdevice</span></span><br><span class="line">UNICODE_STRING deviceName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">RtlInitUnicodeString(&amp;deviceName, DEVICENAME);</span><br><span class="line">PDEVICE_OBJECT pdevice = <span class="literal">NULL</span>;</span><br><span class="line">NTSTATUS status = IoCreateDevice(driver, <span class="number">0</span>, &amp;deviceName, FILE_DEVICE_UNKNOWN, <span class="number">0</span>, TRUE, &amp;pdevice);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">&#123;</span><br><span class="line">DbgPrint(<span class="string">&quot;Create Device fail:%x\n&quot;</span>, status);</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建符号链接</span></span><br><span class="line"><span class="comment">// 步骤同上</span></span><br><span class="line">UNICODE_STRING symname = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">RtlInitUnicodeString(&amp;symname, SYMNAME);</span><br><span class="line">status = IoCreateSymbolicLink(&amp;symname, &amp;deviceName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">&#123;</span><br><span class="line">DbgPrint(<span class="string">&quot;Create symbolicLink fail:%x\n&quot;</span>, status);</span><br><span class="line">IoDeleteDevice(pdevice);</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为设备定义对应的回调函数，注意这里是以驱动的身份获取的</span></span><br><span class="line">driver-&gt;MajorFunction[IRP_MJ_CREATE] = myCreate;</span><br><span class="line">driver-&gt;MajorFunction[IRP_MJ_CLOSE] = myClose;</span><br><span class="line">driver-&gt;MajorFunction[IRP_MJ_CLEANUP] = myCleanup;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充之前的<a href="https://www.pri87.vip/posts/d2620136.html">驱动开发入门</a>这篇博客，这里需要说明一下对于驱动，设备对象，以及符号链接这三个东西的概念。</p><p>驱动：运行在操作系统OS内存中，作为补充操作系统功能的软件。类似于R3里的程序与DLL的关系。一般分为两种，一种是硬件驱动：用来实现接收硬件的数字信号并进行处理，或者实现操作系统对硬件的控制。这里的硬件可以是虚拟硬件，因为驱动是中间层，操作系统只会发送消息，让它执行某些操作，系统并不关心驱动如何完成这些任务。因此，虚拟硬盘(类似将内存当作硬盘用)驱动可以在系统要读取其控制的数据时，将地址转化为内存中的读取等等。另一种是和硬件无关的驱动，只是借助驱动的权限高的特点，来实现R0层不好实现的内容，一般叫它内核模块。</p><p>设备对象：操作系统控制硬件时，不是直接和硬件交互，而是中间间隔了硬件抽象层(hal.dll)，也就是虚拟设备。虚拟设备需要处理系统的irp请求，比如文件打开，文件关闭等等。这些内容都应该是函数/过程，r0也只能写在都写sys文件(驱动)里面。因此，驱动需要生成并绑定设备对象，之后所有的irp回调，都是由驱动来定义的，系统收到对这个对象的请求，都会先给驱动，在驱动中找到对应的irp回调并触发。</p><p>符号链接：操作系统需要一个指明设备对象的句柄才可以知道找哪个设备对象，同时，为了让R3也可以使用不同的硬件，设备对象需要绑定一个全局的符号链接，通过使用这个链接，表示了指向这个设备对象，符号链接是一个字符串。比如调用上面例子的设备，在R3需要使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateFile(<span class="string">&quot;\\\\.\\SymboilcLinkTest&quot;</span>,GENERIC_READ|GENERIC_WRITE,<span class="number">0</span>,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">介绍在windows下vs进行驱动开发的方法和系统模块的基本框架</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="R0" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/R0/"/>
    
    <category term="驱动" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/R0/%E9%A9%B1%E5%8A%A8/"/>
    
    
    <category term="驱动" scheme="https://www.pri87.vip/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Intel-pin动态二进制插桩工具</title>
    <link href="https://www.pri87.vip/posts/6811c218.html"/>
    <id>https://www.pri87.vip/posts/6811c218.html</id>
    <published>2025-05-22T16:43:05.000Z</published>
    <updated>2025-05-31T12:42:00.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pin"><a href="#pin" class="headerlink" title="pin"></a>pin</h1><p>这是什么东西就不解释了，我也不是很清楚，网上的介绍也挺多的。</p><p>下面的演示以Windows为准</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.intel.cn/content/www/cn/zh/developer/articles/tool/pin-a-binary-instrumentation-tool-downloads.html">Pin - A Dynamic Binary Instrumentation Tool</a></p><p>在其中找到Windows(MSVC)</p><p><img src="https://s2.loli.net/2025/05/23/kblyGYRrhd7HWME.png" alt="image-20250523004544183"></p><p>选择最新版下载</p><p>下载后解压，其中的pin.exe就是pin主程序了。</p><p>将本目录添加到path</p><p>然后安装<a href="https://cygwin.com/install.html">Cygwin</a>，在选择安装时额外添加make，gcc和g++，安装成功后，将bin目录添加到path</p><p>然后尝试编译pintool工具，看看有没有成功安装：</p><ul><li>打开x64 Native Tools Command Prompt for VS 2022/如果是32位使用32位的prompt</li><li>跳转到\source\tools\MyPinTool目录</li><li>执行make all TARGET=Intel64</li></ul><p>会生成obj-intel64文件夹及其中的dll文件，然后尝试执行验证一下能不能用</p><p>到ManualExamples中再次make，cd到obj-intel64中pin -t inscount2.dll -o inscount0.log — divide_by_zero.exe，查看输出文件是否存在和是否可以执行。</p><p><img src="https://s2.loli.net/2025/05/25/4jneEhY3taAIpDO.png" alt="image-20250525020741939"></p><p>十分合理。</p><p>参考：</p><p><a href="https://hur1k.github.io/2023/02/26/Intel Pin — Windows&amp;wsl 编译踩坑实录/">Intel Pin — Windows&amp;wsl 编译踩坑实录</a></p><p><a href="https://software.intel.com/sites/landingpage/pintool/docs/98484/Pin/html/index.html#BuildingExamples">Pin: Pin 3.21 User Guide</a></p><p><a href="https://www.cnblogs.com/mgdzy/p/13644475.html">Intel-Pin的windows安装</a></p><hr><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><p>在source/tools中新建一个文件夹PinTool1</p><p>在里面写一个cpp文件，我直接在ManualExample文件里面复制了，命名为pintool.cpp，然后同样复制一个makefile.rules和makefile文件，makefile.rule文件里面把TEST_TOOL_ROOTS后面的内容改为pintool：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEST_TOOL_ROOTS := pintool</span><br></pre></td></tr></table></figure><p>并把后面的附加内容删掉</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(TARGET_OS)</span>,windows)</span><br><span class="line">    TEST_TOOL_ROOTS += w_malloctrace buffer_windows emudiv replacesigprobed dumpargv</span><br><span class="line">    APP_ROOTS += divide_by_zero</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>然后直接make tools，这里不知道为什么如果使用make TARGET=Intel64会报错不支持的架构，但是直接make也可以生成64位的dll</p><p>然后依旧任意找个exe测试</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pin -t obj-intel64/pintool.dll -o log.log -- divide_by_zero.exe</span><br></pre></td></tr></table></figure><p>成功。</p><h3 id="使用VS写代码"><a href="#使用VS写代码" class="headerlink" title="使用VS写代码"></a>使用VS写代码</h3><p>创建新项目，但是修改编译环境：</p><p><a href="https://lzeroyuee.cn/2021/02/18/Intel-Pin的安装与配置/">Intel Pin的安装与配置 | lzeroyuee’s blog</a></p><p>在目录<code>%PinDir%\source\tools\MyPinTool</code>下有示例代码，使用VS编译即可，编译中可能存在错误，对照错误提示修改，主要的编译环境配置如下：</p><ul><li><p><code>C/C++ --&gt; 常规 --&gt; 附加包含目录</code>添加如下路径：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">..</span>\<span class="string">..</span>\include\pin</span><br><span class="line"><span class="string">..</span>\<span class="string">..</span>\include\pin\gen</span><br><span class="line"><span class="string">..</span>\InstLib</span><br><span class="line"><span class="string">..</span>\<span class="string">..</span>\<span class="string">..</span>\extras\components\include</span><br><span class="line"><span class="string">..</span>\<span class="string">..</span>\<span class="string">..</span>\extras\stlport\include</span><br><span class="line"><span class="string">..</span>\<span class="string">..</span>\<span class="string">..</span>\extras</span><br><span class="line"><span class="string">..</span>\<span class="string">..</span>\<span class="string">..</span>\extras\libstdc++\include</span><br><span class="line"><span class="string">..</span>\<span class="string">..</span>\<span class="string">..</span>\extras\crt\include</span><br><span class="line"><span class="string">..</span>\<span class="string">..</span>\<span class="string">..</span>\extras\crt</span><br><span class="line"><span class="string">..</span>\<span class="string">..</span>\<span class="string">..</span>\extras\crt\include\kernel\uapi</span><br><span class="line"><span class="string">..</span>\<span class="string">..</span>\<span class="string">..</span>\extras\crt\include\kernel\uapi\asm-x86</span><br><span class="line"></span><br><span class="line">对x86需要额外添加：</span><br><span class="line"><span class="string">..</span>\<span class="string">..</span>\<span class="string">..</span>\extras\crt\include\arch-x86</span><br><span class="line"><span class="string">..</span>\<span class="string">..</span>\<span class="string">..</span>\extras\xed-ia32\include\xed</span><br><span class="line"></span><br><span class="line">对x64需要额外添加：</span><br><span class="line"><span class="string">..</span>\<span class="string">..</span>\<span class="string">..</span>\extras\crt\include\arch-x86_64</span><br><span class="line"><span class="string">..</span>\<span class="string">..</span>\<span class="string">..</span>\extras\xed-intel64\include\xed</span><br></pre></td></tr></table></figure></li><li><p><code>链接器 --&gt; 高级 --&gt; 映像具有安全异常处理程序</code>设置为<strong>否</strong></p></li><li><p><code>链接器 --&gt; 输入 --&gt; 附加依赖项</code>添加如下项目：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pin.<span class="keyword">lib</span></span><br><span class="line">xed.<span class="keyword">lib</span></span><br><span class="line">pinvm.<span class="keyword">lib</span></span><br><span class="line">pincrt.<span class="keyword">lib</span></span><br><span class="line">kernel32.<span class="keyword">lib</span></span><br><span class="line">crtbeginS.obj</span><br><span class="line"></span><br><span class="line">x86需要额外添加：</span><br><span class="line">ntdll-<span class="number">32</span>.<span class="keyword">lib</span></span><br><span class="line"></span><br><span class="line">x64需要额外添加：</span><br><span class="line">ntdll-<span class="number">64</span>.<span class="keyword">lib</span></span><br></pre></td></tr></table></figure></li></ul><p>然后就可以写代码了。编译的时候还是使用vs x64 native执行make指令来编译</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="插桩粒度"><a href="#插桩粒度" class="headerlink" title="插桩粒度"></a>插桩粒度</h3><h4 id="trace-instumentation"><a href="#trace-instumentation" class="headerlink" title="trace instumentation"></a>trace instumentation</h4><p>在一个代码序列(从某个指令开始到控制流语句)第一次执行前插桩，用<code>TRACE_AddInstrumentFunction</code>实现</p><h4 id="instruction-instrumentation"><a href="#instruction-instrumentation" class="headerlink" title="instruction instrumentation"></a>instruction instrumentation</h4><p>指令插桩，用<code>INS_AddInstrumentFunction</code>实现</p><h4 id="image-instrumentation"><a href="#image-instrumentation" class="headerlink" title="image instrumentation"></a>image instrumentation</h4><p>映像插桩，在映像加载时执行，使用<code>IMG_AddInstrumentFunction</code>实现，需要初始化符号信息：<code>PIN_InitSysmbols</code></p><h4 id="routine-instrumentation"><a href="#routine-instrumentation" class="headerlink" title="routine instrumentation"></a>routine instrumentation</h4><p>例程插桩，在映像加载时执行，使用<code>RTN_AddInstrumentFunction</code>实现</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>翻译来自<a href="https://bbs.kanxue.com/thread-269711.htm">有毒的学Pin记录</a>，部分例子省略，只摘抄了相对重要的部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pin.H&quot;</span></span></span><br><span class="line">FILE* trace;</span><br><span class="line"><span class="comment">// 在每条指令执行前都会被调用，打印出当前指令的地址</span></span><br><span class="line">VOID <span class="title function_">printip</span><span class="params">(VOID* ip)</span> &#123; <span class="built_in">fprintf</span>(trace, <span class="string">&quot;%p\n&quot;</span>, ip); &#125;</span><br><span class="line"><span class="comment">// 遇到一条新指令调用一次</span></span><br><span class="line">VOID <span class="title function_">Instruction</span><span class="params">(INS ins, VOID* v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在每条指令前插入对 printip 函数的调用，并传递 ip 参数</span></span><br><span class="line">    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)printip, IARG_INST_PTR, IARG_END);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结束函数</span></span><br><span class="line">VOID <span class="title function_">Fini</span><span class="params">(INT32 code, VOID* v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(trace, <span class="string">&quot;#eof\n&quot;</span>);</span><br><span class="line">    fclose(trace);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"><span class="comment">/* Print Help Message                                                    */</span></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line">INT32 <span class="title function_">Usage</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    PIN_ERROR(<span class="string">&quot;This Pintool prints the IPs of every instruction executed\n&quot;</span> + KNOB_BASE::StringKnobSummary() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"><span class="comment">/* Main                                                                  */</span></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    trace = fopen(<span class="string">&quot;itrace.out&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (PIN_Init(argc, argv)) <span class="keyword">return</span> Usage();</span><br><span class="line">    <span class="comment">// 桩指令注册</span></span><br><span class="line">    INS_AddInstrumentFunction(Instruction, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 结束逻辑注册</span></span><br><span class="line">    PIN_AddFiniFunction(Fini, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 开始执行，不返回</span></span><br><span class="line">    PIN_StartProgram();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>INS_AddInstrumentFunction注册了回调，PIN_AddFiniFunction作为程序退出时的处理函数</p><p>INS_InsertCall说明了插入的功能在什么时候触发，函数指针是什么，以及传参</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">Instruction</span><span class="params">(INS ins, VOID* v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取指令中的内存操作数计数</span></span><br><span class="line">    UINT32 memOperands = <span class="built_in">INS_MemoryOperandCount</span>(ins);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 遍历指令中的每个内存操作数</span></span><br><span class="line">    <span class="keyword">for</span> (UINT32 memOp = <span class="number">0</span>; memOp &lt; memOperands; memOp++)</span><br><span class="line">    &#123;       </span><br><span class="line">          <span class="comment">// 如果是内存读</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">INS_MemoryOperandIsRead</span>(ins, memOp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">INS_InsertPredicatedCall</span>(ins, IPOINT_BEFORE, (AFUNPTR)RecordMemRead, IARG_INST_PTR, IARG_MEMORYOP_EA, memOp,</span><br><span class="line">                                     IARG_END);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 在某些架构下，内存操作数可以同时用作读和写，例如 IA-32 的 %eax，这种情况下只记录一次</span></span><br><span class="line">        <span class="comment">// 如果是写</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">INS_MemoryOperandIsWritten</span>(ins, memOp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">INS_InsertPredicatedCall</span>(ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite, IARG_INST_PTR, IARG_MEMORYOP_EA, memOp,</span><br><span class="line">                                     IARG_END);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子使用了内存模块</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pin 在 image 加载时调用该函数，在该例中没有进行插桩</span></span><br><span class="line"><span class="function">VOID <span class="title">ImageLoad</span><span class="params">(IMG img, VOID* v)</span> </span>&#123; TraceFile &lt;&lt; <span class="string">&quot;Loading &quot;</span> &lt;&lt; <span class="built_in">IMG_Name</span>(img) &lt;&lt; <span class="string">&quot;, Image id = &quot;</span> &lt;&lt; <span class="built_in">IMG_Id</span>(img) &lt;&lt; endl; &#125;</span><br><span class="line"><span class="comment">// Pin 在 image 卸载时调用该函数，对于将要卸载的image无法进行插桩</span></span><br><span class="line"><span class="function">VOID <span class="title">ImageUnload</span><span class="params">(IMG img, VOID* v)</span> </span>&#123; TraceFile &lt;&lt; <span class="string">&quot;Unloading &quot;</span> &lt;&lt; <span class="built_in">IMG_Name</span>(img) &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 符号初始化</span></span><br><span class="line">    <span class="built_in">PIN_InitSymbols</span>();</span><br><span class="line">    <span class="comment">// pin 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">PIN_Init</span>(argc, argv)) <span class="keyword">return</span> <span class="built_in">Usage</span>();</span><br><span class="line">    TraceFile.<span class="built_in">open</span>(KnobOutputFile.<span class="built_in">Value</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 注册加载桩函数</span></span><br><span class="line">    <span class="built_in">IMG_AddInstrumentFunction</span>(ImageLoad, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 注册卸载桩函数</span></span><br><span class="line">    <span class="built_in">IMG_AddUnloadFunction</span>(ImageUnload, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 注册退出函数</span></span><br><span class="line">    <span class="built_in">PIN_AddFiniFunction</span>(Fini, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 开始执行，无返回</span></span><br><span class="line">    <span class="built_in">PIN_StartProgram</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">Trace</span><span class="params">(TRACE trace, VOID* v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 访问 trace 中的每个 bbl</span></span><br><span class="line">    <span class="keyword">for</span> (BBL bbl = <span class="built_in">TRACE_BblHead</span>(trace); <span class="built_in">BBL_Valid</span>(bbl); bbl = <span class="built_in">BBL_Next</span>(bbl))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在每个 bbl 前插入对 docount 函数的调用，传入指令数量</span></span><br><span class="line">        <span class="built_in">BBL_InsertCall</span>(bbl, IPOINT_BEFORE, (AFUNPTR)docount, IARG_UINT32, <span class="built_in">BBL_NumIns</span>(bbl), IARG_END);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><h4 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    IPOINT_INVALID,</span><br><span class="line"></span><br><span class="line">    IPOINT_BEFORE, <span class="comment">///&lt; 在被插桩对象的第一条指令之前插入一次调用。总是有效。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * 在被插桩对象最后一条指令的顺序执行路径上（如果存在该顺序执行路径）插入一次调用。</span></span><br><span class="line"><span class="comment">     * 对于例程 (RTN)：对所有返回路径都进行插桩。总是有效。</span></span><br><span class="line"><span class="comment">     * 对于指令 (INS)：仅当 INS_IsValidForIpointAfter() 返回 true 时才有效。</span></span><br><span class="line"><span class="comment">     * 对于基本块 (BBL)：仅当 BBL_HasFallThrough() 返回 true 时才有效。</span></span><br><span class="line"><span class="comment">     * 对于追踪 (TRACE)：仅当 TRACE_HasFallThrough() 返回 true 时才有效。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IPOINT_AFTER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * 在被插桩对象的任意位置插入一次调用。</span></span><br><span class="line"><span class="comment">     * 除了 INS_InsertIfCall() 和 INS_InsertThenCall() 之外，适用于所有插桩函数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IPOINT_ANYWHERE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * 在被插桩对象中控制流指令的被采取分支上插入一次调用。</span></span><br><span class="line"><span class="comment">     * 对于指令而言，仅当 INS_IsValidForIpointTakenBranch() 返回 true 时才有效。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IPOINT_TAKEN_BRANCH</span><br><span class="line">&#125; IPOINT;</span><br></pre></td></tr></table></figure><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    IARG_INVALID,</span><br><span class="line">    IARG_ADDRINT, <span class="comment">///&lt; Type: ADDRINT. Constant value (additional arg required)</span></span><br><span class="line">    IARG_PTR,     <span class="comment">///&lt; Type: &quot;VOID *&quot;. Constant value (additional pointer arg required)</span></span><br><span class="line">    IARG_BOOL,    <span class="comment">///&lt; Type: BOOL. Constant (additional BOOL arg required)</span></span><br><span class="line">    IARG_UINT32,  <span class="comment">///&lt; Type: UINT32. Constant (additional integer arg required)</span></span><br><span class="line">    IARG_UINT64,  <span class="comment">///&lt; Type: UINT64. Constant (additional UINT64 arg required)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: ADDRINT. The address of the instrumented instruction. This value does not change at IPOINT_AFTER.</span></span><br><span class="line"><span class="comment">     * This is simply shorthand for &lt;tt&gt;IARG_ADDRINT, INS_Address(ins)&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_INST_PTR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: ADDRINT for integer registers. Value of a register (additional register arg required) @ref REG</span></span><br><span class="line"><span class="comment">     * Basically, this cannot be used to retrieve the value of registers whose size is larger than ADDRINT</span></span><br><span class="line"><span class="comment">     * (e.g. x87 FPU/XMM/YMM/ZMM/opmask) or registers which are not architectural (REG_PIN_*), but there are some</span></span><br><span class="line"><span class="comment">     * exceptions to this rule.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_REG_VALUE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: @ref UINT8*.</span></span><br><span class="line"><span class="comment">     *      Pointer to buffer holding the content of the requested register. buffer size is the size of the requested register.</span></span><br><span class="line"><span class="comment">     *      Register is specified in additional argument.</span></span><br><span class="line"><span class="comment">     * Register is updated back to the relevant application register (Meaning if you change values in the mentioned pointer they will</span></span><br><span class="line"><span class="comment">     * be propagated to the relevant application register). If you&#x27;re not interested in modifying the register value, but only read</span></span><br><span class="line"><span class="comment">     * its value use IARG_REG_CONST_REFERENCE instead.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Not supported in Probe mode or with the Buffering APIs.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @note additional REG arg required!!!</span></span><br><span class="line"><span class="comment">     * @note If the requested register is a tile register and AMX is in init state (i.e., not active) - a NULL pointer will be</span></span><br><span class="line"><span class="comment">     *       passed to the analysis routine as the reference argument.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_REG_REFERENCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: @ref UINT8*.</span></span><br><span class="line"><span class="comment">     *      Pointer to buffer holding the content of the requested register. buffer size is the size of the requested register.</span></span><br><span class="line"><span class="comment">     *      Register is specified in additional argument.</span></span><br><span class="line"><span class="comment">     * Registers are not updated back to the relevant application register (Meaning if you change values in the mentioned pointer</span></span><br><span class="line"><span class="comment">     * they will not be propagated to the relevant application register). If you&#x27;re interested in modifying the register value,</span></span><br><span class="line"><span class="comment">     * use IARG_REG_REFERENCE instead.</span></span><br><span class="line"><span class="comment">     * Not supported with the Buffering APIs.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @note additional REG arg required!!!</span></span><br><span class="line"><span class="comment">     * @note If the requested register is a tile register and AMX is in init state (i.e., not active) - a NULL pointer will be</span></span><br><span class="line"><span class="comment">     *       passed to the analysis routine as the reference argument.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_REG_CONST_REFERENCE,</span><br><span class="line"></span><br><span class="line">    IARG_MEMORYREAD_EA, <span class="comment">///&lt; Type: ADDRINT. Effective address of a memory read, only valid if INS_IsMemoryRead is true and at IPOINT_BEFORE</span></span><br><span class="line">    IARG_MEMORYREAD2_EA, <span class="comment">///&lt; Type: ADDRINT. Effective address of a 2nd memory read (e.g. 2nd operand in cmps on ia32), only valid at IPOINT_BEFORE</span></span><br><span class="line">    IARG_MEMORYWRITE_EA, <span class="comment">///&lt; Type: ADDRINT. Effective address of a memory write, only valid at IPOINT_BEFORE</span></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: UINT32. Size in bytes of memory read.</span></span><br><span class="line"><span class="comment">     * This IARG is applicable for all instructions for which @ref INS_hasKnownMemorySize returns TRUE.</span></span><br><span class="line"><span class="comment">     * For other instructions e.g. vgather/vscatter see @ref IARG_MULTI_ELEMENT_OPERAND.</span></span><br><span class="line"><span class="comment">     * For the varying memory size read instruction, XRSTOR, the size is based on the XSAVE area header. If the header</span></span><br><span class="line"><span class="comment">     * indicates compact mode it will provide the compact size. Otherwise it will provide the standard size.</span></span><br><span class="line"><span class="comment">     * The minimum size for the XRSTOR instruction (not including FXRSTOR) is 576 (i.e the XSAVE area size up</span></span><br><span class="line"><span class="comment">     * to and including the header).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_MEMORYREAD_SIZE,</span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: UINT32. Size in bytes of memory write.</span></span><br><span class="line"><span class="comment">     * This IARG is applicable for all instructions for which @ref INS_hasKnownMemorySize returns TRUE.</span></span><br><span class="line"><span class="comment">     * For other instructions e.g. vgather/vscatter see @ref IARG_MULTI_ELEMENT_OPERAND.</span></span><br><span class="line"><span class="comment">     * For varying size memory write instructions, the supported instructions are the XSAVE family of instructions.</span></span><br><span class="line"><span class="comment">     * For XSAVE, the size of the XSAVE area used is based on user request and supported features in the machine. This will</span></span><br><span class="line"><span class="comment">     * provide the exact size used.</span></span><br><span class="line"><span class="comment">     * For XSAVEOPT, the size is calculated the same as if XSAVE was used. This may provide in some cases an upper</span></span><br><span class="line"><span class="comment">     * bound to the actual used memory.</span></span><br><span class="line"><span class="comment">     * For XSAVEC, in IPOINT_BEFORE the size is calculated based on user request only. This may provide in some cases</span></span><br><span class="line"><span class="comment">     * an upper bound to the actual size.</span></span><br><span class="line"><span class="comment">     * If used in IPOINT_AFTER it will provide the exact compact size as defined in the XSAVE area header.</span></span><br><span class="line"><span class="comment">     * The minimum size for the XSAVE family write instructions (not including FXSAVE) is 576 (i.e the XSAVE area</span></span><br><span class="line"><span class="comment">     * size up to and including the header).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_MEMORYWRITE_SIZE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IARG_MEMORY*_PTR argument represents actual address of the memory access, even if the operand is rewritten</span></span><br><span class="line">    <span class="comment">// or a memory translation callback is registered</span></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Actual address of the memory access; same as @ref IARG_MEMORYREAD_EA, unless the memory address is translated</span></span><br><span class="line"><span class="comment">     * by @ref MEMORY_ADDR_TRANS_CALLBACK, or the memory operand is rewritten by @ref INS_RewriteMemoryOperand</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_MEMORYREAD_PTR,</span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Actual address of the memory access; same as @ref IARG_MEMORYREAD2_EA, unless the memory address is translated</span></span><br><span class="line"><span class="comment">     * by @ref MEMORY_ADDR_TRANS_CALLBACK, or the memory operand is rewritten by @ref INS_RewriteMemoryOperand</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_MEMORYREAD2_PTR,</span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Actual address of the memory access. Same as @ref IARG_MEMORYWRITE_EA, unless the memory address is translated</span></span><br><span class="line"><span class="comment">     * by @ref MEMORY_ADDR_TRANS_CALLBACK, or the memory operand is rewritten by @ref INS_RewriteMemoryOperand</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_MEMORYWRITE_PTR,</span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Actual address of the memory access. Same as @ref IARG_MEMORYOP_EA, unless the memory address is translated</span></span><br><span class="line"><span class="comment">     * by @ref MEMORY_ADDR_TRANS_CALLBACK, or the memory operand is rewritten by @ref INS_RewriteMemoryOperand. \n</span></span><br><span class="line"><span class="comment">     * When using @ref INS_RewriteMemoryOperand the value is valid only with IPOINT_AFTER.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_MEMORYOP_PTR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: PIN_MULTI_MEM_ACCESS_INFO* the addresses read by the various vgather* instructions,</span></span><br><span class="line"><span class="comment">     * Also available for regular memory instructions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_MULTI_MEMORYACCESS_EA,</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: @ref IMULTI_ELEMENT_OPERAND * . Information about a multi element operand (implemented for IPOINT_BEFORE).</span></span><br><span class="line"><span class="comment">     * The operand index is required as the next argument.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_MULTI_ELEMENT_OPERAND,   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: @ref ISCATTERED_MEMORY_REWRITE * . Interface that allows rewriting elemenets addresses for instructions </span></span><br><span class="line"><span class="comment">     *       with scattered memory access (implemented for IPOINT_BEFORE).</span></span><br><span class="line"><span class="comment">     *       Only valid for instructions where @ref INS_IsValidForIarg for this IARG returns TRUE.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_REWRITE_SCATTERED_MEMOP,</span><br><span class="line"></span><br><span class="line">    IARG_EXPLICIT_MEMORY_EA, <span class="comment">///&lt; Type: ADDRINT. Effective address of the explicit memory operand. Useful for instrumenting LEA instructions</span></span><br><span class="line"></span><br><span class="line">    IARG_BRANCH_TAKEN, <span class="comment">///&lt; Type: BOOL. Non zero if a branch is taken. Argument is invalid for XBEGIN and XEND instructions.</span></span><br><span class="line">    <span class="comment">/*! Type: ADDRINT. Target address of branch instruction.\n</span></span><br><span class="line"><span class="comment">     *   In case of INS instrumentation, valid when @ref INS_IsControlFlow() is true.\n</span></span><br><span class="line"><span class="comment">     *   However, this argument is invalid if the instruction is XBEGIN or XEND.</span></span><br><span class="line"><span class="comment">     *   In Linux, for the case of branching into the vsyscall area (in kernel 5.3 or above), the target</span></span><br><span class="line"><span class="comment">     *   address that will be received in the analysis routine would be that of the vsyscall area. Note that</span></span><br><span class="line"><span class="comment">     *   this address is not readable (e.g. via PIN_SafeCopy() and PIN_FetchCode())</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_BRANCH_TARGET_ADDR,</span><br><span class="line">    <span class="comment">/*! Type: ADDRINT. Fall through address of the instrumented object.\n</span></span><br><span class="line"><span class="comment">     *  In case of INS instrumentation, valid only if @ref INS_HasFallThrough() is true.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_FALLTHROUGH_ADDR,</span><br><span class="line"></span><br><span class="line">    IARG_EXECUTING, <span class="comment">///&lt; Type: BOOL. False if the instruction will not be executed because of predication, otherwise true.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*! Type: BOOL. True if INS_HasRealRep(ins) and this the first iteration of the REP sequence, otherwise false.\n</span></span><br><span class="line"><span class="comment">     *  @note In case count register is 0 when calling analysis routine, the value of IARG_FIRST_REP_ITERATION is false.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_FIRST_REP_ITERATION,</span><br><span class="line">    IARG_PREDICATE, <span class="comment">///&lt; Reserved. Do not use</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// These are internal only</span></span><br><span class="line">    IARG_STACK_VALUE,      <span class="comment">///&lt; Reserved. Do not use</span></span><br><span class="line">    IARG_STACK_REFERENCE,  <span class="comment">///&lt; Reserved. Do not use</span></span><br><span class="line">    IARG_MEMORY_VALUE,     <span class="comment">///&lt; Reserved. IA32(e) only</span></span><br><span class="line">    IARG_MEMORY_REFERENCE, <span class="comment">///&lt; Reserved. IA32(e) only</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Syscall stuff</span></span><br><span class="line">    IARG_SYSCALL_NUMBER,   <span class="comment">///&lt; Type: ADDRINT. System call number. Valid for IPOINT_BEFORE at the system call instruction</span></span><br><span class="line">    IARG_SYSARG_REFERENCE, <span class="comment">///&lt; Type: &quot;ADDRINT *&quot;. Pointer to system call argument n. Valid for IPOINT_BEFORE at the system call instruction.  (First argument number is 0.)</span></span><br><span class="line"></span><br><span class="line">    IARG_SYSARG_VALUE, <span class="comment">///&lt; Type: ADDRINT. System call argument n. Valid for IPOINT_BEFORE at the system call instruction.  (First argument number is 0.)</span></span><br><span class="line">    IARG_SYSRET_VALUE, <span class="comment">///&lt; Type: ADDRINT. System call return value. On Linux and macOS* the value is -1 if the system call failed. (IPOINT_AFTER only)</span></span><br><span class="line">    IARG_SYSRET_ERRNO, <span class="comment">///&lt; Type: INT32. System call errno (IPOINT_AFTER_only).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// function arguments</span></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: &quot;ADDRINT *&quot;. Pointer to integer argument n. Valid only at the call site.  (First argument number is 0.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    IARG_FUNCARG_CALLSITE_REFERENCE,</span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: ADDRINT. Integer argument n. Valid only at the call site.  (First argument number is 0.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_FUNCARG_CALLSITE_VALUE,</span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: &quot;ADDRINT *&quot;. Pointer to integer argument n. Valid only at the entry point of a routine.  (First argument number is 0.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_FUNCARG_ENTRYPOINT_REFERENCE,</span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: ADDRINT. Integer argument n. Valid only at the entry point of a routine.  (First argument number is 0.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_FUNCARG_ENTRYPOINT_VALUE,</span><br><span class="line">    IARG_FUNCRET_EXITPOINT_REFERENCE, <span class="comment">///&lt; Type: &quot;ADDRINT *&quot;. Pointer to function result. Valid only at return instruction.</span></span><br><span class="line">    IARG_FUNCRET_EXITPOINT_VALUE,     <span class="comment">///&lt; Type: ADDRINT. Function result. Valid only at return instruction.</span></span><br><span class="line"></span><br><span class="line">    IARG_RETURN_IP, <span class="comment">///&lt; Type: ADDRINT. Return address for function call, valid only at the function entry point.</span></span><br><span class="line"></span><br><span class="line">    IARG_ORIG_FUNCPTR, <span class="comment">///&lt; Type: AFUNPTR. Function pointer to the relocated entry of the original uninstrumented function.</span></span><br><span class="line"></span><br><span class="line">    IARG_PROTOTYPE, <span class="comment">///&lt; Type: PROTO.  The function prototype of the application function. See @ref PROTO</span></span><br><span class="line"></span><br><span class="line">    IARG_THREAD_ID, <span class="comment">///&lt; Type: THREADID. Application thread id.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: @ref CONTEXT *. Handle to access a context (architectural state).  When passed at</span></span><br><span class="line"><span class="comment">     * @ref IPOINT_AFTER or @ref IPOINT_TAKEN_BRANCH, PC points to the next instruction.  Upon return from</span></span><br><span class="line"><span class="comment">     * the analysis routine, Pin ignores any changes you&#x27;ve made to the @ref CONTEXT.  If you want</span></span><br><span class="line"><span class="comment">     * to change register values, use @ref IARG_REG_REFERENCE, @ref IARG_RETURN_REGS, or @ref PIN_ExecuteAt.</span></span><br><span class="line"><span class="comment">     * See @ref PROBE_IARGS for probe mode restrictions.  Not supported with the Buffering APIs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_CONTEXT,</span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: @ref CONTEXT *.</span></span><br><span class="line"><span class="comment">     * Like @ref IARG_CONTEXT, but tool receives a read-only @ref CONTEXT*.</span></span><br><span class="line"><span class="comment">     * @ref PIN_SetContextReg, @ref PIN_SetContextRegval and @ref PIN_SetContextFPState will not work with</span></span><br><span class="line"><span class="comment">     * @ref IARG_CONST_CONTEXT.</span></span><br><span class="line"><span class="comment">     * The overhead of @ref IARG_CONST_CONTEXT is considerably lower than that of @ref IARG_CONTEXT.</span></span><br><span class="line"><span class="comment">     * Tools that need a @ref CONTEXT* and only read from it should use @ref IARG_CONST_CONTEXT.</span></span><br><span class="line"><span class="comment">     * Tools that need a @ref CONTEXT* and only occasionally write into it should also use @ref IARG_CONST_CONTEXT (by</span></span><br><span class="line"><span class="comment">     * using PIN_SaveContext() - see below).</span></span><br><span class="line"><span class="comment">     * One example of a tool that needs a @ref CONTEXT * and only occasionally writes into it, would be an</span></span><br><span class="line"><span class="comment">     * emulator that would need to write into the @ref CONTEXT * only when an exception occurs, and then</span></span><br><span class="line"><span class="comment">     * raise an exception with the @ref CONTEXT *.</span></span><br><span class="line"><span class="comment">     * @ref PIN_SaveContext can be used by the tool to get a writable copy of the @ref CONTEXT *.</span></span><br><span class="line"><span class="comment">     * @ref IARG_CONST_CONTEXT is available only in Jit mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_CONST_CONTEXT,</span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: @ref CONTEXT *. Additional two @ref REGSET * arguments are needed &#x27;inSet&#x27; and &#x27;outSet&#x27;.</span></span><br><span class="line"><span class="comment">     * Like @ref IARG_CONTEXT, but tool needs to define also which registers set it needs to read (inSet)</span></span><br><span class="line"><span class="comment">     * and which registers set it may write (outSet).</span></span><br><span class="line"><span class="comment">     * @ref PIN_SetContextReg, @ref PIN_SetContextRegval and @ref PIN_SetContextFPState will work only on registers</span></span><br><span class="line"><span class="comment">     * that are in the outSet. These functions will change the actual application registers so there is no need</span></span><br><span class="line"><span class="comment">     * to perform @ref PIN_ExecuteAt as need to be done with @ref IARG_CONTEXT.</span></span><br><span class="line"><span class="comment">     * @ref PIN_GetContextReg, @ref PIN_GetContextRegval and @ref PIN_GetContextFPState will return unexpected values</span></span><br><span class="line"><span class="comment">     * for registers not defined in the &#x27;inSet&#x27;.</span></span><br><span class="line"><span class="comment">     * The overhead of @ref IARG_PARTIAL_CONTEXT may lower than that of @ref IARG_CONTEXT as there is no need to perform</span></span><br><span class="line"><span class="comment">     * @ref PIN_ExecuteAt to update registers.</span></span><br><span class="line"><span class="comment">     * Tools that know which application registers are needed to be read should use @ref IARG_PARTIAL_CONTEXT instead of</span></span><br><span class="line"><span class="comment">     * @ref IARG_CONST_CONTEXT. Thus may reduce the overhead as not fully updated context for read need to be provided.</span></span><br><span class="line"><span class="comment">     * Tools that know which application registers are needed to be written other than @ref REG_INST_PTR should use</span></span><br><span class="line"><span class="comment">     * @ref IARG_PARTIAL_CONTEXT instead of combination of @ref IARG_CONTEXT and the use of @ref PIN_ExecuteAt</span></span><br><span class="line"><span class="comment">     * for registers update.</span></span><br><span class="line"><span class="comment">     * If @ref REG_INST_PTR needs to be updated @ref PIN_ExecuteAt still needs to be used.</span></span><br><span class="line"><span class="comment">     * Any updates to a register from the outSet of an @ref IARG_PARTIAL_CONTEXT will be propagated to the application upon</span></span><br><span class="line"><span class="comment">     * return from the analysis routine. Tools that want to update @ref CONTEXT registers without affecting application</span></span><br><span class="line"><span class="comment">     * registers should use @ref IARG_CONTEXT.</span></span><br><span class="line"><span class="comment">     * @ref IARG_PARTIAL_CONTEXT is available only in Jit mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_PARTIAL_CONTEXT,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * Type: @ref REGSET *.</span></span><br><span class="line"><span class="comment">     * Used to specify registers whose values will be the same upon return from the analysis routine.</span></span><br><span class="line"><span class="comment">     * Should be used to specify caller-saved registers which are preserved by the analysis routine.</span></span><br><span class="line"><span class="comment">     * When a non-inlinable analysis routine preserves caller-saved registers, Pin can avoid generating</span></span><br><span class="line"><span class="comment">     * code to preserve these registers, across the analysis call, if they are specified in the IARG_PRESERVE.</span></span><br><span class="line"><span class="comment">     * e.g. if a non-inlinable analysis routine preserves the values in the x87 registers, then Pin</span></span><br><span class="line"><span class="comment">     * can avoid generating code to preserve these registers, across the analysis call, if REG_X87 is specified in</span></span><br><span class="line"><span class="comment">     * the @ref IARG_PRESERVE</span></span><br><span class="line"><span class="comment">     * e.g. if a non-inlinable analysis routine preserves the values in XMM caller saved registers, then Pin</span></span><br><span class="line"><span class="comment">     * can avoid generating code to preserve these registers, across the analysis call, if those preserved XMM</span></span><br><span class="line"><span class="comment">     * registers are specified in the @ref IARG_PRESERVE</span></span><br><span class="line"><span class="comment">     * @ref IARG_PRESERVE must be followed by a @ref REGSET* that points to the @ref REGSET containing the registers preserved.</span></span><br><span class="line"><span class="comment">     * See the @ref REGSET_AddAll &quot;(REGSET_*)&quot; functions defined under @ref REG for @ref REGSET construction and manipulation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_PRESERVE,</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*! Type: BOOL.</span></span><br><span class="line"><span class="comment">     * Used to mark analysis routine that is expected to be inlined.</span></span><br><span class="line"><span class="comment">     * If the analysis ruotine is not inlinable and -assert_check_inline has been passed then Pin will assert.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IARG_CHECK_INLINE,</span><br><span class="line"></span><br><span class="line">    IARG_RETURN_REGS, <span class="comment">///&lt; Register to write analysis function return value (additional register arg required).  Not supported in Probe mode.</span></span><br><span class="line"></span><br><span class="line">    IARG_CALL_ORDER, <span class="comment">///&lt; Type: CALL_ORDER. Determine order of analysis calls. See @ref CALL_ORDER.</span></span><br><span class="line"></span><br><span class="line">    IARG_IARGLIST, <span class="comment">///&lt; Type: IARGLIST. List of IARGS which can be constructed one IARG at a time.</span></span><br><span class="line"></span><br><span class="line">    IARG_FAST_ANALYSIS_CALL, <span class="comment">///&lt; No type: Use a fast linkage to call the analysis function. See @ref PIN_FAST_ANALYSIS_CALL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">    * Type: @ref REGSET *.</span></span><br><span class="line"><span class="comment">    * The only supported register for now is REG_MXCSR. In case it is not included into the register set</span></span><br><span class="line"><span class="comment">    * then an error is issued.</span></span><br><span class="line"><span class="comment">    * . Upon entry to the analysis routine, the MXCSR physical register value is loaded with the application value.</span></span><br><span class="line"><span class="comment">    * . Upon termination of the routine the physical MXCSR register including the changes are visible by</span></span><br><span class="line"><span class="comment">    *   the application.</span></span><br><span class="line"><span class="comment">    * . As a side effect, the analysis routine will never be inlined.</span></span><br><span class="line"><span class="comment">    * @ref IARG_EXPOSE must be followed by a @ref REGSET* that points to the @ref REGSET containing the registers</span></span><br><span class="line"><span class="comment">    * exposed, REG_MXCSR must be included and be the only one.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    IARG_EXPOSE, </span><br><span class="line"></span><br><span class="line">    IARG_MEMORYOP_EA, <span class="comment">///&lt; Type: ADDRINT. Effective address of a memory op (memory op index is next arg); only valid at IPOINT_BEFORE</span></span><br><span class="line">    IARG_MEMORYOP_SIZE, <span class="comment">///&lt; Type: UINT32. Size of a memory op (memory op index is next arg)</span></span><br><span class="line">    IARG_MEMORYOP_MASKED_ON, <span class="comment">///&lt; Type: BOOL. TRUE if the this memory op (memory op index is next arg) is masked on; only valid at IPOINT_BEFORE</span></span><br><span class="line">    IARG_TSC,                <span class="comment">///&lt; Type: UINT64. Time Stamp Counter value at the point of entering the analysis call.</span></span><br><span class="line">    IARG_FILE_NAME, <span class="comment">///&lt; Reserved for internal use only.</span></span><br><span class="line">    IARG_LINE_NO,   <span class="comment">///&lt; Reserved for internal use only.</span></span><br><span class="line">    IARG_LAST       <span class="comment">///&lt; Reserved for internal use only.</span></span><br><span class="line"></span><br><span class="line">&#125; IARG_TYPE;</span><br></pre></td></tr></table></figure><p>这里类型是IARG_INST_PTR，表示当前指令地址，IARG_END表示参数列表结尾</p><h4 id="插桩函数"><a href="#插桩函数" class="headerlink" title="插桩函数"></a>插桩函数</h4><p>这里的插桩函数是由AddFunction函数设置的函数中的CALL函数</p><p>具体有很多，可以vs双击直接看定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">INS_InsertPredicatedCall</span><br><span class="line">INS_InsertCall</span><br><span class="line">INS_InsertIfCall</span><br><span class="line">INS_InsertThenCall</span><br><span class="line">INS_InsertIfPredicatedCall</span><br><span class="line">INS_InsertThenPredicatedCall</span><br><span class="line"></span><br><span class="line">BBL_InsertCall</span><br><span class="line">BBL_InsertIfCall</span><br><span class="line">BBL_InsertThenCall</span><br><span class="line"></span><br><span class="line">TRACE_InsertCall</span><br><span class="line">TRACE_InsertIfCall</span><br><span class="line">TRACE_InsertThenCall</span><br><span class="line"></span><br><span class="line"><span class="comment">//IMAGE没有插桩函数，只有设置某个时机回调函数的AddFunction函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="注册函数"><a href="#注册函数" class="headerlink" title="注册函数"></a>注册函数</h4><p>内容来自<a href="https://bbs.kanxue.com/thread-269836.htm">有毒的学Pin记录</a></p><ul><li>INS_AddInstrumentFunction (INSCALLBACK fun, VOID *val)：注册以指令粒度插桩的函数</li><li>TRACE_AddInstrumentFunction (TRACECALLBACK fun, VOID *val)：注册以trace粒度插桩的函数</li><li>RTN_AddInstrumentFunction (RTNCALLBACK fun, VOID *val)：注册以routine粒度插桩的函数</li><li>IMG_AddInstrumentFunction (IMGCALLBACK fun, VOID *val)：注册以image粒度插桩的函数</li><li>PIN_AddFiniFunction (FINICALLBACK fun, VOID *val)：注册在应用程序退出前执行的函数，该类函数不进行插桩，可以有多个。</li><li>PIN_AddDetachFunction (DETACHCALLBACK fun, VOID *val)：注册在Pin通过PIN_Detach()函数放弃对应用程序的控制权限之前执行的函数，一个进程只调用一次，可以被任何线程调用，此时Pin的内存并没有释放。</li></ul><h4 id="修改指令的代码"><a href="#修改指令的代码" class="headerlink" title="修改指令的代码"></a>修改指令的代码</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INS_InsertDirectJump</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">INS_InsertIndirectJump</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">INS_RewriteMemoryOperand</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>指令执行时，每条指令调用一次插桩函数，但是调用多次分析代码，所以尽量将大部分判断放到插桩函数中，然后再在插桩函数中执行精简后的分析代码，而不是把大部分操作放到分析代码中。</p><p>其它的优化性能内容见：<a href="https://bbs.kanxue.com/thread-269836.htm">有毒的学Pin记录</a></p><h2 id="有关链接"><a href="#有关链接" class="headerlink" title="有关链接"></a>有关链接</h2><p><a href="https://anhkgg.com/pin-use-note-function-analysis/">pin使用小记-函数分析 | Anhkgg’Lab | Windows Kernel | Rootkit | Reverse Engineer | Expolit | 内核研究 | 逆向分析 | 漏洞分析挖掘</a></p><p><a href="https://bbs.kanxue.com/article-16660.htm">bbs.kanxue.com/article-16660.htm</a></p><p><a href="https://zhuanlan.zhihu.com/p/75456977">使用 Pin 来实现对 Windows 函数及其参数的追踪</a></p>]]></content>
    
    
    <summary type="html">不喜欢frida，只好学Windows上其它的插桩了QAQ</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="技能" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/"/>
    
    <category term="插桩" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/%E6%8F%92%E6%A1%A9/"/>
    
    
    <category term="re" scheme="https://www.pri87.vip/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://www.pri87.vip/posts/de7c53fe.html"/>
    <id>https://www.pri87.vip/posts/de7c53fe.html</id>
    <published>2025-05-22T02:58:12.000Z</published>
    <updated>2025-05-22T10:07:05.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="池"><a href="#池" class="headerlink" title="池"></a>池</h1><p>池是一种以空间换时间的思想。对于内存，线程，连接这类资源，每次使用时都需要申请，申请完后都要释放。一旦内存块/线程/连接数变多，这之中的资源消耗就会变多，因此我们可以先申请一定数量的资源，等待需要使用时，可以直接在高层分配，而不需要向操作系统申请，在使用完后，也不直接销毁，而是清空，等待下一次循环使用，这就是池。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>通过先在池中生成一定数量的线程，先令其挂起，等待有新的线程任务时再执行。结束后回归池，实现资源复用。</p><h3 id="具体结构"><a href="#具体结构" class="headerlink" title="具体结构"></a>具体结构</h3><ul><li>池本身(逻辑结构，并不实际存在)：需要实现创建池，销毁池，和外部添加任务。</li><li>作业队列：外部添加的任务全部会按顺序加入这个队列，等待工作线程获取并执行。</li><li>工作线程：以一个循环包裹的线程，循环中无限等待作业队列是否有新任务并处理。</li></ul><p>作业队列需要在任务添加时立即通知所有的工作线程，让工作线程可以尝试获取新任务。<br>工作线程获取新任务时，要确保其它工作线程不能获取同一个任务。</p><h3 id="具体逻辑"><a href="#具体逻辑" class="headerlink" title="具体逻辑"></a>具体逻辑</h3><p>内存池类：</p><ul><li>创建池：创建n个工作线程和一个作业队列，初始化上面需要的锁getwork和条件变量ispushing。</li><li>作业队列：一个队列，每个元素是作业结构，其中有函数CallBack和传参args。</li><li>添加任务的公开函数：传入一个CallBack生成一个作业结构push到队列末尾。并用WakeAllConditionVariable唤醒所有等待ispushing的工作线程。</li><li>工作线程：处于循环，先EnterCriticalSection getwork，如果没有任务，等待ispushing，否则取任务，并执行。</li><li>销毁线程池：设置一个flag标志，如果工作线程检测到flag，同时没有任务，立即return。然后销毁作业队列和线程池本身。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadPool.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(*pCallBack)</span><span class="params">(PVOID args)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Job</span></span><br><span class="line">&#123;</span><br><span class="line">pCallBack _callBack;</span><br><span class="line">PVOID _args;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::queue&lt;Job&gt; jobQueue;<span class="comment">//任务队列</span></span><br><span class="line">std::vector&lt;HANDLE&gt; threads; <span class="comment">// 线程句柄</span></span><br><span class="line">CRITICAL_SECTION cs; <span class="comment">// 互斥锁</span></span><br><span class="line">CONDITION_VARIABLE cv; <span class="comment">// 条件变量</span></span><br><span class="line"><span class="type">int</span> maxJob;</span><br><span class="line"><span class="type">int</span> threadNum;</span><br><span class="line"><span class="type">bool</span> stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> DWORD WINAPI <span class="title">ThreadFunc</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ThreadPool* pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(lpParam);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;pool-&gt;cs);</span><br><span class="line"><span class="keyword">while</span> (pool-&gt;jobQueue.<span class="built_in">empty</span>() &amp;&amp; !pool-&gt;stop)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 等待时会释放互斥锁,如果被唤醒，又会得到互斥锁</span></span><br><span class="line"><span class="built_in">SleepConditionVariableCS</span>(&amp;pool-&gt;cv, &amp;pool-&gt;cs, INFINITE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;jobQueue.<span class="built_in">empty</span>() &amp;&amp; pool-&gt;stop)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;pool-&gt;cs);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Job job = pool-&gt;jobQueue.<span class="built_in">front</span>();</span><br><span class="line">pool-&gt;jobQueue.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;pool-&gt;cs);</span><br><span class="line"><span class="keyword">if</span> (job._callBack)</span><br><span class="line">&#123;</span><br><span class="line">job._callBack(job._args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allThreadExitIfStop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WakeAllConditionVariable</span>(&amp;cv);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ithread : threads)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(ithread, INFINITE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(ithread);</span><br><span class="line">&#125;</span><br><span class="line">threads.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ThreadPool</span>(<span class="type">int</span> threadNum = <span class="number">4</span>, <span class="type">int</span> maxJob = <span class="number">100</span>)</span><br><span class="line">: <span class="built_in">maxJob</span>(maxJob), <span class="built_in">threadNum</span>(threadNum), <span class="built_in">stop</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (maxJob &lt;= <span class="number">0</span> || threadNum &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;maxJob and threadNum must be greater than 0.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化互斥锁和条件变量</span></span><br><span class="line"><span class="built_in">InitializeCriticalSection</span>(&amp;cs);</span><br><span class="line"><span class="built_in">InitializeConditionVariable</span>(&amp;cv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建工作线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line">HANDLE thread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="keyword">this</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (thread == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">stop = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">allThreadExitIfStop</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">DeleteCriticalSection</span>(&amp;cs);</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;CreateThread failed.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">threads.<span class="built_in">push_back</span>(thread);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 停止线程池</span></span><br><span class="line">stop = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">allThreadExitIfStop</span>();</span><br><span class="line"><span class="built_in">DeleteCriticalSection</span>(&amp;cs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">addWork</span><span class="params">(pCallBack callBack, PVOID args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//防止刚好有操作队列的线程</span></span><br><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;cs);</span><br><span class="line"><span class="keyword">if</span> (jobQueue.<span class="built_in">size</span>() &gt;= maxJob)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;cs);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">jobQueue.<span class="built_in">push</span>(&#123; callBack, args &#125;);</span><br><span class="line"><span class="comment">//push完立即唤醒一个线程</span></span><br><span class="line"><span class="built_in">WakeConditionVariable</span>(&amp;cv);</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;cs);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ThreadPool.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">myWork</span><span class="params">(PVOID i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; <span class="built_in">GetCurrentThreadId</span>() &lt;&lt; <span class="string">&quot; is working on task &quot;</span> &lt;&lt; *(PDWORD)i &lt;&lt; endl;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">500</span>); <span class="comment">// Simulate work</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> startTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">ThreadPool pool = <span class="built_in">ThreadPool</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">DWORD* arg = <span class="keyword">new</span> <span class="built_in">DWORD</span>(i);</span><br><span class="line">pool.<span class="built_in">addWork</span>(myWork, arg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇介绍如何实现线程池</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="数据结构与算法" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="池" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%B1%A0/"/>
    
    
    <category term="多线程" scheme="https://www.pri87.vip/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="CPP" scheme="https://www.pri87.vip/tags/CPP/"/>
    
    <category term="池" scheme="https://www.pri87.vip/tags/%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>windows上的hook对抗</title>
    <link href="https://www.pri87.vip/posts/20ac0c84.html"/>
    <id>https://www.pri87.vip/posts/20ac0c84.html</id>
    <published>2025-05-19T11:23:09.000Z</published>
    <updated>2025-05-19T17:25:05.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h1><p>hook是逆向中一种基本操作，它的作用对象是函数(代码块)，作用效果是在执行某个函数之前/之时/之后立即执行用户定义的过程。我们将加载这个hook到这个函数的过程称为挂钩，将从函数取消这个hook的过程称为脱钩。</p><p>本文是hook原理的总结，没有涉及实践</p><h2 id="基于修改代码的Hook"><a href="#基于修改代码的Hook" class="headerlink" title="基于修改代码的Hook"></a>基于修改代码的Hook</h2><h3 id="最简单的inlineHook"><a href="#最简单的inlineHook" class="headerlink" title="最简单的inlineHook"></a>最简单的inlineHook</h3><ul><li>先获取目标函数的地址</li><li>将目标函数地址前x字节改为jmp跳转，跳转到自己函数的地址</li><li>最后执行刚刚被覆盖的指令，然后跳转回去</li></ul><p>简单，但是无法确定被覆盖的指令的长度，同时如果被覆盖的指令含有ip索引或短跳转，则会报错，需要手动脱钩</p><h3 id="trampolineHook"><a href="#trampolineHook" class="headerlink" title="trampolineHook"></a>trampolineHook</h3><p>基于上面的缺点，通过构造一个新函数，在新函数中调用原函数，调用之前，调用之后都可以执行自己需要的操作。</p><ul><li>获取目标函数地址</li><li>将目标函数地址前x字节改为jmp跳转，跳转到下一步这个函数的地址，并保存前x字节</li><li>构造一个新函数，使得传入传出类型(调用约定)相同<ul><li>将前x字节还原</li><li>hook代码</li><li>执行原函数</li><li>hook代码</li><li>将前x字节重新设置为该函数开头</li><li>返回</li></ul></li></ul><p>这样，就不需要担心被覆盖的指令的执行问题，同时，这个hook可以自动恢复挂钩，如果是多线程，也许会出现挂钩不到的情况？</p><h3 id="CRC32检测Hook"><a href="#CRC32检测Hook" class="headerlink" title="CRC32检测Hook"></a>CRC32检测Hook</h3><p>针对以上两种基于修改代码实现的hook，只需要通过实现一个CRC32校验函数去检查对应函数是否被修改即可。</p><p>需要已知目标的CRC32值，或者在很早的时候先执行，保存原始CRC32值，在某个时刻或开启新线程循环检查计算的CRC32值是否相同即可，这种方法也可以实现对断点的检测。</p><h3 id="更改页属性正面对抗CRC32检测"><a href="#更改页属性正面对抗CRC32检测" class="headerlink" title="更改页属性正面对抗CRC32检测"></a>更改页属性正面对抗CRC32检测</h3><p>如果CRC32是先执行，然后保存，可以在进程启动时立即hook实现绕过，但是这样只能用基本inlinehook，否则trampolineHook还原代码时也会被检测到。</p><p>CRC32检测代码时，需要读取代码段数据，通过将代码段的页设为不可读或使用硬件断点为函数加上读断点，可以找到CRC32检测代码，然后hook这个代码即可令检测失效。</p><p>与此同时，如果还有n个CRC32检测代码，第i个检测第i+1个，第n个检测真实代码，那么就需要对所有的代码进行hook。在实际场景中，防不胜防，在游戏逆向时，往往可能导致封号造成损失，所以需要注意。这就是在量上的对抗升级？</p><h2 id="基于表的Hook"><a href="#基于表的Hook" class="headerlink" title="基于表的Hook"></a>基于表的Hook</h2><h3 id="IAT-hook"><a href="#IAT-hook" class="headerlink" title="IAT hook"></a>IAT hook</h3><p>在hook外部导入函数时，可以对IAT进行hook，基本方法是：</p><ul><li>IAT初始化后，读取IAT对应的位置，找到jmp后面的offset，计算出正确的函数地址</li><li>实现一个hook函数，最后jmp到正确的函数地址</li><li>将offset设置为到hook函数的偏移</li></ul><p>对于kernel32函数和ntdll函数这样设置都比较方便</p><h3 id="API-Set-Map-Hook-DLL注入"><a href="#API-Set-Map-Hook-DLL注入" class="headerlink" title="API Set Map Hook(DLL注入)"></a>API Set Map Hook(DLL注入)</h3><p>打开进程时，系统根据API Set Map设置导入的不同dll 函数的正确映射dll，因此，通过挂起创建的进程，先修改对应的map，实现对某个dll中全部函数的hook。</p><ul><li>用注入器进程创建目标进程</li><li>将目标peb的ApiSetMap拷贝出来，添加自己的dll到结构末尾</li><li>将上面的内容拷贝到目标的新地址空间</li><li>让目标ApiSetMap指针指向对应位置</li><li>执行进程</li></ul><h3 id="CPP虚函数表Hook"><a href="#CPP虚函数表Hook" class="headerlink" title="CPP虚函数表Hook"></a>CPP虚函数表Hook</h3><p>CPP中实现子类调用父类虚函数(自己实现的函数)时，使用了虚函数表，通过修改虚函数表，实现调用hook的函数。类实例开头存放着虚函数表，其中有所有可调用的函数地址。它们有固定的顺序。通过修改这个来实现Hook一个类的成员方法</p><p>具体过程省略，和签名的IAThook相同</p><h3 id="SSDT-Hook"><a href="#SSDT-Hook" class="headerlink" title="SSDT Hook"></a>SSDT Hook</h3><p>SSDT是系统服务描述符表，在内核层。执行系统调用的时候，会在这个表中寻找对应的函数地址，从而执行。</p><ul><li>绕过写保护和Patchguard</li><li>写入SSDT表</li><li>后续过程与IAThook相同</li></ul><p><a href="https://www.cnblogs.com/revercc/p/14701592.html">HOOK技术之SSDT hook（x86/x64）</a></p><h3 id="IDT-Hook"><a href="#IDT-Hook" class="headerlink" title="IDT Hook"></a>IDT Hook</h3><p>IDT是中断描述符表，描述了CPU遇到中断/异常时该转向哪里去处理它们。IDT对应单个CPU核心，hook时，需要hook所有表。内核层。</p><p><a href="https://bbs.kanxue.com/thread-59867.htm">[原创]rootkit hook之[四]— IDT Hook</a></p><h3 id="对抗"><a href="#对抗" class="headerlink" title="对抗"></a>对抗</h3><p>对于表，依旧是数据，因此对应层的CRC32检测依然有效，这就回到了上面的正面对抗</p><h2 id="基于消息分发的Hook"><a href="#基于消息分发的Hook" class="headerlink" title="基于消息分发的Hook"></a>基于消息分发的Hook</h2><h3 id="IRP-hook"><a href="#IRP-hook" class="headerlink" title="IRP hook"></a>IRP hook</h3><p>依旧是内核层，不会。之后学。</p><p><a href="https://bbs.kanxue.com/thread-60022.htm">[原创]rootkit hook 之[五] — IRP Hook全家福-软件逆向-看雪-安全社区|安全招聘|kanxue.com</a></p><h3 id="对抗-1"><a href="#对抗-1" class="headerlink" title="对抗"></a>对抗</h3><p>hook都不会，还对抗？QAQ</p><h2 id="基于异常分发的Hook"><a href="#基于异常分发的Hook" class="headerlink" title="基于异常分发的Hook"></a>基于异常分发的Hook</h2><p>hook本质上就是在程序运行的特定时机修改控制流执行一些代码，因此异常分发，中断，调用等等都可以实现hook。</p><p>在CPU遇到异常时会进入异常分发，在异常分发的流程中进行一些修改即可实现hook。</p><h3 id="R3层"><a href="#R3层" class="headerlink" title="R3层"></a>R3层</h3><p>AddVectoredExceptionHandler可以为一个函数增加异常处理函数，如果遇到异常，会直接触发增加的函数。因此通过设置软/硬件断点，故意触发设置的函数即可实现hook。</p><p>过程略。</p><h3 id="VT层"><a href="#VT层" class="headerlink" title="VT层"></a>VT层</h3><p>由于host(宿主机)可以接管guest(虚拟机)的所有错误触发，可以通过开启EPT扩展页表设置guest的某些页表属性为不可读不可写可执行，当guest试图读写时，触发EPT异常，将</p><ul><li>生成一个新页，内容是自己的hook函数</li><li>将原来的页前几字节设为jmp</li><li>将原来的页设为不可读不可写可执行</li><li>如果读写，则会触发EPT异常<ul><li>异常处理函数将页设为可读可写不可执行并恢复页的前几个字节</li></ul></li><li>如果执行，且当前是可读可写不可执行，触发EPT异常<ul><li>异常处理函数将页设为不可读不可写可执行，并设置jmp</li></ul></li></ul><p><a href="https://qi4l.github.io/2024/08/04/浅谈EPT无痕HOOK的方法/">浅谈EPT无痕HOOK的方法 | QI4L的沉思录</a></p><h3 id="对抗-2"><a href="#对抗-2" class="headerlink" title="对抗"></a>对抗</h3><p>R3层可以通过临时注册函数挤掉之前注册的异常处理函数</p><p>VT层可以通过优先VT(自己先成为host)，先设置不可读不可写来保护程序。但是一般也没用应该。。。</p>]]></content>
    
    
    <summary type="html">总结一下遇见的hook</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="技能" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/"/>
    
    <category term="Hook" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/Hook/"/>
    
    
    <category term="hook" scheme="https://www.pri87.vip/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>web开发入门</title>
    <link href="https://www.pri87.vip/posts/f9fc672b.html"/>
    <id>https://www.pri87.vip/posts/f9fc672b.html</id>
    <published>2025-05-17T11:18:19.000Z</published>
    <updated>2025-05-19T17:25:05.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇是我在学前端的时候做的笔记，可能比较混乱</p><p>大概分为四个部分：HTML，CSS，JS，Vue</p><p>任何一个页面的渲染，都是由 HTML 文件实现的，HTML 是一种超文本标记语言，类似于 markdown 语法，用它可以实现基本的不同文本的显示效果，比如：加粗，改颜色等等，同时引入了各种标签比如容器，针对一个段落来进行添加不同属性，但是其中最重要的，是表单，它是 HTML 前端代码和后端交流的核心组件</p><hr><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>一个标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>html 的格式由 <> </> 标签进行区分，一般分为 head 和 body，head 中可以设定这个 html 使用的基本字符集和标题等效果。body 中则可以添加各种内容实现文字/图片的渲染</p><h3 id="各种标签"><a href="#各种标签" class="headerlink" title="各种标签"></a>各种标签</h3><h4 id="head-标签"><a href="#head-标签" class="headerlink" title="head 标签"></a>head 标签</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://myweb/imgaes/&quot;</span>&gt;</span><span class="comment">&lt;!--表示默认链接--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span><span class="comment">&lt;!--导入外部样式表--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>:yellow;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>:blue</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span><span class="comment">&lt;!--内部样式表，一般不用，一般直接link外部--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;元信息，不详细说明了&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>js脚本<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="body-标签"><a href="#body-标签" class="headerlink" title="body 标签"></a>body 标签</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标签，可以将数字改大变为其它等级的标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    aaaa<span class="tag">&lt;<span class="name">br</span>&gt;</span>左边是一个换行，如果只有一个段落可以用这个换行</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span> <span class="comment">&lt;!-- 左边是水平分割线--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://pri87.vip&quot;</span>&gt;</span>这是一个链接。在标签中有等号的是属性值，比如这个的href还有下面那个src等等<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://pri87.vip/a.pdf&quot;</span> <span class="attr">download</span>=<span class="string">&quot;example.pdf&quot;</span>&gt;</span>表明下载而不是跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/属性值必须用引号.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;11&quot;</span> <span class="attr">height</span>=<span class="string">&quot;11&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;如果没加载出来则显示&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;color_red fort_size_big&quot;</span>&gt;</span>class可以定义类,用于css样式选择器,用空格隔开定义两个类<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="comment">&lt;!-- 表格--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行1，列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行1，列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行1，列3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行2，列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行2，列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行2，列3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="comment">&lt;!-- 无序列表--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span><span class="comment">&lt;!-- 有序列表--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="格式化文本效果"><a href="#格式化文本效果" class="headerlink" title="格式化文本效果"></a>格式化文本效果</h4><div class="table-container"><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><b></td><td style="text-align:left">定义粗体文本</td></tr><tr><td style="text-align:left"><em></td><td style="text-align:left">定义着重文字</td></tr><tr><td style="text-align:left"><i></td><td style="text-align:left">定义斜体字</td></tr><tr><td style="text-align:left"><small></td><td style="text-align:left">定义小号字</td></tr><tr><td style="text-align:left"><strong></td><td style="text-align:left">定义加重语气</td></tr><tr><td style="text-align:left"><sub></td><td style="text-align:left">定义下标字</td></tr><tr><td style="text-align:left"><sup></td><td style="text-align:left">定义上标字</td></tr><tr><td style="text-align:left"><ins></td><td style="text-align:left">定义插入字</td></tr><tr><td style="text-align:left"><del></td><td style="text-align:left">定义删除字</td></tr></tbody></table></div><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><h5 id="内联使用"><a href="#内联使用" class="headerlink" title="内联使用"></a>内联使用</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:blue;margin-left:20px;&quot;</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;font-family:verdana;&quot;</span>&gt;</span>一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;font-family:arial;color:red;font-size:20px;&quot;</span>&gt;</span>一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;&quot;</span>&gt;</span>居中对齐的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="内联样式表"><a href="#内联样式表" class="headerlink" title="内联样式表"></a>内联样式表</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>:yellow;&#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue;&#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="区块与布局"><a href="#区块与布局" class="headerlink" title="区块与布局"></a>区块与布局</h3><p>区块用于分组内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        h1,p,ul,table等是块级元素，每个都会占一行</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        b,td,a,img是内联元素，下一个元素在这一个元素之后继续，而不会换行</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        区块可以将多个元素组合，是块级元素，用来对大的内容块进行样式设置</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>而span是内联元素，用来给少部分文本设置样式<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>布局用于分块整个页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:500px&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#FFA500;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;margin-bottom:0;&quot;</span>&gt;</span>主要的网页标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;menu&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#FFD700;height:200px;width:100px;float:left;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">b</span>&gt;</span>菜单<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            HTML<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            CSS<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            JavaScript</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#EEEEEE;height:200px;width:400px;float:left;&quot;</span>&gt;</span></span><br><span class="line">        内容在这里</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#FFA500;clear:both;text-align:center;&quot;</span>&gt;</span></span><br><span class="line">        喵喵喵<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css 的 float 属性为不同 id 设置了不同位置取消了块级元素基本设定，通过不同的宽高来组合实现布局</p><p>布局十分重要，是好看的网站效果必须的内容</p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>表单是收集用户输入，实现高级功能最重要的东西。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文本输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 密码输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 单选按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>性别:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 复选框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;subscribe&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subscribe&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;subscribe&quot;</span>&gt;</span>订阅推送信息<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 下拉列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;country&quot;</span>&gt;</span>国家:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;country&quot;</span> <span class="attr">name</span>=<span class="string">&quot;country&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;cn&quot;</span>&gt;</span>CN<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;usa&quot;</span>&gt;</span>USA<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;uk&quot;</span>&gt;</span>UK<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 提交按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面是例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span> <span class="attr">action</span>=<span class="string">&quot;html_form_action.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输入元素：<input> 标签，输入类型由 type 定义</p><p>具体类别见上</p><p>submit 中，定义了 action 传给的文件，method 是传递方式，post 和 get</p><p>post 是在报文体中发送，get 则是在 action 属性的 url 中用?作为分隔符发送</p><h2 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h2><p>之后只会直接放在 css 文件中而不是直接内嵌在 html 代码中</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>格式：选择器+样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">默认选择器</span><br><span class="line">*&#123;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">元素选择器</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">类选择器,.开头</span><br><span class="line"><span class="selector-class">.oneclass</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line">id选择器,id是唯一的</span><br><span class="line"><span class="selector-id">#title1</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line">合并选择器</span><br><span class="line"><span class="selector-tag">h3</span>,<span class="selector-tag">h2</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择器优先级：行内样式&gt;ID选择器&gt;类选择器&gt;元素选择器&gt;默认</p><hr><p>后代选择器：选择E中的所有F</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E F&#123;&#125;</span><br></pre></td></tr></table></figure><p>子代选择器：选择E下一级的F</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E&gt;F&#123;&#125;</span><br></pre></td></tr></table></figure><p>相邻兄弟选择器：选择E和后面相邻的P</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E+<span class="selector-tag">P</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>通用兄弟选择器：选择E和后面所有的P</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E~<span class="selector-tag">P</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><h4 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h4><h5 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">color</span>:<span class="number">#ff0000</span>;&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>);&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0.5</span>);&#125;</span><br></pre></td></tr></table></figure><h5 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;&#125;</span><br></pre></td></tr></table></figure><h5 id="粗细"><a href="#粗细" class="headerlink" title="粗细"></a>粗细</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">font-weight</span>:normal;&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">font-weight</span>:bolder;&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">font-weight</span>:lighter;&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">font-weight</span>:<span class="number">100</span>;&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">font-weight</span>:<span class="number">900</span>;&#125;</span><br></pre></td></tr></table></figure><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">font-style</span>:normal;&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">font-style</span>:italic;&#125;</span><br></pre></td></tr></table></figure><h5 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">font-family</span>:<span class="string">&quot;A字体&quot;</span>,<span class="string">&quot;B字体&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">background-color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&quot;1.jpg&quot;</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">background-position</span><span class="selector-pseudo">:left</span> <span class="attribute">top</span>;&#125;设置起始位置</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">background-position</span>:center bottom;&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">background-position</span><span class="selector-pseudo">:right</span> center;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">background-repeat</span>:repeat&#125;平铺方式</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">background-repeat</span>:repeat-x&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">background-repeat</span>:repeat-y&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">background-repeat</span>:no-repeat&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">background-size</span>:<span class="number">1000px</span> <span class="number">1200px</span>&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">background-size</span>:<span class="number">50%</span> <span class="number">50%</span>&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">background-size</span>:cover&#125;最小填充满</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">background-size</span>:contain&#125;最大缩放满</span><br></pre></td></tr></table></figure><h4 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">text-align</span>:center&#125;水平对齐</span><br><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">text-align</span><span class="selector-pseudo">:left</span>&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">text-align</span><span class="selector-pseudo">:right</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">text-decoration</span>:overline&#125;加线</span><br><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">text-decoration</span>:line-through&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">text-decoration</span>:underline&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">text-transform</span>:captialize&#125;大小写</span><br><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">text-transform</span>:uppercase&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">text-transform</span>:lowercase&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">text-indent</span>:<span class="number">50px</span>&#125;首行缩进</span><br></pre></td></tr></table></figure><p>太多了，之后只放重点一点的</p><h4 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h4><p>略</p><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>外边距，边框，内边距，实际内容</p><p>内边距：padding，使得内容靠中心</p><p>边框：border，就是边框</p><p>外边距：margin，元素和元素的间隔</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">50px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">5px</span> solid blue; </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>:<span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>:<span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>:<span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>:<span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h3><p>弹性盒子内默认横向摆放</p><p>略</p><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>脱离文档流，在新的层出现会覆盖底层，在浮动层可以让元素横向排放</p><p>略</p><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>绝对定位和固定定位会脱离文档流</p><p>略</p><h3 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h3><h4 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#123;<span class="attribute">border-radius</span>:<span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span></span><br></pre></td></tr></table></figure><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> name&#123;</span><br><span class="line">    <span class="selector-tag">from</span>|<span class="number">0%</span>&#123;</span><br><span class="line">        css样式</span><br><span class="line">    &#125;</span><br><span class="line">    percent&#123;</span><br><span class="line">        css样式</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span>|<span class="number">100%</span>&#123;</span><br><span class="line">        css样式</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attribute">animation</span>: name duration timeing-function delay iteration-count direction;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鼠标划上的效果</p><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>根据设备及时修正大小，排布</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span><span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=l,maximum-scale=l,user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>略</p><h3 id="雪碧图"><a href="#雪碧图" class="headerlink" title="雪碧图"></a>雪碧图</h3><p>略</p><h3 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h3><p>略</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="引入JS"><a href="#引入JS" class="headerlink" title="引入JS"></a>引入JS</h3><h4 id="嵌入html"><a href="#嵌入html" class="headerlink" title="嵌入html"></a>嵌入html</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> age = <span class="number">10</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="引入本地js"><a href="#引入本地js" class="headerlink" title="引入本地js"></a>引入本地js</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;./hello.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入网络js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;http://code.jquery.com/jquery1.2.1.min.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇介绍web浏览器页面显示的基础</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>编译器实现-1</title>
    <link href="https://www.pri87.vip/posts/1195dca5.html"/>
    <id>https://www.pri87.vip/posts/1195dca5.html</id>
    <published>2025-05-12T11:29:46.000Z</published>
    <updated>2025-05-19T17:25:05.327Z</updated>
    
    <content type="html"><![CDATA[<p>这几周一直在研究怎么写编译器，算是这一年学花指令的最后学习了吧。这个写完之后，就专心学Win内核QAQ</p><p>目前还没有把编译器写完，所以现在只是先总结一下流程。</p><p>目前我遵循的流程是：</p><ul><li>输入文本</li><li>token流：将输入的文本解析为token字，它是最小的基本词汇，比如把+=视为1个符号，把abcd视为标识符。此处会进行词法检查。</li><li>抽象语法树(AST)：将token流解析为抽象语法树，以语句块(节点)为基本单位，装载在不同函数块(节点)中。生成结束后，再进行语法检查。</li><li>三地址码：将抽象语法树按自顶向下的(从块到句)解析为三地址码，三地址码类似汇编，比如：a += b + c这个AST，会变为tmp = b+c，a = a + tmp，这种方式可以很方便地在下一步映射中间变量为寄存器。</li><li>汇编代码：三地址码转化为汇编基本只用实现寄存器初始化，使用和销毁。这一步可以和三地址码一起使用，也就是说可以省略三地址码，直接从抽象语法树转换为汇编。</li></ul><h2 id="生成token流"><a href="#生成token流" class="headerlink" title="生成token流"></a>生成token流</h2><p>这一步需要通过读取文本，解析文本结构来实现输出token流，可以先对输入的内容分类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字符:<span class="string">&#x27;&#x27;</span></span><br><span class="line">字符串：<span class="string">&quot;&quot;</span></span><br><span class="line">数字：数字开头纯数字，<span class="number">0</span>x开头且字母小于F的hex值</span><br><span class="line">关键字：控制流关键字(main,<span class="keyword">if</span>,<span class="keyword">continue</span>,<span class="keyword">break</span>,<span class="keyword">return</span>,等),类型关键字(<span class="keyword">void</span>,<span class="built_in">int</span>,dword,<span class="built_in">byte</span>,proc,<span class="keyword">struct</span>,等)</span><br><span class="line">符号：运算符：(+,-,*,%,/,等)，间隔符：((),&#123;&#125;,[],;)</span><br><span class="line">标识符：字母开头的不含运算符和间隔符的任意内容。且不与关键字重复。</span><br></pre></td></tr></table></figure><p>那么就可以对以上内容进行顺序判断实现生成token流，因为是第一次写，所以类型写的比较混乱，QAQ之后有机会改一改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Token</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::string originaldata;</span><br><span class="line">ttoken tokenData;</span><br><span class="line">TYPE tokenType;</span><br><span class="line"><span class="built_in">Token</span>(std::string data, ttoken type, TYPE type_)</span><br><span class="line">: <span class="built_in">originaldata</span>(data), <span class="built_in">tokenData</span>(type), <span class="built_in">tokenType</span>(type_) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ttoken <span class="title">type</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> tokenData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isType</span><span class="params">(ttoken type)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> tokenData == type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Token a) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> tokenData == a.tokenData;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parser</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; origalCode;</span><br><span class="line">std::vector&lt;Token&gt; TokenList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parser</span>(std::string soureCodePath)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::ifstream <span class="title">file</span><span class="params">(soureCodePath, std::ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">is_open</span>())</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;文件打开失败&quot;</span>);</span><br><span class="line">file.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::end);</span><br><span class="line">std::streamsize dataSize = file.<span class="built_in">tellg</span>();</span><br><span class="line">file.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::beg);</span><br><span class="line">origalCode.<span class="built_in">resize</span>(dataSize);</span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">read</span>(origalCode.<span class="built_in">data</span>(), dataSize))</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;拷贝文件至缓冲区失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lexicalAnalysis</span><span class="params">()</span></span>;<span class="comment">//词法分析</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> pomnet</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> inner &#123;</span><br><span class="line"><span class="comment">//获得下一个值,不递增pdata</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">getNext</span><span class="params">(<span class="type">char</span>*&amp; pdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> pdata[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符是否为数字</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDigit</span><span class="params">(<span class="type">char</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (data &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; data &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isHex</span><span class="params">(<span class="type">char</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isDigit</span>(data))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (data &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; data &lt;= <span class="string">&#x27;f&#x27;</span> || data &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; data &lt;= <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符是否为字母</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isAlpha</span><span class="params">(<span class="type">char</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (data &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; data &lt;= <span class="string">&#x27;z&#x27;</span> || data &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; data &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为非字母和数字</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">notDigitAlpha</span><span class="params">(<span class="type">char</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isAlpha</span>(data) || <span class="built_in">isDigit</span>(data))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">notDigitAlpha_</span><span class="params">(<span class="type">char</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (data == <span class="string">&#x27;_&#x27;</span> || <span class="built_in">isAlpha</span>(data) || <span class="built_in">isDigit</span>(data))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结束</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEndSentence</span><span class="params">(<span class="type">char</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> data == <span class="string">&#x27;;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断块开始或结束</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBlockStart</span><span class="params">(<span class="type">char</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> data == <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBlockEnd</span><span class="params">(<span class="type">char</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> data == <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断数字是否正确闭合，当存在一个值是字母但是不是hex时说明数字输入错误</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNumberEndHex</span><span class="params">(<span class="type">char</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">isHex</span>(data) &amp;&amp; (<span class="built_in">isAlpha</span>(data) || data == <span class="string">&#x27;_&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断数字是否正确闭合，当存在一个值是字母时说明数字输入错误</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNumberEnd</span><span class="params">(<span class="type">char</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isAlpha</span>(data) || data == <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取最长可能串，字母开头,除了下划线和数字和字母以外的最长字符串,同时偏移到字符串结尾,如果是空，说明没有找到</span></span><br><span class="line"><span class="function">std::string <span class="title">getMostData</span><span class="params">(<span class="type">char</span>*&amp; pdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> inner;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">isAlpha</span>(*pdata))</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">string</span>();</span><br><span class="line">std::string result;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">notDigitAlpha_</span>(*pdata))</span><br><span class="line">&#123;</span><br><span class="line">result += *pdata;</span><br><span class="line">pdata++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取最长可能串，数字，如果是空，说明没有找到</span></span><br><span class="line"><span class="function">std::string <span class="title">getMostNumber</span><span class="params">(<span class="type">char</span>*&amp; pdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> inner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">isDigit</span>(*pdata))</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">string</span>();</span><br><span class="line">std::string result;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是0x开头</span></span><br><span class="line"><span class="keyword">if</span> (pdata[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="built_in">getNext</span>(pdata) == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">pdata += <span class="number">2</span>;</span><br><span class="line">result += <span class="string">&quot;0x&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isHex</span>(*pdata))</span><br><span class="line">&#123;</span><br><span class="line">result += *pdata;</span><br><span class="line">pdata++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">isNumberEndHex</span>(*pdata))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;数字未闭合&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//标准数字</span></span><br><span class="line"><span class="keyword">if</span> (pdata[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isDigit</span>(*pdata))</span><br><span class="line">&#123;</span><br><span class="line">result += *pdata;</span><br><span class="line">pdata++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">isNumberEnd</span>(*pdata))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;数字未闭合&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符串为0</span></span><br><span class="line">pdata++;</span><br><span class="line"><span class="keyword">return</span> result = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取最长可能字符串</span></span><br><span class="line"><span class="function">std::string <span class="title">getMostString</span><span class="params">(<span class="type">char</span>*&amp; pdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> inner;</span><br><span class="line">std::string result;</span><br><span class="line"><span class="keyword">if</span> (*pdata == <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">pdata++;</span><br><span class="line">result += <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span> (*pdata != <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*pdata == <span class="string">&#x27;\\&#x27;</span> &amp;&amp; <span class="built_in">getNext</span>(pdata) == <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">pdata++;</span><br><span class="line">result += *pdata;</span><br><span class="line">pdata++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*pdata == <span class="string">&#x27;\\&#x27;</span> &amp;&amp; <span class="built_in">getNext</span>(pdata) == <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">pdata++;</span><br><span class="line">result += *pdata;</span><br><span class="line">pdata++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">result += *pdata;</span><br><span class="line">pdata++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*pdata == <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">result += <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">pdata++;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字符</span></span><br><span class="line"><span class="function">std::string <span class="title">getChar</span><span class="params">(<span class="type">char</span>*&amp; pdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> inner;</span><br><span class="line">std::string result;</span><br><span class="line"><span class="keyword">if</span> (*pdata == <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">pdata++;</span><br><span class="line">result += <span class="string">&#x27;\&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (*pdata == <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">pdata++;</span><br><span class="line">result += *pdata;</span><br><span class="line">pdata++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">result += *pdata;</span><br><span class="line">pdata++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*pdata != <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br><span class="line">result += *pdata;</span><br><span class="line">pdata++;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取符号，如果是空，说明没有找到</span></span><br><span class="line"><span class="function">std::string <span class="title">getMostSymbol</span><span class="params">(<span class="type">char</span>*&amp; pdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> inner;</span><br><span class="line">std::string result;</span><br><span class="line"><span class="keyword">auto</span> targetKey = symbolMap.<span class="built_in">find</span>(result + *pdata);</span><br><span class="line"><span class="keyword">if</span> (targetKey == symbolMap.<span class="built_in">end</span>())</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">auto</span> targetKey2 = symbolMap.<span class="built_in">find</span>(result + *pdata + <span class="built_in">getNext</span>(pdata));</span><br><span class="line"><span class="keyword">if</span> (targetKey2 == symbolMap.<span class="built_in">end</span>())<span class="comment">//长度为1</span></span><br><span class="line">&#123;</span><br><span class="line">result += *pdata;</span><br><span class="line">pdata++;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//长度为2</span></span><br><span class="line">result += *pdata + <span class="built_in">getNext</span>(pdata);</span><br><span class="line">pdata += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接返回对应类型对应源数据的Token类实例</span></span><br><span class="line"><span class="function">Token <span class="title">generateToken</span><span class="params">(std::string data, TYPE type_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (type_)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> identifier:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Token</span>(data, ID_TOKEN, identifier);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> keyword:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> targetKey = keyWordMap.<span class="built_in">find</span>(data);</span><br><span class="line"><span class="keyword">if</span> (targetKey != keyWordMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Token</span>(data, targetKey-&gt;second, keyword);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Token</span>(data, BAD_TOKEN, keyword);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> type:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> targetKey = typeMap.<span class="built_in">find</span>(data);</span><br><span class="line"><span class="keyword">if</span> (targetKey != typeMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Token</span>(data, targetKey-&gt;second, type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Token</span>(data, BAD_TOKEN, type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> number:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Token</span>(data, NUM_TOKEN, number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> string:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Token</span>(data, STR_TOKEN, string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> character:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Token</span>(data, CHR_TOKEN, character);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> symbol:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> targetKey = symbolMap.<span class="built_in">find</span>(data);</span><br><span class="line"><span class="keyword">if</span> (targetKey != symbolMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Token</span>(data, targetKey-&gt;second, symbol);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Token</span>(data, BAD_TOKEN, symbol);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> separator:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (data == <span class="string">&quot;;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Token</span>(data, SY_SEMI, separator);</span><br><span class="line"><span class="keyword">if</span> (data == <span class="string">&quot;&#123;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Token</span>(data, SY_LBRACE, separator);</span><br><span class="line"><span class="keyword">if</span> (data == <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Token</span>(data, SY_RBRACE, separator);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Parser::lexicalAnalysis</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* pdata = origalCode.<span class="built_in">data</span>();</span><br><span class="line"><span class="keyword">auto</span> dataSize = origalCode.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (dataSize == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;源文件为空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> pomnet;</span><br><span class="line"><span class="keyword">while</span> (pdata &lt; origalCode.<span class="built_in">data</span>() + dataSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果是数字</span></span><br><span class="line"><span class="keyword">if</span> (inner::<span class="built_in">isDigit</span>(*pdata))</span><br><span class="line">&#123;</span><br><span class="line">std::string number = <span class="built_in">getMostNumber</span>(pdata);</span><br><span class="line"><span class="keyword">if</span> (number.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;数字未闭合&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">TokenList.<span class="built_in">push_back</span>(<span class="built_in">generateToken</span>(number, TYPE::number));</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是字母开头，两种可能，标识符和关键字</span></span><br><span class="line"><span class="keyword">if</span> (inner::<span class="built_in">isAlpha</span>(*pdata))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">std::string str = <span class="built_in">getMostData</span>(pdata);</span><br><span class="line"><span class="comment">//如果字符串在map中，说明是关键字</span></span><br><span class="line"><span class="keyword">if</span> (keyWordMap.<span class="built_in">find</span>(str) != keyWordMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">TokenList.<span class="built_in">push_back</span>(<span class="built_in">generateToken</span>(str, TYPE::keyword));</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (typeMap.<span class="built_in">find</span>(str) != typeMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">TokenList.<span class="built_in">push_back</span>(<span class="built_in">generateToken</span>(str, TYPE::type));</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果不是关键字，说明是标识符</span></span><br><span class="line">TokenList.<span class="built_in">push_back</span>(<span class="built_in">generateToken</span>(str, TYPE::identifier));</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是符号开头，分隔符，运算符，字符串或字符</span></span><br><span class="line"><span class="keyword">if</span> (inner::<span class="built_in">notDigitAlpha</span>(*pdata))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果是空格</span></span><br><span class="line"><span class="keyword">if</span> (*pdata == <span class="string">&#x27; &#x27;</span> || *pdata == <span class="string">&#x27;\t&#x27;</span> || *pdata == <span class="string">&#x27;\n&#x27;</span> || *pdata == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">pdata++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是字符或字符串</span></span><br><span class="line"><span class="keyword">if</span> (*pdata == <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::string chr = <span class="built_in">getChar</span>(pdata);</span><br><span class="line"><span class="keyword">if</span> (!chr.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">TokenList.<span class="built_in">push_back</span>(<span class="built_in">generateToken</span>(chr, TYPE::character));</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*pdata == <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::string str = <span class="built_in">getMostString</span>(pdata);</span><br><span class="line"><span class="keyword">if</span> (!str.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">TokenList.<span class="built_in">push_back</span>(<span class="built_in">generateToken</span>(str, TYPE::string));</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是分割符</span></span><br><span class="line"><span class="keyword">if</span> (inner::<span class="built_in">isEndSentence</span>(*pdata))</span><br><span class="line">&#123;</span><br><span class="line">TokenList.<span class="built_in">push_back</span>(<span class="built_in">generateToken</span>(<span class="string">&quot;;&quot;</span>, TYPE::separator));</span><br><span class="line">pdata++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inner::<span class="built_in">isBlockEnd</span>(*pdata))</span><br><span class="line">&#123;</span><br><span class="line">TokenList.<span class="built_in">push_back</span>(<span class="built_in">generateToken</span>(<span class="string">&quot;&#125;&quot;</span>, TYPE::separator));</span><br><span class="line">pdata++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inner::<span class="built_in">isBlockStart</span>(*pdata))</span><br><span class="line">&#123;</span><br><span class="line">TokenList.<span class="built_in">push_back</span>(<span class="built_in">generateToken</span>(<span class="string">&quot;&#123;&quot;</span>, TYPE::separator));</span><br><span class="line">pdata++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是符号</span></span><br><span class="line">std::string symbol = <span class="built_in">getMostSymbol</span>(pdata);</span><br><span class="line"><span class="keyword">if</span> (symbol.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;非符号&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">TokenList.<span class="built_in">push_back</span>(<span class="built_in">generateToken</span>(symbol, TYPE::symbol));</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上内容，就可以生成token list</p><h2 id="生成AST"><a href="#生成AST" class="headerlink" title="生成AST"></a>生成AST</h2><p>这一步主要进行语法解析，所以是要对每个函数块的内容实现抽象描述。</p><p>从最基本的抽象开始：表达式</p><p>这里使用partt表达式解析方法。</p><p>在一次解析中，先解析符号是否是前缀运算符，再解析符号是否是中缀运算符，最后判断是否是后缀运算符。</p><p>解析符号生成AST时，使用固定的getGenerateFunc解析函数传入不同的token类型返回生成对应节点的函数</p><p>因此只需要递归调用主函数并在getGenerateFunc返回的函数中实现生成AST即可。</p><p>[未完待续]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这几周一直在研究怎么写编译器，算是这一年学花指令的最后学习了吧。这个写完之后，就专心学Win内核QAQ&lt;/p&gt;
&lt;p&gt;目前还没有把编译器写完，所以现在只是先总结一下流程。&lt;/p&gt;
&lt;p&gt;目前我遵循的流程是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入文本&lt;/li&gt;
&lt;li&gt;token流</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PrattParsing解析表达式</title>
    <link href="https://www.pri87.vip/posts/d6331565.html"/>
    <id>https://www.pri87.vip/posts/d6331565.html</id>
    <published>2025-04-30T14:02:16.000Z</published>
    <updated>2025-05-31T12:50:34.873Z</updated>
    
    <content type="html"><![CDATA[<p>本文是一篇翻译，太悲伤了，不知道怎么翻，机翻还是太好用了，出处：</p><p><a href="https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html">Simple but Powerful Pratt Parsing</a></p><h1 id="简单强大的Pratt-解析"><a href="#简单强大的Pratt-解析" class="headerlink" title="简单强大的Pratt 解析"></a>简单强大的Pratt 解析</h1><p>这篇文章是一个语法解析的monad教程。关于Pratt解析的文章很多，甚至这里有一个<a href="https://www.oilshell.org/blog/2017/03/31.html">合集blog</a></p><p>我写这篇文章的目的是：</p><ul><li>说明左递归问题是容易解决的</li><li>用另一种方式代替不好识别中缀表达式的BNF</li><li>给出Pratt的算法描述和具体实现，并聚焦重点，不引入DSL-y的抽象</li><li>希望这是我最后一次理解这个算法，之前写过一次，但是写完之后就忘了QAQ</li></ul><p>本文假设读者对解析操作有基本的理解，知晓基本术语，比如上下文无关语法</p><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>解析(parser)是编译器将标记的序列转为语法树表示的过程：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                           Add</span><br><span class="line">                Parser     / <span class="string">\</span> </span><br><span class="line"><span class="string">&quot;1 + 2 * 3&quot;</span>    -------&gt;   <span class="number">1</span>  Mul</span><br><span class="line">                             / <span class="string">\</span></span><br><span class="line">                            <span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><p>实现这个过程有很多方式，我们一般分为两类：</p><ul><li>使用DSL定义一个语言的抽象语法</li><li>手动实现解析</li></ul><h2 id="BNF"><a href="#BNF" class="headerlink" title="BNF"></a>BNF</h2><p>语法分析的作用就是将token流解析为树结构，其中最重要的方法就是使用上下文无关语法来记录（一般用BNF语法）</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Item =</span><br><span class="line">    StructItem</span><br><span class="line">  <span class="string">| EnumItem</span></span><br><span class="line">  <span class="string">| ...</span></span><br><span class="line">StructItem =</span><br><span class="line">    &#x27;struct&#x27; Name &#x27;&#123;&#x27; FieldList &#x27;&#125;&#x27;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>自然语言和程序语言结构十分地相似，这让我很激动，BNF可以做到解析它们。但是当我尝试解析表达式的时候，BNF就不好用了。我们先看看自然语言表达式的表达：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Expr</span> =</span><br><span class="line">    <span class="built_in">Expr</span> <span class="string">&#x27;+&#x27;</span> <span class="built_in">Expr</span></span><br><span class="line">  | <span class="built_in">Expr</span> <span class="string">&#x27;*&#x27;</span> <span class="built_in">Expr</span></span><br><span class="line">  | <span class="string">&#x27;(&#x27;</span> <span class="built_in">Expr</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">  | &#x27;number&#x27;</span><br></pre></td></tr></table></figure><p>这样写是没什么问题的，但是还需要考虑运算符的优先级和结合性，所以BNF会变成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Expr =</span><br><span class="line">    Factor</span><br><span class="line">  | Expr <span class="string">&#x27;+&#x27;</span> <span class="type">Factor</span></span><br><span class="line"><span class="variable">Factor</span> <span class="operator">=</span></span><br><span class="line">    Atom</span><br><span class="line">  | Factor <span class="string">&#x27;*&#x27;</span> <span class="type">Atom</span></span><br><span class="line"><span class="variable">Atom</span> <span class="operator">=</span></span><br><span class="line">    <span class="string">&#x27;number&#x27;</span></span><br><span class="line">  | <span class="string">&#x27;(&#x27;</span> Expr <span class="string">&#x27;)&#x27;</span></span><br></pre></td></tr></table></figure><p>这样再看，就会感觉它很不“表达式”。而且很难写，在我能写出来这种语法之前，我多学了至少3，4课才学会。</p><p>这就是为什么我喜欢Pratt解析（基于递归下降而又比它强），它使用自然语言中的优先级和关联性来解析表达式，而不是语法混淆技术(存疑？)</p><h2 id="递归下降和左递归"><a href="#递归下降和左递归" class="headerlink" title="递归下降和左递归"></a>递归下降和左递归</h2><p>下面是使用递归下降实现的上面那个例子的代码，它是用一组嵌套递归的函数来实现的，所以叫递归下降：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">item</span>(p: &amp;<span class="keyword">mut</span> Parser) &#123;</span><br><span class="line">    <span class="keyword">match</span> p.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">        STRUCT_KEYWORD =&gt; <span class="title function_ invoke__">struct_item</span>(p),</span><br><span class="line">        ENUM_KEYWORD   =&gt; <span class="title function_ invoke__">enum_item</span>(p),</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">struct_item</span>(p: &amp;<span class="keyword">mut</span> Parser) &#123;</span><br><span class="line">    p.<span class="title function_ invoke__">expect</span>(STRUCT_KEYWORD);</span><br><span class="line">    <span class="title function_ invoke__">name</span>(p);</span><br><span class="line">    p.<span class="title function_ invoke__">expect</span>(L_CURLY);</span><br><span class="line">    <span class="title function_ invoke__">field_list</span>(p);</span><br><span class="line">    p.<span class="title function_ invoke__">expect</span>(R_CURLY);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>书上说这种方法有一个缺点，那就是左递归。因而它带来了更高级的LR解析技术。可以看看下面这个有问题的例子：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sum</span> =</span><br><span class="line">    <span class="built_in">Sum</span> &#x27;+&#x27; <span class="built_in">Int</span></span><br><span class="line">  | <span class="built_in">Int</span></span><br></pre></td></tr></table></figure><p>写成代码呢：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>(p: &amp;<span class="keyword">mut</span> Parser) &#123;</span><br><span class="line">    <span class="comment">// 第一个选项</span></span><br><span class="line">    <span class="title function_ invoke__">sum</span>(p); </span><br><span class="line">    p.<span class="title function_ invoke__">expect</span>(PLUS);</span><br><span class="line">    <span class="title function_ invoke__">int</span>(p);</span><br><span class="line">    <span class="comment">// 如果失败，选第二个选项</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第三行，sum(p)会无限递归导致栈溢出</p><p>所以我们一般在实践中用循环代替递归：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>(p: &amp;<span class="keyword">mut</span> Parser) &#123;</span><br><span class="line">    <span class="title function_ invoke__">int</span>(p);</span><br><span class="line">    <span class="keyword">while</span> p.<span class="title function_ invoke__">eat</span>(PLUS) &#123;</span><br><span class="line">        <span class="title function_ invoke__">int</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pratt解析标准模板"><a href="#Pratt解析标准模板" class="headerlink" title="Pratt解析标准模板"></a>Pratt解析标准模板</h2><p>如果只有循环，前缀表达式就不能解析。所以，Pratt用循环和递归一起实现解析操作：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_expr</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="title function_ invoke__">parse_expr</span>()</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它把表达式放进循环，还能解析优先级和关联性</p><h2 id="优先级与绑定能力"><a href="#优先级与绑定能力" class="headerlink" title="优先级与绑定能力"></a>优先级与绑定能力</h2><p>我经常把高优先级和低优先级搞混。在a+b*c中加法的优先级较低，但是它在语法树的顶端。所以我们可以引入绑定能力这个概念：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表达式:   A       +       B       *       C</span><br><span class="line">绑定能力:    <span class="number"> 3 </span>     <span class="number"> 3 </span>     <span class="number"> 5 </span>      5</span><br></pre></td></tr></table></figure><p>在这个例子中，*更强，所以它绑定左右内容的能力更强，因此整个表达式先组合BC，然后组合A和BC</p><p>那相关性呢？如果是A+B+C，每个运算符都是一样的，那要怎么判断是(A+B)+C还是A+(B+C)，但是绑定能力也可以表示这个特性：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表达式:      A       +       B       +       C</span><br><span class="line">绑定能力:<span class="number"> 0 </span>    <span class="number"> 3 </span>     3.1     <span class="number"> 3 </span>     3.1     0</span><br></pre></td></tr></table></figure><p>这里我们把+的右侧的绑定能力增加了，这样可以让+运算符后面的数和+联系得更紧密。然后在左右加0说明两边没有操作符。对于B来说，左边的+比右边的+的绑定能力更强，所以它和左边的+优先结合，因此，可以化简为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">表达式:      (A + B)     +     C</span></span><br><span class="line"><span class="section">绑定能力:  0          3    3.1    0</span></span><br></pre></td></tr></table></figure><p>然后就顺理成章了，第二个+更喜欢后面那个数，所以在它连接C时，A和B被第一个+捕获了，这是很清晰的。</p><p>Pratt解析需要在读取从左到右的token流的同时来实现上面的过程。这无疑是比邻居搜索算法(存疑？)更好的。基本原理已经OK了，只剩写代码。但是我们还需要表示一个右结合的语法，我们用 . 来表示，假设数字为f，g和h：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="attribute">f</span>     .    g     .    h</span><br><span class="line"><span class="attribute">0</span>   <span class="number">8</span>.<span class="number">5</span>    <span class="number">8</span>   <span class="number">8</span>.<span class="number">5</span>    <span class="number">8</span>   <span class="number">0</span></span><br></pre></td></tr></table></figure><p>它会被解析为：f . (g . h)</p><h2 id="最简Pratt解析器"><a href="#最简Pratt解析器" class="headerlink" title="最简Pratt解析器"></a>最简Pratt解析器</h2><p>我们传入解析器的参数是单字符的数字和变量，并用标点符号作为运算符，实例如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Token</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Atom</span>(<span class="type">char</span>),</span><br><span class="line">    <span class="title function_ invoke__">Op</span>(<span class="type">char</span>),</span><br><span class="line">    Eof,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Lexer</span> &#123;</span><br><span class="line">    tokens: <span class="type">Vec</span>&lt;Token&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Lexer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Lexer &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tokens</span> = input</span><br><span class="line">            .<span class="title function_ invoke__">chars</span>()</span><br><span class="line">            .<span class="title function_ invoke__">filter</span>(|it| !it.<span class="title function_ invoke__">is_ascii_whitespace</span>())</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|c| <span class="keyword">match</span> c &#123;</span><br><span class="line">                <span class="string">&#x27;0&#x27;</span>..=<span class="string">&#x27;9&#x27;</span> |</span><br><span class="line">                <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> | <span class="string">&#x27;A&#x27;</span>..=<span class="string">&#x27;Z&#x27;</span> =&gt; Token::<span class="title function_ invoke__">Atom</span>(c),</span><br><span class="line">                _ =&gt; Token::<span class="title function_ invoke__">Op</span>(c),</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">        tokens.<span class="title function_ invoke__">reverse</span>();</span><br><span class="line">        Lexer &#123; tokens &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Token &#123;</span><br><span class="line">        <span class="keyword">self</span>.tokens.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap_or</span>(Token::Eof)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">peek</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Token &#123;</span><br><span class="line">        <span class="keyword">self</span>.tokens.<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(Token::Eof)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了可以正确识别绑定能力，需要先将中缀表达式变为前缀表达式：</p><p><code>1 + 2 * 3 == (+ 1 (* 2 3))</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Atom</span>(<span class="type">char</span>),</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">char</span>, <span class="type">Vec</span>&lt;S&gt;),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            S::<span class="title function_ invoke__">Atom</span>(i) =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;&quot;</span>, i),</span><br><span class="line">            S::<span class="title function_ invoke__">Cons</span>(head, rest) =&gt; &#123;</span><br><span class="line">                <span class="built_in">write!</span>(f, <span class="string">&quot;(&#123;&#125;&quot;</span>, head)?;</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> rest &#123;</span><br><span class="line">                    <span class="built_in">write!</span>(f, <span class="string">&quot; &#123;&#125;&quot;</span>, s)?</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">write!</span>(f, <span class="string">&quot;)&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们从+和*开始：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr</span>(input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lexer</span> = Lexer::<span class="title function_ invoke__">new</span>(input);</span><br><span class="line">    <span class="title function_ invoke__">expr_bp</span>(&amp;<span class="keyword">mut</span> lexer)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    todo!()</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">tests</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;1 + 2 * 3&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(+ 1 (* 2 3))&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，实际就是使用我们处理左递归的方法——解析数字，循环，然后consum操作符，然后做其它的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">tests</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;1&quot;</span>); </span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已经可以正常执行了</p><p>我们添加上运算符的左右绑定能力，由于两侧都是0，所以运算符的至少为1，对于不同结合性的，可以在对应边+1</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> (l_bp, r_bp) = <span class="title function_ invoke__">infix_binding_power</span>(op);</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">infix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> (<span class="type">u8</span>, <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在是最棘手的地方，引入递归，假设下面这个例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span>   +   b   *   c   *   d   +   e</span><br><span class="line">  <span class="attribute">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">1</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这里，开始执行时，将a放入lhs，然后呢？很明显不能直接将b和a组合，那是b*c吗？也不是，应该是b*c*d，一共应该分为三个部分：A+B+C，这是因为+的结合性更低，所以，我们引入递归：从b开始，找到比b左边结合性还低的结合性即可，在这里就是e，因此要向main函数添加min_bp参数。bp就是bind power</p><p>最后，就是这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr</span>(input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lexer</span> = Lexer::<span class="title function_ invoke__">new</span>(input);</span><br><span class="line">    <span class="title function_ invoke__">expr_bp</span>(&amp;<span class="keyword">mut</span> lexer, <span class="number">0</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer, min_bp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> S &#123; </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> (l_bp, r_bp) = <span class="title function_ invoke__">infix_binding_power</span>(op);</span><br><span class="line">        <span class="keyword">if</span> l_bp &lt; min_bp &#123; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lexer.<span class="title function_ invoke__">next</span>(); </span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">        lhs = S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs]); </span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">infix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> (<span class="type">u8</span>, <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">tests</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;1 + 2 * 3&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(+ 1 (* 2 3))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;a + b * c * d + e&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(+ (+ a (* (* b c) d)) e)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第5行：min_bp十分重要，expr_bp在它的控制下可以解析比它绑定能力大的所有表达式，当看到比它小的表达式时，就会停止。</li><li>第17行：停止条件</li><li>第20行：这里我们跳过操作符本身，进行递归调用。我们使用l_bp来检测min_bp，r_bp作为递归调用的新min_bp。因此min_bp可以视为当前表达式左侧操作符的绑定能力。</li><li>第22行：解析完右侧的表达式后，组合成当前表达式</li><li>第3行：开始时，使用0的绑定能力，0表示没有运算符</li></ul><p>上面的40行代码就是Pratt核心的解析算法。如果你能理解它，那么其它的内容就是单纯的加法罢了。</p><h2 id="额外内容"><a href="#额外内容" class="headerlink" title="额外内容"></a>额外内容</h2><p>好了，我们现在可以添加一些奇怪的表达式来展示Pratt算法的强大。首先添加一个高优先的，右结合的成员函数调用运算符 . ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">infix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> (<span class="type">u8</span>, <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        <span class="string">&#x27;.&#x27;</span> =&gt; (<span class="number">6</span>, <span class="number">5</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很不错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;f . g . h&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(. f (. g h))&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot; 1 + 2 + f . g . h * 3 * 4&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(+ (+ 1 2) (* (* (. f (. g h)) 3) 4))&quot;</span>);</span><br></pre></td></tr></table></figure><p>好的，现在添加负号，也就是一元 - ，它比比特运算符绑定更强，但是比二元的绑定弱，同时如果它是第一个出现的token，那上面的代码就需要修改为先处理一元运算符的版本。由于一元运算符只和右边结合所以只有右结合性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">prefix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> ((), <span class="type">u8</span>) &#123; </span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; ((), <span class="number">5</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">infix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> (<span class="type">u8</span>, <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        <span class="string">&#x27;.&#x27;</span> =&gt; (<span class="number">8</span>, <span class="number">7</span>), </span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第1行：使用()表明这是一个前缀运算符而不是后缀或中缀，所以只能把其它东西放在这个符号后。</li><li>第11行：由于我们要在.和*中添加一元减，所以需要修正.的优先级，一般来说，如果运算符是二元的，设置它的优先级为一个奇数，并用这个数+1表示它的结合性。对于一元减来说，则都可以，但是最好设置一个原则。</li></ul><p>加到expr_bp之后，得到：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer, min_bp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(op) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> ((), r_bp) = <span class="title function_ invoke__">prefix_binding_power</span>(op);</span><br><span class="line">            todo!()</span><br><span class="line">        &#125;</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，我们现在有r_bp了，还没有l_bp，所以直接复制main的一段代码修改出来吧？记住，r_bp是用来递归的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer, min_bp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(op) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> ((), r_bp) = <span class="title function_ invoke__">prefix_binding_power</span>(op);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">            S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[rhs])</span><br><span class="line">        &#125;</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> (l_bp, r_bp) = <span class="title function_ invoke__">infix_binding_power</span>(op);</span><br><span class="line">        <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">        lhs = S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs]);</span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">tests</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;--1 * 2&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(* (- (- 1)) 2)&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;--f . g&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(- (- (. f g)))&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有趣，它直接生效了，你可以想一下为什么会这样。因为操作数被绑定程度更高的运算符结合了，而这里正好有一个解析指定绑定能力更高的表达式的函数。</p><p>OK，((), u8) 可以解决前缀式，那后缀式可以用(u8, ()) 来解决吗？现在加个阶乘：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (l_bp, ()) = <span class="title function_ invoke__">postfix_binding_power</span>(op);</span><br><span class="line"><span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> (l_bp, r_bp) = <span class="title function_ invoke__">infix_binding_power</span>(op);</span><br><span class="line"><span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>e，不对，解析前缀表达式时，我们能看到后缀或中缀运算符。但是传递没有识别到的运算符时，就不能正常运行了。所以，让postfix_binding_power 返回一个指明是不是后缀的选项：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer, min_bp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(op) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> ((), r_bp) = <span class="title function_ invoke__">prefix_binding_power</span>(op);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">            S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[rhs])</span><br><span class="line">        &#125;</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((l_bp, ())) = <span class="title function_ invoke__">postfix_binding_power</span>(op) &#123;</span><br><span class="line">            <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">            lhs = S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> (l_bp, r_bp) = <span class="title function_ invoke__">infix_binding_power</span>(op);</span><br><span class="line">        <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">        lhs = S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs]);</span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">prefix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> ((), <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; ((), <span class="number">5</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">postfix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">u8</span>, ())&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;!&#x27;</span> =&gt; (<span class="number">7</span>, ()),</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">infix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> (<span class="type">u8</span>, <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        <span class="string">&#x27;.&#x27;</span> =&gt; (<span class="number">10</span>, <span class="number">9</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">tests</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;-9!&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(- (! 9))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;f . g !&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(! (. f g))&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太好了，这样就都通过了。</p><p>现在，我们需要添加括号。这很简单，我们本可以在一开始做，但是这里再处理更有意义。括号表达式只是一个基础表达式，它的处理方式类似于基本的数字标识符等组成的原子表达式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">    Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">    Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;(&#x27;</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">lhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(lexer.<span class="title function_ invoke__">next</span>(), Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;)&#x27;</span>));</span><br><span class="line">        lhs</span><br><span class="line">    &#125;</span><br><span class="line">    Token::<span class="title function_ invoke__">Op</span>(op) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> ((), r_bp) = <span class="title function_ invoke__">prefix_binding_power</span>(op);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">        S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[rhs])</span><br><span class="line">    &#125;</span><br><span class="line">    t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可惜，失败了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;(((0)))&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;0&quot;</span>);</span><br></pre></td></tr></table></figure><p>报错来自于下面的循环，我们的终止条件是达到eof，而不是)，所以解决方法是在遇到未知的标识符是返回None</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer, min_bp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;(&#x27;</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">lhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(lexer.<span class="title function_ invoke__">next</span>(), Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;)&#x27;</span>));</span><br><span class="line">            lhs</span><br><span class="line">        &#125;</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(op) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> ((), r_bp) = <span class="title function_ invoke__">prefix_binding_power</span>(op);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">            S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[rhs])</span><br><span class="line">        &#125;</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((l_bp, ())) = <span class="title function_ invoke__">postfix_binding_power</span>(op) &#123;</span><br><span class="line">            <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">            lhs = S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((l_bp, r_bp)) = <span class="title function_ invoke__">infix_binding_power</span>(op) &#123;</span><br><span class="line">            <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">            lhs = S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">prefix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> ((), <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; ((), <span class="number">5</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">postfix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">u8</span>, ())&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;!&#x27;</span> =&gt; (<span class="number">7</span>, ()),</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">infix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">u8</span>, <span class="type">u8</span>)&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        <span class="string">&#x27;.&#x27;</span> =&gt; (<span class="number">10</span>, <span class="number">9</span>),</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后继续，我们来添加数组索引操作符：a[i]。它属于什么缀呢？环绕型？如果只有a[]那就是后缀，如果是[i]，则可以像括号一样。我们可以发现i并没有参与优先级的计算，所以可以这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer, min_bp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;(&#x27;</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">lhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(lexer.<span class="title function_ invoke__">next</span>(), Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;)&#x27;</span>));</span><br><span class="line">            lhs</span><br><span class="line">        &#125;</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(op) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> ((), r_bp) = <span class="title function_ invoke__">prefix_binding_power</span>(op);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">            S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[rhs])</span><br><span class="line">        &#125;</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((l_bp, ())) = <span class="title function_ invoke__">postfix_binding_power</span>(op) &#123;</span><br><span class="line">            <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">            lhs = <span class="keyword">if</span> op == <span class="string">&#x27;[&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">assert_eq!</span>(lexer.<span class="title function_ invoke__">next</span>(), Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;]&#x27;</span>));</span><br><span class="line">                S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs])</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((l_bp, r_bp)) = <span class="title function_ invoke__">infix_binding_power</span>(op) &#123;</span><br><span class="line">            <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">            lhs = S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">prefix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> ((), <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; ((), <span class="number">5</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">postfix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">u8</span>, ())&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;!&#x27;</span> | <span class="string">&#x27;[&#x27;</span> =&gt; (<span class="number">7</span>, ()), </span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">infix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">u8</span>, <span class="type">u8</span>)&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        <span class="string">&#x27;.&#x27;</span> =&gt; (<span class="number">10</span>, <span class="number">9</span>),</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">tests</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;x[0][1]&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;([ ([ x 0) 1)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第57行：我们这里把!和[用作相同优先级。一般来说，优先级是不能相等的，否则可能的候选项就有2个或以上。而这里，我们比较的是右绑定能力和左绑定能力，而它们都只是右结合，不会出现多种可能，所以可以这样用。</li></ul><p>最后的boss是这个，三元表达式：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c ? e1 : <span class="type">e2</span></span><br></pre></td></tr></table></figure><p>如果这样就很好看了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c <span class="selector-attr">[ e1 ]</span> e2</span><br></pre></td></tr></table></figure><p>这和a[i]差不多，所以把它当作奇怪的括号也未尝不可。既然如此，直接用我们之前解决括号的方法来解决它。那结合性和优先级呢？</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a ? b : <span class="type">c</span> ? d : <span class="type">e</span></span><br></pre></td></tr></table></figure><p>就像刚刚说的，尝试把b和d看作括号的内容，而它不参与优先级的考虑：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="string">?:</span> c <span class="string">?:</span> e</span><br></pre></td></tr></table></figure><p>最后就变成这样：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a <span class="string">?:</span> c) <span class="string">?:</span> e</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="string">?:</span> (c <span class="string">?:</span> e)</span><br></pre></td></tr></table></figure><p>哪一个更有用呢？？链像这样：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a ? b :</span><br><span class="line"><span class="type">c</span> ? d :</span><br><span class="line"><span class="type">e</span></span><br></pre></td></tr></table></figure><p>右结合的方式更有用，就优先级而言，三元运算符优先级较低。C语言中，只有=和，的优先级比它低。那么，也添加一个=吧。</p><p>现在，得到了最后的版本：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;fmt, io::BufRead&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Atom</span>(<span class="type">char</span>),</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">char</span>, <span class="type">Vec</span>&lt;S&gt;),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            S::<span class="title function_ invoke__">Atom</span>(i) =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;&quot;</span>, i),</span><br><span class="line">            S::<span class="title function_ invoke__">Cons</span>(head, rest) =&gt; &#123;</span><br><span class="line">                <span class="built_in">write!</span>(f, <span class="string">&quot;(&#123;&#125;&quot;</span>, head)?;</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> rest &#123;</span><br><span class="line">                    <span class="built_in">write!</span>(f, <span class="string">&quot; &#123;&#125;&quot;</span>, s)?</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">write!</span>(f, <span class="string">&quot;)&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Token</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Atom</span>(<span class="type">char</span>),</span><br><span class="line">    <span class="title function_ invoke__">Op</span>(<span class="type">char</span>),</span><br><span class="line">    Eof,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Lexer</span> &#123;</span><br><span class="line">    tokens: <span class="type">Vec</span>&lt;Token&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Lexer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Lexer &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tokens</span> = input</span><br><span class="line">            .<span class="title function_ invoke__">chars</span>()</span><br><span class="line">            .<span class="title function_ invoke__">filter</span>(|it| !it.<span class="title function_ invoke__">is_ascii_whitespace</span>())</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|c| <span class="keyword">match</span> c &#123;</span><br><span class="line">                <span class="string">&#x27;0&#x27;</span>..=<span class="string">&#x27;9&#x27;</span></span><br><span class="line">                | <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> | <span class="string">&#x27;A&#x27;</span>..=<span class="string">&#x27;Z&#x27;</span> =&gt; Token::<span class="title function_ invoke__">Atom</span>(c),</span><br><span class="line">                _ =&gt; Token::<span class="title function_ invoke__">Op</span>(c),</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">        tokens.<span class="title function_ invoke__">reverse</span>();</span><br><span class="line">        Lexer &#123; tokens &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Token &#123;</span><br><span class="line">        <span class="keyword">self</span>.tokens.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap_or</span>(Token::Eof)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">peek</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Token &#123;</span><br><span class="line">        <span class="keyword">self</span>.tokens.<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(Token::Eof)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expr</span>(input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lexer</span> = Lexer::<span class="title function_ invoke__">new</span>(input);</span><br><span class="line">    <span class="title function_ invoke__">expr_bp</span>(&amp;<span class="keyword">mut</span> lexer, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer, min_bp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;(&#x27;</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">lhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(lexer.<span class="title function_ invoke__">next</span>(), Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;)&#x27;</span>));</span><br><span class="line">            lhs</span><br><span class="line">        &#125;</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(op) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> ((), r_bp) = <span class="title function_ invoke__">prefix_binding_power</span>(op);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">            S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[rhs])</span><br><span class="line">        &#125;</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((l_bp, ())) = <span class="title function_ invoke__">postfix_binding_power</span>(op) &#123;</span><br><span class="line">            <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">            lhs = <span class="keyword">if</span> op == <span class="string">&#x27;[&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">assert_eq!</span>(lexer.<span class="title function_ invoke__">next</span>(), Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;]&#x27;</span>));</span><br><span class="line">                S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs])</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((l_bp, r_bp)) = <span class="title function_ invoke__">infix_binding_power</span>(op) &#123;</span><br><span class="line">            <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">            lhs = <span class="keyword">if</span> op == <span class="string">&#x27;?&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">mhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">assert_eq!</span>(lexer.<span class="title function_ invoke__">next</span>(), Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;:&#x27;</span>));</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">                S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, mhs, rhs])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">                S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs])</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">prefix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> ((), <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; ((), <span class="number">9</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">postfix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">u8</span>, ())&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;!&#x27;</span> =&gt; (<span class="number">11</span>, ()),</span><br><span class="line">        <span class="string">&#x27;[&#x27;</span> =&gt; (<span class="number">11</span>, ()),</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">infix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">u8</span>, <span class="type">u8</span>)&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;=&#x27;</span> =&gt; (<span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="string">&#x27;?&#x27;</span> =&gt; (<span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">7</span>, <span class="number">8</span>),</span><br><span class="line">        <span class="string">&#x27;.&#x27;</span> =&gt; (<span class="number">14</span>, <span class="number">13</span>),</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">tests</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;1 + 2 * 3&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(+ 1 (* 2 3))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;a + b * c * d + e&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(+ (+ a (* (* b c) d)) e)&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;f . g . h&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(. f (. g h))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot; 1 + 2 + f . g . h * 3 * 4&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        s.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        <span class="string">&quot;(+ (+ 1 2) (* (* (. f (. g h)) 3) 4))&quot;</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;--1 * 2&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(* (- (- 1)) 2)&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;--f . g&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(- (- (. f g)))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;-9!&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(- (! 9))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;f . g !&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(! (. f g))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;(((0)))&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;x[0][1]&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;([ ([ x 0) 1)&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(</span><br><span class="line">        <span class="string">&quot;a ? b :</span></span><br><span class="line"><span class="string">         c ? d</span></span><br><span class="line"><span class="string">         : e&quot;</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(? a b (? c d e))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;a = 0 ? b : c = d&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(= a (= (? 0 b c) d))&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> std::io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">line</span> = line.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(&amp;line);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码也可以在<a href="https://github.com/matklad/minipratt">这个仓库</a>中找到。</p><p>Eof :-)</p>]]></content>
    
    
    <summary type="html">非原创，翻译</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="数据结构与算法" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Pratt" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/Pratt/"/>
    
    
    <category term="算法" scheme="https://www.pri87.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="解析" scheme="https://www.pri87.vip/tags/%E8%A7%A3%E6%9E%90/"/>
    
    <category term="字符串" scheme="https://www.pri87.vip/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="递归" scheme="https://www.pri87.vip/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>病毒分析基本流程</title>
    <link href="https://www.pri87.vip/posts/8d9e4631.html"/>
    <id>https://www.pri87.vip/posts/8d9e4631.html</id>
    <published>2025-04-17T13:18:49.000Z</published>
    <updated>2025-05-04T15:10:53.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预分析"><a href="#预分析" class="headerlink" title="预分析"></a>预分析</h2><p>这个阶段主要在于收集样本信息。</p><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>分析样本是由什么语言编译的，分析出对应的调用约定，有无现成的符号表，签名文件等，为后续分析减少困难。</p><p>如果有壳，要知道是什么壳，一般病毒的壳都是强壳，我还不会分析。</p><p>分析导入表，如果壳隐藏了，只有后续看。大致看出有没有干文件操作，有没有干网络操作，有没有干驻留操作（注册表和服务）。判断出病毒类型。之后在对应的逻辑中仔细分析。</p><h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>在线沙箱中检测/虚拟机中检测。沙箱可以直接分析，如果是自己的虚拟机，则需要打开一个可以检测进程的(ARK)工具，获取样本的所有操作，尤其是：是否有文件创建和写入？网络连接的ip是多少？网络中读取的内容是什么？注册了哪些服务和注册表？Hook了哪些模块，用了哪些API等等。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>打开程序，根据预分析的内容定位关键位置然后具体分析。</p><p>跟CTF的逆向题差不多。</p>]]></content>
    
    
    <summary type="html">基本的病毒分析流程总结</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ida基本使用操作</title>
    <link href="https://www.pri87.vip/posts/dc1142ef.html"/>
    <id>https://www.pri87.vip/posts/dc1142ef.html</id>
    <published>2025-04-12T07:07:46.000Z</published>
    <updated>2025-05-01T05:50:32.981Z</updated>
    
    <content type="html"><![CDATA[<p>-</p><h2 id="自定义调用约定"><a href="#自定义调用约定" class="headerlink" title="自定义调用约定"></a>自定义调用约定</h2><p>ida支持用户显式指定参数和返回值所使用的寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall func@&lt;ebx&gt;(<span class="type">int</span> x, <span class="type">int</span> y@&lt;esi&gt;);</span><br></pre></td></tr></table></figure><p>这表明x用堆栈传递，y用esi传递，返回值用ebx传递</p><p>返回值必须位于寄存器中<br>如果返回值类型是void，不能指定返回值的位置<br>如果参数的位置没有指定，假设参数通过堆栈传递<br>可以允许嵌套声明，如: int **__usercall func16@\<eax\>(int *(__usercall *x)@\<ebx\> (int, long@\<ecx\>, int)@\<esi\>);<br>用于指定位置名的寄存器必须在当前处理器中有效<br>寄存器对可以像这样 \<edx:eax\> 用冒号的形式指定</p><p>__usercall 调用者清理堆栈</p><p>__userpurge 被调用者清理堆栈</p><p>__spoils指定函数破坏的寄存器列表，比如int __spoils<eax, bh> func(int x);</p><h2 id="汇编下寄存器命名指定范围"><a href="#汇编下寄存器命名指定范围" class="headerlink" title="汇编下寄存器命名指定范围"></a>汇编下寄存器命名指定范围</h2><p>很多时候一个寄存器在同个函数中作用不同，按n后，可以在start address和end addres中指定寄存器在某个范围中的名字从而更方便地重命名</p>]]></content>
    
    
    <summary type="html">本篇介绍部分基本ida使用操作</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>自动化代码混淆</title>
    <link href="https://www.pri87.vip/posts/e00631f.html"/>
    <id>https://www.pri87.vip/posts/e00631f.html</id>
    <published>2025-04-08T01:34:00.000Z</published>
    <updated>2025-05-01T05:50:32.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在写shellcode。发现shellcode生成的代码十分简单，也没有绝对跳转或者之类的需要重定位的东西，所以我感觉用这个来练手自动化加花还是很不错的</p><h2 id="使用的库"><a href="#使用的库" class="headerlink" title="使用的库"></a>使用的库</h2><p>Zydis和keystone</p><p>前者作为反汇编工具，后者作为从字符串生成机器码的工具。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过Zydis对代码进行解析，装入一个list中，然后执行混淆，这里我干了两个事：</p><ol><li>判断是否有直接字符串数据压栈，有的话加密原内容，然后解密再压栈</li><li>打乱整个代码结构</li></ol><p>1的话，通过Zydis生成字符串来检测，keystone生成机器码然后创建对应代码插入/修改list即可</p><p>2的话，通过分块每个块最后加jmp然后交换块的位置即可，但是好像cpp原生的list交换会导致一些bug，所以我准备之后重新写一下</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>见github</p>]]></content>
    
    
    <summary type="html">本篇是进行代码混淆的练习</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向，自动化逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91%EF%BC%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E9%80%86%E5%90%91/"/>
    
    
    <category term="代码混淆" scheme="https://www.pri87.vip/tags/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    
  </entry>
  
  <entry>
    <title>X86-64汇编机器码格式</title>
    <link href="https://www.pri87.vip/posts/47eb1508.html"/>
    <id>https://www.pri87.vip/posts/47eb1508.html</id>
    <published>2025-03-31T07:29:42.000Z</published>
    <updated>2025-04-01T01:14:01.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p><img src="https://s2.loli.net/2025/03/31/vEYwI5kGshboazd.png" alt="image-20250331153157959"></p><p><img src="https://s2.loli.net/2025/03/31/r9fHQj3BgMu1mDL.png" alt="image-20250331155123077"></p><p>该图说明：主操作码一定有，由于其它内容不一定在一条指令中，所以指令长度不固定</p><h3 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h3><p>G：寄存器<br>E：寄存器/内存<br>b：单字节<br>v：根据操作系统判断位数，一般数默认32位，地址默认64位</p><p>MOV Gv Ev：意思是把一个内存或寄存器的值放到一个寄存器中，大小根据操作系统决定</p><p>现在依次介绍这几个</p><h2 id="指令前缀（Instruction-Prefixes）"><a href="#指令前缀（Instruction-Prefixes）" class="headerlink" title="指令前缀（Instruction Prefixes）"></a>指令前缀（Instruction Prefixes）</h2><p>前缀分为 4 类，使用时，不区分前后顺序，且每组最多出现一个：</p><p>1.锁定和重复前缀</p><div class="table-container"><table><thead><tr><th>前缀</th><th>效果</th></tr></thead><tbody><tr><td>F0</td><td>使操作变为原子操作</td></tr><tr><td>F2</td><td>REPNE/REPNZ，重复前缀，用于串和 IO</td></tr><tr><td>F3</td><td>REP 或 REPE/REPZ，用于串和 IO</td></tr></tbody></table></div><p>2.段重载</p><div class="table-container"><table><thead><tr><th>前缀</th><th>效果</th></tr></thead><tbody><tr><td>2E</td><td>CS 段重载</td></tr><tr><td>36</td><td>SS 段重载</td></tr><tr><td>3E</td><td>DS 段重载</td></tr><tr><td>26</td><td>ES 段重载</td></tr><tr><td>64</td><td>FS 段重载</td></tr><tr><td>65</td><td>GS 段重载</td></tr><tr><td>2E</td><td>分支一般不跳转，用于提示 CPU 进行预测</td></tr><tr><td>3E</td><td>分支一般跳转，用于提示 CPU 进行预测</td></tr></tbody></table></div><p>3.操作数大小重载</p><div class="table-container"><table><thead><tr><th>前缀</th><th>效果</th></tr></thead><tbody><tr><td>66</td><td>将默认操作数大小从 32 位转为 16 位</td></tr></tbody></table></div><p>4.操作地址大小重载</p><div class="table-container"><table><thead><tr><th>前缀</th><th>效果</th></tr></thead><tbody><tr><td>67</td><td>将默认的 64 位地址大小转为 32 位</td></tr></tbody></table></div><h2 id="REX-前缀"><a href="#REX-前缀" class="headerlink" title="REX 前缀"></a>REX 前缀</h2><p>REX 用来扩展指令从 32 位到 64 位，这一部分的内容需要先看后面的几个部分才能看懂</p><p>占一字节，可以没有</p><p><img src="https://s2.loli.net/2025/03/31/uBJv1dEkf8NXGpD.png" alt="image-20250331160405462"></p><p>将对应域置 1 就可以使目标扩展</p><p>其中经常使用的就是 48，让操作数变为 64 位大小</p><h2 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h2><p>一般来说，主操作码长度为 1 到 3 字节，ModR/M 可能编码附加的 3 位操作码</p><p>双字节：0F+第二个操作码字节 或 一个前缀(66H, F2H, 或 F3H)+0F+第二个操作码字节<br>三字节：0F+后两个操作码字节 或 一个前缀(66H, F2H, 或 F3H)+0F+后两个操作码字节</p><p>部分内容需要先看后面的</p><p>下面为 1 到 3 字节指令的查表</p><p><img src="https://s2.loli.net/2025/03/31/JqnVpF7uomvaj4L.png" alt="image-20250331161314311"></p><p><img src="https://s2.loli.net/2025/03/31/LFVOx9YB4whqlIG.png" alt="image-20250331161329868"></p><p><img src="https://s2.loli.net/2025/03/31/y35PrtfsOdVNcZi.png" alt="image-20250331161339920"></p><p><img src="https://s2.loli.net/2025/03/31/MRiwKW1ZmSj83GQ.png" alt="image-20250331161350193"></p><p><img src="https://s2.loli.net/2025/03/31/hTMljvS2V6nPRXW.png" alt="image-20250331161359418"></p><p><img src="https://s2.loli.net/2025/03/31/rogQINylSKYHLJ3.png" alt="image-20250331161408747"></p><p><img src="https://s2.loli.net/2025/03/31/Ax95rqsP4VI3fNc.png" alt="image-20250331161419001"></p><p><img src="https://s2.loli.net/2025/03/31/LhElcWowv7MtYCi.png" alt="image-20250331161429738"></p><p><img src="https://s2.loli.net/2025/03/31/dDWFZ32bXHqLgQr.png" alt="image-20250331161439214"></p><p><img src="https://s2.loli.net/2025/03/31/sOSoX6rl5MiTzPf.png" alt="image-20250331161448469"></p><blockquote><p>以上截取自 IA32 手册 2024-12 版的 2929 页至 2938 页</p></blockquote><p>除了上面的查表方式，x86-64 指令还有另一种方式：通过组来查询，这种方式使用了一张新表，叫做单双字节操作码的操作码扩展</p><p>先附表</p><p><img src="https://s2.loli.net/2025/03/31/v3guPoV9xBY4HcI.png" alt="image-20250331163515951"></p><p><img src="https://s2.loli.net/2025/03/31/PflMsu9DHAa65Sg.png" alt="image-20250331163526702"></p><p><img src="https://s2.loli.net/2025/03/31/AWFud91GmSMNsYQ.png" alt="image-20250331165953065"></p><p><img src="https://s2.loli.net/2025/03/31/QaphGj7wUt8bKYs.png" alt="image-20250331170007852"></p><p><img src="https://s2.loli.net/2025/03/31/qKaURr7v9ew54cm.png" alt="image-20250331170031403"></p><p><img src="https://s2.loli.net/2025/03/31/ijDMHZgbCTVLUoQ.png" alt="image-20250331170044132"></p><p><img src="https://s2.loli.net/2025/03/31/glzF7n1DKhGYrE5.png" alt="image-20250331170056390"></p><p><img src="https://s2.loli.net/2025/03/31/tmDh75EdeKa93TC.png" alt="image-20250331170105301"></p><p><img src="https://s2.loli.net/2025/03/31/8ygvpfUW5sFHcMC.png" alt="image-20250331170116327"></p><p><img src="https://s2.loli.net/2025/03/31/9lIOjfepRrqGBLm.png" alt="image-20250331170126623"></p><p><img src="https://s2.loli.net/2025/03/31/2vhJ5iNDqRBG8bK.png" alt="image-20250331170135362"></p><p><img src="https://s2.loli.net/2025/03/31/STFlRIhLdAKUjnQ.png" alt="image-20250331170145112"></p><p><img src="https://s2.loli.net/2025/03/31/Mb8p9NrtxkF6imv.png" alt="image-20250331170154414"></p><p><img src="https://s2.loli.net/2025/03/31/2xaMiUDeQIPEln6.png" alt="image-20250331170205007"></p><p><img src="https://s2.loli.net/2025/03/31/2ICDLpAyMuXohHZ.png" alt="image-20250331170213809"></p><p><img src="https://s2.loli.net/2025/03/31/zChIJxtd6SDjqVQ.png" alt="image-20250331170226577"></p><p><img src="https://s2.loli.net/2025/03/31/ws6iqjJzf127Ktm.png" alt="image-20250331170241767"></p><p><img src="https://s2.loli.net/2025/03/31/v8ltPzSd52j1CxF.png" alt="image-20250331170254243"></p><blockquote><p>这里是 2940 到 2950</p></blockquote><p>考虑 80 C0 05</p><p>80 在表 A-6 中是 Group 1，然后看 ModR/M 字段的 5，4，3 位<br>C0:11000000，5，4，3 位为 000，即 0，查纵列得 ADD，根据之后的内容可以知道 ModR/M 指定了对应的内存和寄存器，所以得到 add al,5，这和第一种直接查表得到的 0405 的指令相同</p><h2 id="ModR-M"><a href="#ModR-M" class="headerlink" title="ModR/M"></a>ModR/M</h2><p>如果一个操作码涉及内存，后面一般就会有一个寻址格式说明字节即 ModR/M，而如果 ModR/M 中提到了需要内存寻址，那么就需要 SIB 字节去进一步解释</p><p>ModR/M和SIB各涉及三个域：<br><img src="https://s2.loli.net/2025/03/31/RadXi6T4VHcKSOJ.png" alt="image-20250331171513102"></p><p><img src="https://s2.loli.net/2025/03/31/ZY7RDy4MJorbdUv.png" alt="image-20250331172923245"></p><h3 id="Mod寻址模式"><a href="#Mod寻址模式" class="headerlink" title="Mod寻址模式"></a>Mod寻址模式</h3><p>指明操作码中的E是寄存器还是内存，11是内存，其它都是寄存器</p><div class="table-container"><table><thead><tr><th>Mod值</th><th>描述</th><th>偏移量</th></tr></thead><tbody><tr><td>00</td><td>内存，无偏移量(除非 R/M=101)</td><td>无或32</td></tr><tr><td>01</td><td>内存，有8位偏移</td><td>[base+8位偏移]</td></tr><tr><td>10</td><td>内存，有32位偏移</td><td>[base+32 位偏移]</td></tr><tr><td>11</td><td>寄存器操作数</td><td>寄存器</td></tr></tbody></table></div><p>前三个为内存，后一个为数</p><h3 id="Reg-Opcode寄存器或操作码扩展"><a href="#Reg-Opcode寄存器或操作码扩展" class="headerlink" title="Reg/Opcode寄存器或操作码扩展"></a>Reg/Opcode寄存器或操作码扩展</h3><p>指定使用的reg或opcode扩展：</p><div class="table-container"><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">32 位寄存器</th><th style="text-align:left">16 位寄存器</th><th style="text-align:left">8 位寄存器</th><th style="text-align:left">用途 (操作码扩展)</th></tr></thead><tbody><tr><td style="text-align:left">000</td><td style="text-align:left">EAX</td><td style="text-align:left">AX</td><td style="text-align:left">AL</td><td style="text-align:left">ADD</td></tr><tr><td style="text-align:left">001</td><td style="text-align:left">ECX</td><td style="text-align:left">CX</td><td style="text-align:left">CL</td><td style="text-align:left">OR</td></tr><tr><td style="text-align:left">010</td><td style="text-align:left">EDX</td><td style="text-align:left">DX</td><td style="text-align:left">DL</td><td style="text-align:left">ADC</td></tr><tr><td style="text-align:left">011</td><td style="text-align:left">EBX</td><td style="text-align:left">BX</td><td style="text-align:left">BL</td><td style="text-align:left">SBB</td></tr><tr><td style="text-align:left">100</td><td style="text-align:left">ESP</td><td style="text-align:left">SP</td><td style="text-align:left">AH</td><td style="text-align:left">AND</td></tr><tr><td style="text-align:left">101</td><td style="text-align:left">EBP</td><td style="text-align:left">BP</td><td style="text-align:left">CH</td><td style="text-align:left">SUB</td></tr><tr><td style="text-align:left">110</td><td style="text-align:left">ESI</td><td style="text-align:left">SI</td><td style="text-align:left">DH</td><td style="text-align:left">XOR</td></tr><tr><td style="text-align:left">111</td><td style="text-align:left">EDI</td><td style="text-align:left">DI</td><td style="text-align:left">BH</td><td style="text-align:left">CMP</td></tr></tbody></table></div><h3 id="R-M寄存器或内存"><a href="#R-M寄存器或内存" class="headerlink" title="R/M寄存器或内存"></a>R/M寄存器或内存</h3><div class="table-container"><table><thead><tr><th style="text-align:left">R/M 值</th><th style="text-align:left">Mod = 11（寄存器）</th><th style="text-align:left">Mod ≠ 11（内存基址/索引）</th></tr></thead><tbody><tr><td style="text-align:left">000</td><td style="text-align:left">EAX</td><td style="text-align:left">[RAX]</td></tr><tr><td style="text-align:left">001</td><td style="text-align:left">ECX</td><td style="text-align:left">[RCX]</td></tr><tr><td style="text-align:left">010</td><td style="text-align:left">EDX</td><td style="text-align:left">[RDX]</td></tr><tr><td style="text-align:left">011</td><td style="text-align:left">EBX</td><td style="text-align:left">[RBX]</td></tr><tr><td style="text-align:left">100</td><td style="text-align:left">ESP</td><td style="text-align:left">[SIB]（需要 SIB 字节）</td></tr><tr><td style="text-align:left">101</td><td style="text-align:left">EBP</td><td style="text-align:left">[RBP] 或无偏移/disp32</td></tr><tr><td style="text-align:left">110</td><td style="text-align:left">ESI</td><td style="text-align:left">[RSI]</td></tr><tr><td style="text-align:left">111</td><td style="text-align:left">EDI</td><td style="text-align:left">[RDI]</td></tr></tbody></table></div><p>内存索引的标准格式：<code>base+index*scale+disp</code></p><h2 id="SIB"><a href="#SIB" class="headerlink" title="SIB"></a>SIB</h2><p>SIB用来确定具体的地址格式<br>如果ModR/M中Mod不为11，且R/M的值为100，则后一个字节为SIB</p><p>ModR/M和SIB各涉及三个域：<br><img src="https://s2.loli.net/2025/03/31/RadXi6T4VHcKSOJ.png" alt="image-20250331171513102"></p><p><img src="https://s2.loli.net/2025/03/31/bTHXZd9BnIeYQMw.png" alt="image-20250331190129120"></p><h3 id="Scale比例因子"><a href="#Scale比例因子" class="headerlink" title="Scale比例因子"></a>Scale比例因子</h3><p>决定索引寄存器值的倍数</p><div class="table-container"><table><thead><tr><th>值</th><th>比例因子 (Scale)</th></tr></thead><tbody><tr><td>00</td><td>1</td></tr><tr><td>01</td><td>2</td></tr><tr><td>10</td><td>4</td></tr><tr><td>11</td><td>8</td></tr></tbody></table></div><h3 id="Index索引寄存器"><a href="#Index索引寄存器" class="headerlink" title="Index索引寄存器"></a>Index索引寄存器</h3><div class="table-container"><table><thead><tr><th>值</th><th>寄存器 (64 位模式)</th><th>寄存器 (32 位模式)</th></tr></thead><tbody><tr><td>000</td><td>RAX</td><td>EAX</td></tr><tr><td>001</td><td>RCX</td><td>ECX</td></tr><tr><td>010</td><td>RDX</td><td>EDX</td></tr><tr><td>011</td><td>RBX</td><td>EBX</td></tr><tr><td>100</td><td>无索引寄存器</td><td>无索引寄存器</td></tr><tr><td>101</td><td>RBP</td><td>EBP</td></tr><tr><td>110</td><td>RSI</td><td>ESI</td></tr><tr><td>111</td><td>RDI</td><td>EDI</td></tr></tbody></table></div><h3 id="Base基址寄存器"><a href="#Base基址寄存器" class="headerlink" title="Base基址寄存器"></a>Base基址寄存器</h3><div class="table-container"><table><thead><tr><th>值</th><th>寄存器 (64 位模式)</th><th>寄存器 (32 位模式)</th></tr></thead><tbody><tr><td>000</td><td>RAX</td><td>EAX</td></tr><tr><td>001</td><td>RCX</td><td>ECX</td></tr><tr><td>010</td><td>RDX</td><td>EDX</td></tr><tr><td>011</td><td>RBX</td><td>EBX</td></tr><tr><td>100</td><td>RSP（需 SIB 扩展）</td><td>ESP（需 SIB 扩展）</td></tr><tr><td>101</td><td>RBP 或 disp32(Mod=00)</td><td>EBP 或 disp32(Mod=00)</td></tr><tr><td>110</td><td>RSI</td><td>ESI</td></tr><tr><td>111</td><td>RDI</td><td>EDI</td></tr></tbody></table></div><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>8B 41 10</p><p>8B对应MOV Gv Ev</p><p>Gv说明目标操作数是寄存器，Ev表示源操作数为寄存器或地址<br>41是ModR/M<br>01 000 001<br>01说明这个指令的地址Ev为内存地址且有8bit偏移，000说明Gv为AX类，001说明目标操作数为CX类<br>由于没有SIB，10为立即数</p><p>所以指令为：MOV EAX, [RCX+0x10]</p><hr><p>04 FF</p><p>04对应ADD AL,Lb</p><p>已经指定寄存器，后面直接跟立即数，Lb表明是一个byte，所以是ADD AL ,0xff</p><hr><p>67 FF 34 88</p><p>67为指令前缀，表明把之后的地址值转为32位<br>FF表明要去Grp $5^{1A}$<br>34为ModR/M：00 110 100得到指令是PUSH Ev<br>00表明为使用地址无偏移，100表示根据SIB确定地址的值</p><p>SIB：10 001 000</p><p>10表明比例因子为4，001表明索引寄存器为RCX，000表明基址寄存器为RAX</p><p>根据指令前缀，将地址相关寄存器大小转为32位：push qword ptr [eax+ecx*4]</p>]]></content>
    
    
    <summary type="html">本篇介绍x86-64下指令结构</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="基础" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="机器码" scheme="https://www.pri87.vip/tags/%E6%9C%BA%E5%99%A8%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Zydis反编译库编译及使用方式</title>
    <link href="https://www.pri87.vip/posts/cbdd2395.html"/>
    <id>https://www.pri87.vip/posts/cbdd2395.html</id>
    <published>2025-03-28T13:27:56.000Z</published>
    <updated>2025-03-29T03:28:09.613Z</updated>
    
    <content type="html"><![CDATA[<p>Zydis是一个反汇编库，可以解析机器指令将其转为汇编代码，下面是使用方法</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://github.com/zyantific/zydis">zyantific/zydis: Fast and lightweight x86/x86-64 disassembler and code generation library</a></p><p>可以直接下载releases也可以直接clone</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>标准的编译方法：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone </span>--recursive <span class="string">&#x27;https://github.com/zyantific/zydis.git&#x27;</span></span><br><span class="line">cd zydis</span><br><span class="line">cmake -<span class="keyword">B </span><span class="keyword">build</span></span><br><span class="line"><span class="keyword"></span>cmake --<span class="keyword">build </span><span class="keyword">build </span>-<span class="keyword">j4</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>如果使用的是msvc，可以直接进入msvc目录使用vs编译，配置为release MT，直接生成。</p><p>如果是上面的方法，输出文件在build文件的debug目录下和Zycore\debug目录，如果是下面的方法，输出文件在bin\releaseX64下</p><p>取得生成的Zydis.lib和Zycore.lib，放在项目目录的lib文件夹下(新建)，然后在最外面的zydis目录下找到include复制到项目文件夹，在dependencies\zycore下找到include文件夹复制到项目文件夹</p><p>在项目属性中：</p><ul><li>C/C++<ul><li>常规：附加包含目录添加：$(ProjectDir)include</li><li>预处理器：预处理器定义添加：ZYDIS_STATIC_DEFINE</li></ul></li><li>链接器<ul><li>常规：附加库目录包含添加：$(ProjectDir)lib</li><li>输入：附加依赖项添加：Zycore.lib;Zydis.lib</li></ul></li></ul><h2 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h2><p>引用头文件：<code>#include &lt;Zydis/Zydis.h&gt;</code></p><h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ZydisDecoderDecodeFull</span>(&amp;decoder, buffer.<span class="built_in">data</span>() + offset, length - offset,&amp;instruction, operands)</span><br></pre></td></tr></table></figure><p>decoder是ZydisDecoder类型<br>instruction是ZydisDecodedInstruction保存基本指令数据<br>operands是ZydisDecodedOperand类型数组，保存一条指令的操作数</p><p>data是存放机器码的缓冲区</p><p>每次执行一次这个指令，就会对instruction和operands赋值，表示一条指令的解析</p><ul><li>instruction.mnemonic   助记符</li><li>instruction.length    指令总长度</li><li>instruction.opcode    机器码</li><li>instruction.operand_count_visible    显式操作数数量</li><li>operand.type    这个操作数的类型<ul><li>立即数(ZYDIS_OPERAND_TYPE_IMMEDIATE):<br>operand.imm.value数值</li><li>寄存器(ZYDIS_OPERAND_TYPE_REGISTER):<br>operand.reg.value寄存器名称</li><li>内存地址(ZYDIS_OPERAND_TYPE_MEMORY):<br>operand.mem.base表示内存的基址寄存器<br>operand.mem.index表示索引寄存器<br>operand.mem.disp地址偏移值</li></ul></li></ul><p>使用模板可以参考example和下面这个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cinttypes&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Zydis/Zydis.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">readFileToBuffer</span><span class="params">(<span class="type">const</span> std::string&amp; filepath, std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;&amp; buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::ifstream <span class="title">file</span><span class="params">(filepath, std::ios::binary | std::ios::ate)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Failed to open file: &quot;</span> &lt;&lt; filepath &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::streamsize fSize = file.<span class="built_in">tellg</span>();</span><br><span class="line">file.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::beg);</span><br><span class="line">buffer.<span class="built_in">resize</span>(fSize);</span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(buffer.<span class="built_in">data</span>()), fSize))</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Failed to read file: &quot;</span> &lt;&lt; filepath &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printInstructionStructure</span><span class="params">(<span class="type">const</span> ZydisDecodedInstruction&amp; instruction, <span class="type">const</span> ZydisDecodedOperand operands[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Instruction Structure:\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Mnemonic: &quot;</span> &lt;&lt; <span class="built_in">ZydisMnemonicGetString</span>(instruction.mnemonic) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Length: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(instruction.length) &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Opcode: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(instruction.opcode) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Operand Count Visible: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(instruction.operand_count_visible) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ZyanU8 i = <span class="number">0</span>; i &lt; instruction.operand_count_visible; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> ZydisDecodedOperand&amp; operand = operands[i];</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Operand &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(i) &lt;&lt; <span class="string">&quot;: \n&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (operand.type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ZYDIS_OPERAND_TYPE_REGISTER:</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Type: Register\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Register: &quot;</span> &lt;&lt; <span class="built_in">ZydisRegisterGetString</span>(operand.reg.value) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ZYDIS_OPERAND_TYPE_IMMEDIATE:</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Type: Immediate\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; operand.imm.value.u &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ZYDIS_OPERAND_TYPE_MEMORY:</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Type: Memory\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Base: &quot;</span> &lt;&lt; <span class="built_in">ZydisRegisterGetString</span>(operand.mem.base) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Index: &quot;</span> &lt;&lt; <span class="built_in">ZydisRegisterGetString</span>(operand.mem.index) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Displacement: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; operand.mem.disp.value &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; (operand.mem.disp.value &gt;= <span class="number">0</span> ? operand.mem.disp.value : -operand.mem.disp.value) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Type: Unknown\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;-----------------------------------\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ZydisDecoder decoder;</span><br><span class="line"><span class="built_in">ZydisDecoderInit</span>(&amp;decoder, ZYDIS_MACHINE_MODE_LONG_64, ZYDIS_STACK_WIDTH_64);</span><br><span class="line"></span><br><span class="line">ZydisFormatter formatter;</span><br><span class="line"><span class="built_in">ZydisFormatterInit</span>(&amp;formatter, ZYDIS_FORMATTER_STYLE_INTEL);</span><br><span class="line"></span><br><span class="line">std::string filePath = <span class="string">&quot;shellcode.bin&quot;</span>;</span><br><span class="line">std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; buffer;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">readFileToBuffer</span>(filePath, buffer))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZyanU64 runtime_address = <span class="number">0</span>;</span><br><span class="line">ZyanUSize offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> ZyanUSize length = buffer.<span class="built_in">size</span>();</span><br><span class="line">ZydisDecodedInstruction instruction;</span><br><span class="line">ZydisDecodedOperand operands[ZYDIS_MAX_OPERAND_COUNT];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">ZYAN_SUCCESS</span>(<span class="built_in">ZydisDecoderDecodeFull</span>(&amp;decoder, buffer.<span class="built_in">data</span>() + offset, length - offset,</span><br><span class="line">&amp;instruction, operands)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%016&quot;</span> PRIX64 <span class="string">&quot;  &quot;</span>, runtime_address);</span><br><span class="line"><span class="type">char</span> tmp[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">ZydisFormatterFormatInstruction</span>(&amp;formatter, &amp;instruction, operands,</span><br><span class="line">instruction.operand_count_visible, tmp, <span class="built_in">sizeof</span>(tmp),</span><br><span class="line">runtime_address, ZYAN_NULL);</span><br><span class="line"><span class="built_in">puts</span>(tmp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printInstructionStructure</span>(instruction, operands);</span><br><span class="line"></span><br><span class="line">offset += instruction.length;</span><br><span class="line">runtime_address += instruction.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Zydis是一个反汇编库，可以解析机器指令将其转为汇编代码，下面是使用方法&lt;/p&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GO逆向入门</title>
    <link href="https://www.pri87.vip/posts/356e98d9.html"/>
    <id>https://www.pri87.vip/posts/356e98d9.html</id>
    <published>2025-03-23T14:40:56.000Z</published>
    <updated>2025-03-29T03:28:09.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h1><p>golang 是谷歌开发的一个静态语言，现在有很多恶意程序使用Go语言开发</p><p><a href="https://www.anquanke.com/post/id/214940">Go二进制文件逆向分析从基础到进阶——综述-安全KER - 安全资讯平台</a></p><h2 id="Go语言基本结构"><a href="#Go语言基本结构" class="headerlink" title="Go语言基本结构"></a>Go语言基本结构</h2><p>Go语言中有些信息会一直保留在程序中，用于实现单文件直接运行而不需要环境，同时由于反射和stack trace，所以保留的信息非常多，如果找到了这些信息，就可以直接恢复符号表</p><p><a href="https://github.com/0xjiayu/go_parser/blob/master/README_cn.md">go_parser/README_cn.md at master · 0xjiayu/go_parser</a></p><p>用这里的介绍来说，基本信息如下：</p><ul><li>Meta information<ul><li>Go version</li><li>Build ID</li><li>GOROOT</li></ul></li><li>strings and string pointer（字符串指针）</li><li>runtime symbol infomation(pclntab)<ul><li>函数名称表</li><li>源代码路径表</li></ul></li><li>runtime type infomation</li><li>interface table<ul><li>接口类型</li><li>真实类型与绑定方法</li></ul></li></ul><h3 id="pclntab"><a href="#pclntab" class="headerlink" title="pclntab"></a>pclntab</h3><p>Program Counter Line Table程序计数器行数映射表/运行时符号表。程序出错时，runtime将从中得到对应的包名，文件名，方法或函数以及出错的行，最后才能输出出来，所以这里有很多有用的信息</p><p>这里最重要的函数表和函数名称表，它们的偏移都是相对于pclntab进行的</p><h2 id="恢复符号表"><a href="#恢复符号表" class="headerlink" title="恢复符号表"></a>恢复符号表</h2><p><a href="https://github.com/mandiant/GoReSym">mandiant/GoReSym: Go symbol recovery tool</a></p><p><a href="https://cloud.google.com/blog/topics/threat-intelligence/golang-internals-symbol-recovery/">Ready， Set， Go — Golang 内部原理和符号恢复 |Google Cloud 博客</a></p><p><a href="https://github.com/0xjiayu/go_parser">0xjiayu/go_parser: Yet Another Golang binary parser for IDAPro</a></p><p>一般来说，这几个就够了，但是如果加了混淆，把符号表和符号名称表的内容(偏移)删了，那就得手动还原了，就很麻烦，所以这种还是用bindiff和sig文件吧</p><h2 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h2><p><a href="QAQ">施工中</a></p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>对于这种根本看不懂的代码，对函数测试还是用黑盒吧，一般来说一个用户函数后面就有一个库调用函数，用汇编流程图反而好看一点</p>]]></content>
    
    
    <summary type="html">Go的笔记</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="语言" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Go" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E8%AF%AD%E8%A8%80/Go/"/>
    
    
    <category term="Go" scheme="https://www.pri87.vip/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>VMP壳学习笔记</title>
    <link href="https://www.pri87.vip/posts/1a88f77f.html"/>
    <id>https://www.pri87.vip/posts/1a88f77f.html</id>
    <published>2025-03-18T13:02:41.000Z</published>
    <updated>2025-03-29T03:28:09.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近想尝试写个代码混淆器，所以尝试先看看市面上的壳有哪些操作可以学一下，防止走歪路</p><p><a href="https://www.52pojie.cn/thread-1564978-1-1.html">快速认识 VMP 3.x 第一部分 壳代码篇 - 吾爱破解 - 52pojie.cn</a></p><p><a href="https://www.52pojie.cn/thread-1565126-1-1.html">快速认识VMP 3.x 第二部分 代码变异篇 - 吾爱破解 - 52pojie.cn</a></p><p><a href="https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/">🔥 Quick look around VMP 3.x - Part 3 : Virtualization | r0da’s Blog</a></p><p>看的主要是这三篇博客</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h3><p>这个部分是一般的壳都会做的操作，对可执行文件的节区进行压缩和加密防止被静态分析</p><p>原始节区的内容被放入.vmp1节区，含有被加密的节区内容，壳代码，节区信息</p><p>VMP使用ZwProtectVirtualMemory函数来修改节区权限从而执行解密代码</p><h3 id="IAT混淆"><a href="#IAT混淆" class="headerlink" title="IAT混淆"></a>IAT混淆</h3><p>原始IAT还存在，但是不会被使用，所有调用API的操作，都会被转换为运算时动态执行</p><p>具体是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call dword ptr ds:[&lt;&amp;targetFunction&gt;]</span><br></pre></td></tr></table></figure><p>变为等长的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push reg</span><br><span class="line">call api解析器</span><br></pre></td></tr></table></figure><p>api解析器中通过一些计算得到地址然后用ret跳转到api函数中</p><h2 id="代码变异"><a href="#代码变异" class="headerlink" title="代码变异"></a>代码变异</h2><p>VMP会向代码中加入垃圾代码，等效替换，控制流保护</p><p>关于插入垃圾代码和代码替换这部分不是很清楚它是怎么做的。</p><p>控制流中，VMP添加了更多无条件跳转，同时拆分了代码块，让函数和函数交错在一起，代码块不一定是对齐的，这导致了顺序的反汇编器很可能失效</p>]]></content>
    
    
    <summary type="html">VMP壳特征相关的学习笔记</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="技能" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/"/>
    
    <category term="反静态分析" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/%E5%8F%8D%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
    <category term="压缩器" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/%E5%8F%8D%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/%E5%8E%8B%E7%BC%A9%E5%99%A8/"/>
    
    
    <category term="壳" scheme="https://www.pri87.vip/tags/%E5%A3%B3/"/>
    
    <category term="反调试" scheme="https://www.pri87.vip/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    
    <category term="代码混淆" scheme="https://www.pri87.vip/tags/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    
    <category term="虚拟机" scheme="https://www.pri87.vip/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>组合模式</title>
    <link href="https://www.pri87.vip/posts/df879792.html"/>
    <id>https://www.pri87.vip/posts/df879792.html</id>
    <published>2025-03-17T15:00:32.000Z</published>
    <updated>2025-03-17T15:52:47.500Z</updated>
    
    <content type="html"><![CDATA[<p>如果你要实现以下功能：<br>一个卡牌类，有不同的效果，很自然地可以想到以下实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">std::string name;</span><br><span class="line">std::string description;</span><br><span class="line"><span class="type">size_t</span> id;</span><br><span class="line">dword cost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onHandTurnStart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onTurnStart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onUse</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onHandTurnEnd</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onTurnEnd</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">dword <span class="title">onAttacked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">afterAttacked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">dword <span class="title">onAttack</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">afterAttack</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myCard</span> : <span class="keyword">public</span> BaseCard&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onUse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.<span class="built_in">heal</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">player</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">useCard</span><span class="params">(BaseCard&amp; card)</span></span>&#123;</span><br><span class="line">        card.<span class="built_in">onUse</span>();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TurnStart</span><span class="params">(BaseCard&amp; card)</span></span>&#123;</span><br><span class="line">        card.<span class="built_in">onTurnStart</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样，如果要创造更多的不一样的卡牌，就要一直添加Card，同时，如果考虑人物技能，道具能力，也许一个效果要重写多次，所以，完全可以将效果单独拿出来当作新类，然后在对应人物/道具/卡牌中添加不同的效果模块</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Effect</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTurnStart</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onUse</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Effect</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AEffect</span> : <span class="keyword">public</span> Effect &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onUse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.<span class="built_in">heal</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CaposEffect</span> : <span class="keyword">public</span> Effect&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Effect&gt;&gt; ce;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onUse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> effect:ce)&#123;</span><br><span class="line">            effect-&gt;<span class="built_in">onUse</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEffect</span><span class="params">(std::shared_ptr&lt;Effect&gt;&amp;x)</span></span>&#123;</span><br><span class="line">        ce.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">std::string name;</span><br><span class="line">std::string description;</span><br><span class="line"><span class="type">size_t</span> id;</span><br><span class="line">dword cost;</span><br><span class="line">std::shared_ptr&lt;CaposEffect&gt; effects;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onHandTurnStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        effects-&gt;<span class="built_in">onHandTurnStart</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onUse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        effects-&gt;<span class="built_in">onUse</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEffect</span><span class="params">(std::shared_ptr&lt;Effect&gt;&amp;x)</span></span>&#123;</span><br><span class="line">        effects.<span class="built_in">addEffect</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myCard</span> : <span class="keyword">public</span> BaseCard&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onUse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.<span class="built_in">heal</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现了两种对象之间的解耦，且可以为effect创建effect组，实现多种效果的组合。</p>]]></content>
    
    
    <summary type="html">组合模式</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="开发" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/"/>
    
    <category term="面向对象基础" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="OOP" scheme="https://www.pri87.vip/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>驱动开发入门</title>
    <link href="https://www.pri87.vip/posts/d2620136.html"/>
    <id>https://www.pri87.vip/posts/d2620136.html</id>
    <published>2025-03-09T10:17:34.000Z</published>
    <updated>2025-03-10T14:40:41.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h2><p>在Windows中，驱动是运行在内核(R0层)的软件。由于运行在内核层，所以可以做操作系统可以做的绝大多数事情，比如和硬件进行交互，就必须在内核中执行。一般来说，驱动都是用来实现某设备的IO操作的。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>驱动分为如下几种类型：</p><ul><li>设备函数驱动程序<ul><li>实现硬件设备的逻辑，比如设备的初始化和数据传输等</li><li>一般为硬件制造商开发</li><li>例：键盘驱动程序，显示驱动程序，打印机驱动程序</li></ul></li><li>设备筛选器驱动程序<ul><li>设备筛选器是用来修改或扩展设备函数驱动的行为的驱动，分为上层过滤器和下层过滤器</li><li>可以拦截或修改设备的操作，类似与钩子</li><li>例：拦截和记录USB设备通信的驱动程序</li></ul></li><li>软件驱动程序<ul><li>为逻辑设备服务的驱动程序，实现虚拟设备或系统功能</li><li>实现虚拟功能并处理高层逻辑而非硬件交互。</li><li>例：虚拟磁盘，虚拟网卡</li></ul></li><li>文件系统筛选器驱动程序<ul><li>用来监控，修改或增强文件系统的行为的驱动，附加在文件系统驱动堆栈中，可以拦截文件操作的IO操作</li><li>检查修改文件操作，打开读取写入等，执行权限控制，加密，数据压缩等</li><li>例：防止未授权访问文件</li></ul></li><li>文件系统驱动程序<ul><li>实现文件操作逻辑的驱动(NTFS,FAT32等)，文件系统堆栈中的核心部分，直接管理磁盘上的文件</li><li>实现文件读写，路径解析，目录管理</li><li>例：Windows中的ntfs.sys和fat32.sys</li></ul></li></ul><h3 id="驱动对象和设备对象"><a href="#驱动对象和设备对象" class="headerlink" title="驱动对象和设备对象"></a>驱动对象和设备对象</h3><h4 id="驱动对象"><a href="#驱动对象" class="headerlink" title="驱动对象"></a>驱动对象</h4><p>操作系统标识一个驱动的数据结构</p><p>该对象由操作系统自动生成(下面是WDM)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pdriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">DbgPrint(<span class="string">&quot;DriverUnload\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject,</span></span><br><span class="line"><span class="params">PUNICODE_STRING pRegPath<span class="comment">//注册表路径</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">DbgPrint(<span class="string">&quot;DriverEntry\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">pDriverObject-&gt;DriverUnload = DriverUnload;<span class="comment">//指定驱动卸载函数</span></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这之中pDriverObject是操作系统为这个驱动创建的驱动对象，部分内容需要在DriverEntry中由用户添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> &#123;</span></span><br><span class="line">    CSHORT Type;</span><br><span class="line">    CSHORT Size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The following links all of the devices created by a single driver</span></span><br><span class="line">    <span class="comment">// together on a list, and the Flags word provides an extensible flag</span></span><br><span class="line">    <span class="comment">// location for driver objects.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    PDEVICE_OBJECT DeviceObject;</span><br><span class="line">    ULONG Flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The following section describes where the driver is loaded.  The count</span></span><br><span class="line">    <span class="comment">// field is used to count the number of times the driver has had its</span></span><br><span class="line">    <span class="comment">// registered reinitialization routine invoked.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    PVOID DriverStart;</span><br><span class="line">    ULONG DriverSize;</span><br><span class="line">    PVOID DriverSection;</span><br><span class="line">    PDRIVER_EXTENSION DriverExtension;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The driver name field is used by the error log thread</span></span><br><span class="line">    <span class="comment">// determine the name of the driver that an I/O request is/was bound.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    UNICODE_STRING DriverName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The following section is for registry support.  This is a pointer</span></span><br><span class="line">    <span class="comment">// to the path to the hardware information in the registry</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    PUNICODE_STRING HardwareDatabase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The following section contains the optional pointer to an array of</span></span><br><span class="line">    <span class="comment">// alternate entry points to a driver for &quot;fast I/O&quot; support.  Fast I/O</span></span><br><span class="line">    <span class="comment">// is performed by invoking the driver routine directly with separate</span></span><br><span class="line">    <span class="comment">// parameters, rather than using the standard IRP call mechanism.  Note</span></span><br><span class="line">    <span class="comment">// that these functions may only be used for synchronous I/O, and when</span></span><br><span class="line">    <span class="comment">// the file is cached.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    PFAST_IO_DISPATCH FastIoDispatch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The following section describes the entry points to this particular</span></span><br><span class="line">    <span class="comment">// driver.  Note that the major function dispatch table must be the last</span></span><br><span class="line">    <span class="comment">// field in the object so that it remains extensible.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    PDRIVER_INITIALIZE DriverInit;</span><br><span class="line">    PDRIVER_STARTIO DriverStartIo;</span><br><span class="line">    PDRIVER_UNLOAD DriverUnload;</span><br><span class="line">    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125; DRIVER_OBJECT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> *<span class="title">PDRIVER_OBJECT</span>;</span> </span><br></pre></td></tr></table></figure><p>在c中，它的定义和可行的操作如上</p><p>可以看出操作系统用一个单链表连接了所有的设备对象。且使用了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PDRIVER_INITIALIZE DriverInit;</span><br><span class="line">PDRIVER_STARTIO DriverStartIo;</span><br><span class="line">PDRIVER_UNLOAD DriverUnload;</span><br><span class="line">PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>来为操作系统调用驱动中的函数提供了基础。</p><p>一般来说，一个驱动注册好了后，会和其它同类驱动组合成驱动栈，它们从高到低地处理不同层级的问题，每当引发一个请求，都会从高到低询问要不要处理，如果不处理就会继续向下，如果处理，那么就此终止，不会继续传递。</p><h4 id="设备对象"><a href="#设备对象" class="headerlink" title="设备对象"></a>设备对象</h4><p>设备对象是操作对象用来描述一个设备的核心数据结构。可以标识并管理硬件设备或逻辑设备。</p><p>需要自创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PDRIVER_OBJECT DriverObject,</span></span><br><span class="line"><span class="params">    _In_ PUNICODE_STRING RegistryPath</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    PDEVICE_OBJECT DeviceObject = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = IoCreateDevice(</span><br><span class="line">        DriverObject,            <span class="comment">// 所属驱动对象</span></span><br><span class="line">        <span class="keyword">sizeof</span>(DEVICE_EXTENSION), <span class="comment">// 设备扩展的大小</span></span><br><span class="line">        &amp;DeviceName,             <span class="comment">// 设备名称</span></span><br><span class="line">        FILE_DEVICE_UNKNOWN,     <span class="comment">// 设备类型</span></span><br><span class="line">        <span class="number">0</span>,                       <span class="comment">// 特性标志</span></span><br><span class="line">        FALSE,                   <span class="comment">// 是否为独占设备</span></span><br><span class="line">        &amp;DeviceObject            <span class="comment">// 输出设备对象</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status; <span class="comment">// 创建失败时返回错误状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PDRIVER_OBJECT pDriverObject,</span></span><br><span class="line"><span class="params">    _In_ PUNICODE_STRING pRegistryPath</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    PDEVICE_OBJECT pDeviceObject = <span class="literal">NULL</span>;</span><br><span class="line">    UNICODE_STRING deviceName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\FileFilter&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建设备对象</span></span><br><span class="line">    status = IoCreateDevice(</span><br><span class="line">        pDriverObject,          <span class="comment">// 驱动对象</span></span><br><span class="line">        <span class="number">0</span>,                      <span class="comment">// 没有设备扩展</span></span><br><span class="line">        &amp;deviceName,            <span class="comment">// 设备名</span></span><br><span class="line">        FILE_DEVICE_DISK_FILE_SYSTEM, <span class="comment">// 指定为文件系统类型</span></span><br><span class="line">        <span class="number">0</span>,                      <span class="comment">// 无特殊特性</span></span><br><span class="line">        FALSE,                  <span class="comment">// 非独占</span></span><br><span class="line">        &amp;pDeviceObject          <span class="comment">// 输出设备对象指针</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;Failed to create device object\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置卸载函数和其他初始化逻辑</span></span><br><span class="line">    pDriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = FileCreateHandler; <span class="comment">// 处理文件创建</span></span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_READ] = FileReadHandler;     <span class="comment">// 处理文件读取</span></span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;Device object created successfully\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(_In_ PDRIVER_OBJECT pDriverObject)</span> &#123;</span><br><span class="line">    UNICODE_STRING deviceName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\FileFilter&quot;</span>);</span><br><span class="line">    IoDeleteDevice(pDriverObject-&gt;DeviceObject); <span class="comment">// 删除设备对象</span></span><br><span class="line">    DbgPrint(<span class="string">&quot;Driver unloaded\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> IRP_MJ_CREATE 和 IRP_MJ_READ 是 I/O 请求包（IRP）的主功能码，分别对应文件/设备的创建（或打开）操作和读取操作。当用户层调用相关 I/O 操作（如 CreateFile 或 ReadFile）时，操作系统的 I/O 管理器会生成对应的 IRP，并将其传递到目标设备的驱动栈中。驱动程序通过在驱动对象中注册的调度例程（Dispatch Routine）处理这些 IRP 请求。调度例程会把主功能码映射为MajorFunction的索引，然后驱动指定对应索引的函数来实现功能。</p>]]></content>
    
    
    <summary type="html">介绍驱动基本概念</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="开发" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/"/>
    
    <category term="驱动开发" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="驱动" scheme="https://www.pri87.vip/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Win11虚拟机配置</title>
    <link href="https://www.pri87.vip/posts/a848d09.html"/>
    <id>https://www.pri87.vip/posts/a848d09.html</id>
    <published>2025-03-05T09:31:13.000Z</published>
    <updated>2025-03-10T05:57:59.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ios下载"><a href="#ios下载" class="headerlink" title="ios下载"></a>ios下载</h2><p><a href="https://next.itellyou.cn/Original/Index">Itellyou</a></p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p><a href="https://www.vmware.com/products">VMware</a></p><h2 id="安装vmware-tools"><a href="#安装vmware-tools" class="headerlink" title="安装vmware tools"></a>安装vmware tools</h2><p>虚拟机整个安装好之后(进入桌面)</p><p><img src="https://s2.loli.net/2025/03/05/q1o7PB8HZGiuNV6.png" alt="image-20250305212801916"></p><p>没有安装的话不会是重新安装，点击后，按虚拟机中的提示安装即可。</p><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><p>管理员powershell:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">irm</span> https://get.activated.win | <span class="built_in">iex</span></span><br></pre></td></tr></table></figure><h2 id="连接主机网络"><a href="#连接主机网络" class="headerlink" title="连接主机网络"></a>连接主机网络</h2><p>虚拟机网络选择net模式、关闭虚拟机防火墙</p><p>win+x然后i执行ipconfig：Ethernet0就是虚拟机本地ip</p><p>主机用同理方法可以得到ip地址，相互ping来测试</p><p>或者直接<code>ping 计算机名</code> 也可以</p><h2 id="配置虚拟机wdk和连接"><a href="#配置虚拟机wdk和连接" class="headerlink" title="配置虚拟机wdk和连接"></a>配置虚拟机wdk和连接</h2><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/provision-a-target-computer-wdk-8-1">预配计算机以便进行驱动程序部署和测试 (WDK 10) - Windows drivers | Microsoft Learn</a></p><p>在虚拟机中安装wdk，执行<code>C:\Program Files (x86)\Windows Kits\10\Remote\x64\WDK Test Target Setup x64-x64_en-us.msi</code>这个文件</p><p>然后vs打开项目的扩展-driver-Test-Configure Devices…添加对应主机名或ip</p><p>然后设置为目标计算机</p><p><img src="https://s2.loli.net/2025/03/06/xT5iMW9stkQ6uJd.png" alt="image-20250306153628068"></p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>虚拟机中开启测试模式</p><p>对于上面显示的key和port，宿主机中</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Windbg <span class="literal">-k</span> net:port=xxx,key=xxx</span><br></pre></td></tr></table></figure><p>在C:\Program Files (x86)\Windows Kits\10\Debuggers\x64下执行</p><h2 id="关于部署驱动和在vs中调试的报错"><a href="#关于部署驱动和在vs中调试的报错" class="headerlink" title="关于部署驱动和在vs中调试的报错"></a>关于部署驱动和在vs中调试的报错</h2><h3 id="编译期报错：需要缓解库或者语法错误"><a href="#编译期报错：需要缓解库或者语法错误" class="headerlink" title="编译期报错：需要缓解库或者语法错误"></a>编译期报错：需要缓解库或者语法错误</h3><p>确保缓解库版本和工具链版本一致，如果是最新，需要在项目属性中找到MVCS版本，调整为所有可选版本中最新的版本，而不是默认</p><p>语法错误需要检查编码，尝试以UTF8存储或者GBK，多试几个应该就好了</p><h3 id="报错：第三方inf不包含数字签名信息"><a href="#报错：第三方inf不包含数字签名信息" class="headerlink" title="报错：第三方inf不包含数字签名信息"></a>报错：第三方inf不包含数字签名信息</h3><p>需要生成crt证书文件，项目，属性，Inf2Cat，Run Inf2Cat 改为是<br>属性，Driver Signing中Sign Mode改为Test Sign<br>虚拟机开启测试模式 </p><h3 id="Windbg无法调试，打开一直显示Waiting-to-reconnect…"><a href="#Windbg无法调试，打开一直显示Waiting-to-reconnect…" class="headerlink" title="Windbg无法调试，打开一直显示Waiting to reconnect…"></a>Windbg无法调试，打开一直显示Waiting to reconnect…</h3><p>首先确保虚拟机调试模式一打开，如果vs中设置好了port和key，且虚拟机中<br><code>bcdedit /dbgsettings</code>查看设置是否相同，如果相同，尝试关闭虚拟机的调试模式再打开，重复两三次，然后再尝试（这个被坑了好久，最后还是学长帮我配好的）</p><h3 id="driverquery无法看到对应的驱动"><a href="#driverquery无法看到对应的驱动" class="headerlink" title="driverquery无法看到对应的驱动"></a>driverquery无法看到对应的驱动</h3><p>查看当前驱动是不是硬件驱动，在设备管理器中选择按驱动分类，可以找到自己安装的驱动，想要看这种驱动的值，可以通过驱动注入程序强制安装，然后在dbgview中看到效果。如果是微软写的抽象helloworld代码，因为没写卸载函数，所以不能卸载。不如用下面这个做测试(用wdm项目)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pdriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">DbgPrint(<span class="string">&quot;DriverUnload\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject,</span></span><br><span class="line"><span class="params">PUNICODE_STRING pRegPath<span class="comment">//注册表路径</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">DbgPrint(<span class="string">&quot;DriverEntry\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pDriverObject-&gt;DriverUnload = DriverUnload;<span class="comment">//指定驱动卸载函数</span></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太抽象了，这个环境配了6天TAT，感谢 <span class='nota' data-nota='卡密'>学长</span> 帮我。</p>]]></content>
    
    
    <summary type="html">配置win11虚拟机以适配调试驱动环境</summary>
    
    
    
    <category term="实践" scheme="https://www.pri87.vip/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="记录" scheme="https://www.pri87.vip/categories/%E5%AE%9E%E8%B7%B5/%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>IDA自动化调试</title>
    <link href="https://www.pri87.vip/posts/9be53c83.html"/>
    <id>https://www.pri87.vip/posts/9be53c83.html</id>
    <published>2025-03-04T14:52:26.000Z</published>
    <updated>2025-03-05T09:29:15.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前一直想找个方法实现IDA调试的时候自动执行操作，现在终于找到了</p><p>ida里面有一个api：ida_dbg.step_into()，效果是执行一次步入，通过循环这个指令就可以实现自动步入的效果，在步过后写自己需要的效果就好</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>下面是一个对于dasctf，BabyEnc的指令还原脚本，这个题将真的逻辑用汇编写了出来，并把每句汇编放在格式相同的花指令中，通过下面这个脚本可以提取每组汇编中的真实代码，组合成一个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idc <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> ida_dbg</span><br><span class="line"></span><br><span class="line">statx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_address</span>(<span class="params">target_ea</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;trace_output.bin&quot;</span>, <span class="string">&quot;ab&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            ida_dbg.wait_for_next_event(ida_dbg.WFNE_SUSP, -<span class="number">1</span>)<span class="comment">#在获取内存/寄存器/状态和执行(f4,f7,f8,f9)之间必须有这行，ida是单线程，必须等待调试器获取到状态之后再取内容</span></span><br><span class="line">            current_ea = ida_dbg.get_reg_val(<span class="string">&quot;EIP&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> current_ea == target_ea:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                handle_instruction(current_ea, f)</span><br><span class="line">                ida_dbg.step_into()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_instruction</span>(<span class="params">ea, file</span>):</span><br><span class="line">    <span class="keyword">global</span> statx</span><br><span class="line">    statx-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(statx &lt;= <span class="number">0</span>):<span class="comment">#减少时间，ida指令需要时间</span></span><br><span class="line">        instr = idc.GetDisasm(ea)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;jmp     ebx&quot;</span> <span class="keyword">in</span> instr:<span class="comment">#在每块的结尾执行</span></span><br><span class="line">            statx = <span class="number">11</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            ea_temp = ea</span><br><span class="line">            prev_instr = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; <span class="number">11</span>:<span class="comment">#向上找第十一行代码</span></span><br><span class="line">                ea_temp = idc.prev_head(ea_temp)</span><br><span class="line">                prev_instr = idc.GetDisasm(ea_temp)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;popa&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> prev_instr <span class="keyword">and</span> <span class="string">&quot;cmp&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> prev_instr:<span class="comment">#过滤跳转指令</span></span><br><span class="line">                machine_code = ida_bytes.get_bytes(ea_temp, idc.get_item_size(ea_temp))</span><br><span class="line">                file.write(machine_code)</span><br><span class="line">                <span class="built_in">print</span>(prev_instr)</span><br><span class="line"></span><br><span class="line">check_address(<span class="number">0x0041F082</span>)</span><br></pre></td></tr></table></figure><p>另一种实现是依赖断点的实现，继承DBG_hooks实现断点钩子，需要准确知道在哪里下断点才行，感觉有点麻烦，不过要是能算出来具体的位置，那也很简单，速度也更快</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>需要的时间太长了，尤其是在有长花指令的情况下，这段代码大概执行了90分钟左右，但是没有花指令一般好像也不需要这种操作(也许控制流混淆需要？)。不过另外一方面，编写这种脚本不需要脑子，不需要主动获取寄存器的值，模拟执行可能写的有偏差，但是这种就肯定不会错。</p>]]></content>
    
    
    <summary type="html">IDA的自动化调试</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="自动化逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%80%86%E5%90%91/"/>
    
    
    <category term="IDA" scheme="https://www.pri87.vip/tags/IDA/"/>
    
  </entry>
  
  <entry>
    <title>MASM汇编</title>
    <link href="https://www.pri87.vip/posts/dfd755e7.html"/>
    <id>https://www.pri87.vip/posts/dfd755e7.html</id>
    <published>2025-02-28T10:42:42.000Z</published>
    <updated>2025-04-28T15:44:58.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="x16基本格式"><a href="#x16基本格式" class="headerlink" title="x16基本格式"></a>x16基本格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment;指定段</span><br><span class="line"></span><br><span class="line">int 21h;退出</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="x86基本格式"><a href="#x86基本格式" class="headerlink" title="x86基本格式"></a>x86基本格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">.586;指定指令集版本</span><br><span class="line">.model flat,stdcall;设置内存模型和调用约定:_edecl,_stdcall,_fastcall，_thiscall</span><br><span class="line">option casemap:none;区分大小写</span><br><span class="line"></span><br><span class="line">includelib ucrt.lib;导入c相关标准库</span><br><span class="line">includelib legacy_stdio_definitions.lib;导入c相关库</span><br><span class="line"></span><br><span class="line">includelib Kernel32.lib</span><br><span class="line">includelib User32.lib</span><br><span class="line"></span><br><span class="line">MessageBoxA proto hwnd:DWORD,lpText:BYTE,lpCaption:BYTE,uType:DWORD</span><br><span class="line">ExitProcess proto uCode:DWORD</span><br><span class="line"></span><br><span class="line">extern printf:proc;声明外部函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.data;指定段</span><br><span class="line">szFormat db &#x27;%d&#x27;, 0</span><br><span class="line"></span><br><span class="line">.code;指定段</span><br><span class="line">main proc</span><br><span class="line">mov eax,64h</span><br><span class="line">push eax;函数调用</span><br><span class="line">lea ecx,szFormat</span><br><span class="line">push ecx</span><br><span class="line">call printf</span><br><span class="line">add esp,8;c标准</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">push 0</span><br><span class="line">push 0</span><br><span class="line">push 0</span><br><span class="line">call MessageBoxA;</span><br><span class="line">push 0</span><br><span class="line">call ExitProcess;win标准 或者可以写invoke ExitProcess,0</span><br><span class="line">main endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="汇编头文件-inc"><a href="#汇编头文件-inc" class="headerlink" title="汇编头文件(.inc)"></a>汇编头文件(.inc)</h3><p>包含头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include header.inc</span><br></pre></td></tr></table></figure><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><h4 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h4><p>使用前必须先定义，比如上面的<code>ExitProcess proto uCode:DWORD</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke farproc,para1,para2,...</span><br></pre></td></tr></table></figure><p>只能用于win32 api</p><p><a href="https://masm32.com/download.htm">Download The MASM32 SDK</a>下载MASM32SDK</p><p>效果是可以直接导入已经定义好的函数，可以直接invoke</p><p>在项目属性中Microsoft Macro Assembler-include Paths中附加MASM中的include目录，然后可以直接这样使用函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.586;指定指令集版本</span><br><span class="line">.model flat,stdcall;设置内存模型和调用约定:_edecl,_stdcall,_fastcall，_thiscall</span><br><span class="line">option casemap:none;区分大小写</span><br><span class="line"></span><br><span class="line">includelib ucrt.lib;导入c相关标准库</span><br><span class="line">includelib legacy_stdio_definitions.lib;导入c相关库</span><br><span class="line"></span><br><span class="line">include Kernel32.inc</span><br><span class="line">include User32.inc</span><br><span class="line"></span><br><span class="line">includelib Kernel32.lib</span><br><span class="line">includelib User32.lib</span><br><span class="line"></span><br><span class="line">extern printf:proc;声明外部函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.data;指定段</span><br><span class="line">szFormat db &#x27;%d&#x27;, 0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">mov eax,64h</span><br><span class="line">push eax;函数调用</span><br><span class="line">lea ecx,szFormat</span><br><span class="line">push ecx</span><br><span class="line">call printf</span><br><span class="line">add esp,8;c标准</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">push 0</span><br><span class="line">push 0</span><br><span class="line">push 0</span><br><span class="line">call MessageBoxA;</span><br><span class="line">push 0</span><br><span class="line">call ExitProcess;win标准 或者可以写invoke ExitProcess,0</span><br><span class="line">main endp</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>对于自己定义的函数，使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addx proc numA:dword,numB:dword</span><br><span class="line">xor eax,eax</span><br><span class="line">add eax,numA</span><br><span class="line">add eax,numB</span><br><span class="line">ret</span><br><span class="line">addx endp</span><br></pre></td></tr></table></figure><p>这样的格式，也可以用invoke调用，对于C库的cstd函数，可以通过这个方式进行一次std的封装。</p><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main proc</span><br><span class="line">mov dwIndex,11</span><br><span class="line">    .if dwIndex== 10</span><br><span class="line">    mov dwNumber,10</span><br><span class="line">    invoke printNumber,dwNumber</span><br><span class="line">    .elseif deIndex &gt;= 12</span><br><span class="line">    mov dwNumber,12</span><br><span class="line">    invoke printNumber,dwNumber</span><br><span class="line">    .else</span><br><span class="line">    mov dwNumber,0</span><br><span class="line">    invoke printNumber,dwNumber</span><br><span class="line">    .endif</span><br><span class="line">main endp</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">.break;跳出循环</span><br><span class="line">.continue;跳到条件检查</span><br></pre></td></tr></table></figure><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dwIndex,100</span><br><span class="line">.while dwIndex&gt;0</span><br><span class="line">dec deIndex</span><br><span class="line">.endw</span><br></pre></td></tr></table></figure><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>无参宏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAA EQU 100</span><br></pre></td></tr></table></figure><p>将AAA当100</p><p>有参宏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;定义</span><br><span class="line">MyAdd MACRO n1</span><br><span class="line">add eax,n1</span><br><span class="line">endm</span><br><span class="line">;使用</span><br><span class="line">MyAdd &lt;1&gt;;简单参数也可以直接MyAdd 1</span><br><span class="line"></span><br><span class="line">MyAdd2 MACRO reg,n1</span><br><span class="line">add reg,n1</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">MyAdd eax,10</span><br></pre></td></tr></table></figure><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>在data段外声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Point struct;声明</span><br><span class="line">x word ?</span><br><span class="line">y word ?</span><br><span class="line">Point ends</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">MyPoint Point&lt;?&gt;;不初始化定义</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">    mov MyPoint.x,123</span><br><span class="line">    mov MyPoint.y,456</span><br><span class="line">main endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h3><p>vs中可以在c和cpp中使用内联汇编</p><p>x86：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_asm&#123;</span><br><span class="line">push MB_OK;可以直接传宏</span><br><span class="line">call myFunc;可以直接调用定义的函数</span><br><span class="line">_emit 1;立即数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x64：</p><p>在生成依赖项中勾选masm，新建asm文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.code</span><br><span class="line">Myadd proc</span><br><span class="line">mov ecx,edx</span><br><span class="line">mov eax,ecx</span><br><span class="line">ret</span><br><span class="line">Myadd endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>再声明head.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exten <span class="string">&quot;C&quot;</span> DWORD <span class="title function_">Myadd</span><span class="params">(DWORD a,DWORD b)</span>;</span><br></pre></td></tr></table></figure><p>包含这个文件即可直接使用</p><h2 id="x64基本格式"><a href="#x64基本格式" class="headerlink" title="x64基本格式"></a>x64基本格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">sub rsp,28h</span><br><span class="line">add rsp,28h</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>可以直接写代码，调用函数用fastcall</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">.data?;定义未初始化数据</span><br><span class="line">.const;定义常量</span><br></pre></td></tr></table></figure><p>通过修改编译器为inter，可以继续使用内联汇编</p><p>可以直接使用vs或者ida查看c/cpp代码然后取得相应的汇编代码，避免麻烦<br>VS中需要先取消符号</p>]]></content>
    
    
    <summary type="html">MASM下的汇编学习</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="基础" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="汇编" scheme="https://www.pri87.vip/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
</feed>
