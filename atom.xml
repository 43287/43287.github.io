<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pRism</title>
  
  
  <link href="https://www.pri87.vip/atom.xml" rel="self"/>
  
  <link href="https://www.pri87.vip/"/>
  <updated>2025-05-01T05:49:49.723Z</updated>
  <id>https://www.pri87.vip/</id>
  
  <author>
    <name>pRism</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PrattParsing解析表达式</title>
    <link href="https://www.pri87.vip/posts/d6331565.html"/>
    <id>https://www.pri87.vip/posts/d6331565.html</id>
    <published>2025-04-30T14:02:16.000Z</published>
    <updated>2025-05-01T05:49:49.723Z</updated>
    
    <content type="html"><![CDATA[<p>本文是一篇翻译，太悲伤了，不知道怎么翻，机翻还是太好用了，出处：</p><p><a href="https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html">Simple but Powerful Pratt Parsing</a></p><h1>简单强大的Pratt 解析</h1><p>这篇文章是一个语法解析的monad教程。关于Pratt解析的文章很多，甚至这里有一个<a href="https://www.oilshell.org/blog/2017/03/31.html">合集blog</a></p><p>我写这篇文章的目的是：</p><ul><li>说明左递归问题是容易解决的</li><li>用另一种方式代替不好识别中缀表达式的BNF</li><li>给出Pratt的算法描述和具体实现，并聚焦重点，不引入DSL-y的抽象</li><li>希望这是我最后一次理解这个算法，之前写过一次，但是写完之后就忘了QAQ</li></ul><p>本文假设读者对解析操作有基本的理解，知晓基本术语，比如上下文无关语法</p><h2 id="导入">导入</h2><p>解析(parser)是编译器将标记的序列转为语法树表示的过程：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                           Add</span><br><span class="line">                Parser     / <span class="string">\</span> </span><br><span class="line"><span class="string">&quot;1 + 2 * 3&quot;</span>    -------&gt;   <span class="number">1</span>  Mul</span><br><span class="line">                             / <span class="string">\</span></span><br><span class="line">                            <span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><p>实现这个过程有很多方式，我们一般分为两类：</p><ul><li>使用DSL定义一个语言的抽象语法</li><li>手动实现解析</li></ul><h2 id="BNF">BNF</h2><p>语法分析的作用就是将token流解析为树结构，其中最重要的方法就是使用上下文无关语法来记录（一般用BNF语法）</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Item =</span><br><span class="line">    StructItem</span><br><span class="line">  <span class="string">| EnumItem</span></span><br><span class="line">  <span class="string">| ...</span></span><br><span class="line">StructItem =</span><br><span class="line">    &#x27;struct&#x27; Name &#x27;&#123;&#x27; FieldList &#x27;&#125;&#x27;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>自然语言和程序语言结构十分地相似，这让我很激动，BNF可以做到解析它们。但是当我尝试解析表达式的时候，BNF就不好用了。我们先看看自然语言表达式的表达：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Expr</span> =</span><br><span class="line">    <span class="built_in">Expr</span> <span class="string">&#x27;+&#x27;</span> <span class="built_in">Expr</span></span><br><span class="line">  | <span class="built_in">Expr</span> <span class="string">&#x27;*&#x27;</span> <span class="built_in">Expr</span></span><br><span class="line">  | <span class="string">&#x27;(&#x27;</span> <span class="built_in">Expr</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">  | &#x27;number&#x27;</span><br></pre></td></tr></table></figure><p>这样写是没什么问题的，但是还需要考虑运算符的优先级和结合性，所以BNF会变成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Expr =</span><br><span class="line">    Factor</span><br><span class="line">  | Expr <span class="string">&#x27;+&#x27;</span> <span class="type">Factor</span></span><br><span class="line"><span class="variable">Factor</span> <span class="operator">=</span></span><br><span class="line">    Atom</span><br><span class="line">  | Factor <span class="string">&#x27;*&#x27;</span> <span class="type">Atom</span></span><br><span class="line"><span class="variable">Atom</span> <span class="operator">=</span></span><br><span class="line">    <span class="string">&#x27;number&#x27;</span></span><br><span class="line">  | <span class="string">&#x27;(&#x27;</span> Expr <span class="string">&#x27;)&#x27;</span></span><br></pre></td></tr></table></figure><p>这样再看，就会感觉它很不“表达式”。而且很难写，在我能写出来这种语法之前，我多学了至少3，4课才学会。</p><p>这就是为什么我喜欢Pratt解析（基于递归下降而又比它强），它使用自然语言中的优先级和关联性来解析表达式，而不是语法混淆技术(存疑？)</p><h2 id="递归下降和左递归">递归下降和左递归</h2><p>下面是使用递归下降实现的上面那个例子的代码，它是用一组嵌套递归的函数来实现的，所以叫递归下降：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="title function_">item</span>(<span class="params">p: &amp;mut Parser</span>) &#123;</span><br><span class="line">    match p.<span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="function"><span class="params">STRUCT_KEYWORD</span> =&gt;</span> <span class="title function_">struct_item</span>(p),</span><br><span class="line">        <span class="function"><span class="params">ENUM_KEYWORD</span>   =&gt;</span> <span class="title function_">enum_item</span>(p),</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn <span class="title function_">struct_item</span>(<span class="params">p: &amp;mut Parser</span>) &#123;</span><br><span class="line">    p.<span class="title function_">expect</span>(<span class="variable constant_">STRUCT_KEYWORD</span>);</span><br><span class="line">    <span class="title function_">name</span>(p);</span><br><span class="line">    p.<span class="title function_">expect</span>(<span class="variable constant_">L_CURLY</span>);</span><br><span class="line">    <span class="title function_">field_list</span>(p);</span><br><span class="line">    p.<span class="title function_">expect</span>(<span class="variable constant_">R_CURLY</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>书上说这种方法有一个缺点，那就是左递归。因而它带来了更高级的LR解析技术。可以看看下面这个有问题的例子：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sum</span> =</span><br><span class="line">    <span class="built_in">Sum</span> &#x27;+&#x27; <span class="built_in">Int</span></span><br><span class="line">  | <span class="built_in">Int</span></span><br></pre></td></tr></table></figure><p>写成代码呢：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="built_in">sum</span>(p: &amp;mut Parser) &#123;</span><br><span class="line">    <span class="comment">// 第一个选项</span></span><br><span class="line">    <span class="built_in">sum</span>(p); </span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-class">.expect</span>(PLUS);</span><br><span class="line">    <span class="built_in">int</span>(p);</span><br><span class="line">    <span class="comment">// 如果失败，选第二个选项</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第三行，sum§会无限递归导致栈溢出</p><p>所以我们一般在实践中用循环代替递归：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="built_in">sum</span>(p: &amp;mut Parser) &#123;</span><br><span class="line">    <span class="built_in">int</span>(p);</span><br><span class="line">    while <span class="selector-tag">p</span><span class="selector-class">.eat</span>(PLUS) &#123;</span><br><span class="line">        <span class="built_in">int</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pratt解析标准模板">Pratt解析标准模板</h2><p>如果只有循环，前缀表达式就不能解析。所以，Pratt用循环和递归一起实现解析操作：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn parse_expr() &#123;</span><br><span class="line">    <span class="params">...</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="params">...</span></span><br><span class="line">        parse_expr()</span><br><span class="line">        <span class="params">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它把表达式放进循环，还能解析优先级和关联性</p><h2 id="优先级与绑定能力">优先级与绑定能力</h2><p>我经常把高优先级和低优先级搞混。在a+b*c中加法的优先级较低，但是它在语法树的顶端。所以我们可以引入绑定能力这个概念：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表达式:   A       +       B       *       C</span><br><span class="line">绑定能力:    <span class="number"> 3 </span>     <span class="number"> 3 </span>     <span class="number"> 5 </span>      5</span><br></pre></td></tr></table></figure><p>在这个例子中，*更强，所以它绑定左右内容的能力更强，因此整个表达式先组合BC，然后组合A和BC</p><p>那相关性呢？如果是A+B+C，每个运算符都是一样的，那要怎么判断是(A+B)+C还是A+(B+C)，但是绑定能力也可以表示这个特性：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表达式:      A       +       B       +       C</span><br><span class="line">绑定能力:<span class="number"> 0 </span>    <span class="number"> 3 </span>     3.1     <span class="number"> 3 </span>     3.1     0</span><br></pre></td></tr></table></figure><p>这里我们把+的右侧的绑定能力增加了，这样可以让+运算符后面的数和+联系得更紧密。然后在左右加0说明两边没有操作符。对于B来说，左边的+比右边的+的绑定能力更强，所以它和左边的+优先结合，因此，可以化简为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">表达式:      (A + B)     +     C</span></span><br><span class="line"><span class="section">绑定能力:  0          3    3.1    0</span></span><br></pre></td></tr></table></figure><p>然后就顺理成章了，第二个+更喜欢后面那个数，所以在它连接C时，A和B被第一个+捕获了，这是很清晰的。</p><p>Pratt解析需要在读取从左到右的token流的同时来实现上面的过程。这无疑是比邻居搜索算法(存疑？)更好的。基本原理已经OK了，只剩写代码。但是我们还需要表示一个右结合的语法，我们用 . 来表示，假设数字为f，g和h：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="attribute">f</span>     .    g     .    h</span><br><span class="line"><span class="attribute">0</span>   <span class="number">8</span>.<span class="number">5</span>    <span class="number">8</span>   <span class="number">8</span>.<span class="number">5</span>    <span class="number">8</span>   <span class="number">0</span></span><br></pre></td></tr></table></figure><p>它会被解析为：f . (g . h)</p><h2 id="最简Pratt解析器">最简Pratt解析器</h2><p>我们传入解析器的参数是单字符的数字和变量，并用标点符号作为运算符，实例如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Token</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Atom</span>(<span class="type">char</span>),</span><br><span class="line">    <span class="title function_ invoke__">Op</span>(<span class="type">char</span>),</span><br><span class="line">    Eof,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Lexer</span> &#123;</span><br><span class="line">    tokens: <span class="type">Vec</span>&lt;Token&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Lexer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Lexer &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tokens</span> = input</span><br><span class="line">            .<span class="title function_ invoke__">chars</span>()</span><br><span class="line">            .<span class="title function_ invoke__">filter</span>(|it| !it.<span class="title function_ invoke__">is_ascii_whitespace</span>())</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|c| <span class="keyword">match</span> c &#123;</span><br><span class="line">                <span class="string">&#x27;0&#x27;</span>..=<span class="string">&#x27;9&#x27;</span> |</span><br><span class="line">                <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> | <span class="string">&#x27;A&#x27;</span>..=<span class="string">&#x27;Z&#x27;</span> =&gt; Token::<span class="title function_ invoke__">Atom</span>(c),</span><br><span class="line">                _ =&gt; Token::<span class="title function_ invoke__">Op</span>(c),</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">        tokens.<span class="title function_ invoke__">reverse</span>();</span><br><span class="line">        Lexer &#123; tokens &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Token &#123;</span><br><span class="line">        <span class="keyword">self</span>.tokens.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap_or</span>(Token::Eof)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">peek</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Token &#123;</span><br><span class="line">        <span class="keyword">self</span>.tokens.<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(Token::Eof)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了可以正确识别绑定能力，需要先将中缀表达式变为前缀表达式：</p><p><code>1 + 2 * 3 == (+ 1 (* 2 3))</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Atom</span>(<span class="type">char</span>),</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">char</span>, <span class="type">Vec</span>&lt;S&gt;),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            S::<span class="title function_ invoke__">Atom</span>(i) =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;&quot;</span>, i),</span><br><span class="line">            S::<span class="title function_ invoke__">Cons</span>(head, rest) =&gt; &#123;</span><br><span class="line">                <span class="built_in">write!</span>(f, <span class="string">&quot;(&#123;&#125;&quot;</span>, head)?;</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> rest &#123;</span><br><span class="line">                    <span class="built_in">write!</span>(f, <span class="string">&quot; &#123;&#125;&quot;</span>, s)?</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">write!</span>(f, <span class="string">&quot;)&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们从+和*开始：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr</span>(input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lexer</span> = Lexer::<span class="title function_ invoke__">new</span>(input);</span><br><span class="line">    <span class="title function_ invoke__">expr_bp</span>(&amp;<span class="keyword">mut</span> lexer)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    todo!()</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">tests</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;1 + 2 * 3&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(+ 1 (* 2 3))&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，实际就是使用我们处理左递归的方法——解析数字，循环，然后consum操作符，然后做其它的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">tests</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;1&quot;</span>); </span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已经可以正常执行了</p><p>我们添加上运算符的左右绑定能力，由于两侧都是0，所以运算符的至少为1，对于不同结合性的，可以在对应边+1</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> (l_bp, r_bp) = <span class="title function_ invoke__">infix_binding_power</span>(op);</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">infix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> (<span class="type">u8</span>, <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在是最棘手的地方，引入递归，假设下面这个例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span>   +   b   *   c   *   d   +   e</span><br><span class="line">  <span class="attribute">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">1</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这里，开始执行时，将a放入lhs，然后呢？很明显不能直接将b和a组合，那是b*c吗？也不是，应该是b*c*d，一共应该分为三个部分：A+B+C，这是因为+的结合性更低，所以，我们引入递归：从b开始，找到比b左边结合性还低的结合性即可，在这里就是e，因此要向main函数添加min_bp参数。bp就是bind power</p><p>最后，就是这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr</span>(input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lexer</span> = Lexer::<span class="title function_ invoke__">new</span>(input);</span><br><span class="line">    <span class="title function_ invoke__">expr_bp</span>(&amp;<span class="keyword">mut</span> lexer, <span class="number">0</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer, min_bp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> S &#123; </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> (l_bp, r_bp) = <span class="title function_ invoke__">infix_binding_power</span>(op);</span><br><span class="line">        <span class="keyword">if</span> l_bp &lt; min_bp &#123; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lexer.<span class="title function_ invoke__">next</span>(); </span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">        lhs = S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs]); </span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">infix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> (<span class="type">u8</span>, <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">tests</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;1 + 2 * 3&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(+ 1 (* 2 3))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;a + b * c * d + e&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(+ (+ a (* (* b c) d)) e)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第5行：min_bp十分重要，expr_bp在它的控制下可以解析比它绑定能力大的所有表达式，当看到比它小的表达式时，就会停止。</li><li>第17行：停止条件</li><li>第20行：这里我们跳过操作符本身，进行递归调用。我们使用l_bp来检测min_bp，r_bp作为递归调用的新min_bp。因此min_bp可以视为当前表达式左侧操作符的绑定能力。</li><li>第22行：解析完右侧的表达式后，组合成当前表达式</li><li>第3行：开始时，使用0的绑定能力，0表示没有运算符</li></ul><p>上面的40行代码就是Pratt核心的解析算法。如果你能理解它，那么其它的内容就是单纯的加法罢了。</p><h2 id="额外内容">额外内容</h2><p>好了，我们现在可以添加一些奇怪的表达式来展示Pratt算法的强大。首先添加一个高优先的，右结合的成员函数调用运算符 . ：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">infix_binding_power</span><span class="params">(op: <span class="keyword">char</span>)</span> -&gt; <span class="params">(u8, u8)</span> </span>&#123;</span><br><span class="line">    match op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        <span class="string">&#x27;.&#x27;</span> =&gt; (<span class="number">6</span>, <span class="number">5</span>),</span><br><span class="line">        _ =&gt; panic!(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很不错：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s = expr(<span class="string">&quot;f . g . h&quot;</span>)<span class="comment">;</span></span><br><span class="line">assert_eq!(<span class="name">s</span>.to_string(), <span class="string">&quot;(. f (. g h))&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let s = expr(<span class="string">&quot; 1 + 2 + f . g . h * 3 * 4&quot;</span>)<span class="comment">;</span></span><br><span class="line">assert_eq!(<span class="name">s</span>.to_string(), <span class="string">&quot;(+ (+ 1 2) (* (* (. f (. g h)) 3) 4))&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>好的，现在添加负号，也就是一元 - ，它比比特运算符绑定更强，但是比二元的绑定弱，同时如果它是第一个出现的token，那上面的代码就需要修改为先处理一元运算符的版本。由于一元运算符只和右边结合所以只有右结合性。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">prefix_binding_power</span><span class="params">(op: <span class="keyword">char</span>)</span> -&gt; <span class="params">(<span class="params">()</span>, u8)</span> </span>&#123; </span><br><span class="line">    match op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; ((), <span class="number">5</span>),</span><br><span class="line">        _ =&gt; panic!(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">infix_binding_power</span><span class="params">(op: <span class="keyword">char</span>)</span> -&gt; <span class="params">(u8, u8)</span> </span>&#123;</span><br><span class="line">    match op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        <span class="string">&#x27;.&#x27;</span> =&gt; (<span class="number">8</span>, <span class="number">7</span>), </span><br><span class="line">        _ =&gt; panic!(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第1行：使用()表明这是一个前缀运算符而不是后缀或中缀，所以只能把其它东西放在这个符号后。</li><li>第11行：由于我们要在.和*中添加一元减，所以需要修正.的优先级，一般来说，如果运算符是二元的，设置它的优先级为一个奇数，并用这个数+1表示它的结合性。对于一元减来说，则都可以，但是最好设置一个原则。</li></ul><p>加到expr_bp之后，得到：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer, min_bp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(op) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> ((), r_bp) = <span class="title function_ invoke__">prefix_binding_power</span>(op);</span><br><span class="line">            todo!()</span><br><span class="line">        &#125;</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，我们现在有r_bp了，还没有l_bp，所以直接复制main的一段代码修改出来吧？记住，r_bp是用来递归的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer, min_bp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(op) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> ((), r_bp) = <span class="title function_ invoke__">prefix_binding_power</span>(op);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">            S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[rhs])</span><br><span class="line">        &#125;</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> (l_bp, r_bp) = <span class="title function_ invoke__">infix_binding_power</span>(op);</span><br><span class="line">        <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">        lhs = S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs]);</span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">tests</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;--1 * 2&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(* (- (- 1)) 2)&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;--f . g&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(- (- (. f g)))&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有趣，它直接生效了，你可以想一下为什么会这样。因为操作数被绑定程度更高的运算符结合了，而这里正好有一个解析指定绑定能力更高的表达式的函数。</p><p>OK，((), u8) 可以解决前缀式，那后缀式可以用(u8, ()) 来解决吗？现在加个阶乘：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> (l_bp, ()) = postfix_binding_power(<span class="built_in">op</span>);</span><br><span class="line"><span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> (l_bp, r_bp) = infix_binding_power(<span class="built_in">op</span>);</span><br><span class="line"><span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>e，不对，解析前缀表达式时，我们能看到后缀或中缀运算符。但是传递没有识别到的运算符时，就不能正常运行了。所以，让postfix_binding_power 返回一个指明是不是后缀的选项：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer, min_bp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(op) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> ((), r_bp) = <span class="title function_ invoke__">prefix_binding_power</span>(op);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">            S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[rhs])</span><br><span class="line">        &#125;</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((l_bp, ())) = <span class="title function_ invoke__">postfix_binding_power</span>(op) &#123;</span><br><span class="line">            <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">            lhs = S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> (l_bp, r_bp) = <span class="title function_ invoke__">infix_binding_power</span>(op);</span><br><span class="line">        <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">        lhs = S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs]);</span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">prefix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> ((), <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; ((), <span class="number">5</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">postfix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">u8</span>, ())&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;!&#x27;</span> =&gt; (<span class="number">7</span>, ()),</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">infix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> (<span class="type">u8</span>, <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        <span class="string">&#x27;.&#x27;</span> =&gt; (<span class="number">10</span>, <span class="number">9</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">tests</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;-9!&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(- (! 9))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;f . g !&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(! (. f g))&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太好了，这样就都通过了。</p><p>现在，我们需要添加括号。这很简单，我们本可以在一开始做，但是这里再处理更有意义。括号表达式只是一个基础表达式，它的处理方式类似于基本的数字标识符等组成的原子表达式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">    Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">    Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;(&#x27;</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">lhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(lexer.<span class="title function_ invoke__">next</span>(), Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;)&#x27;</span>));</span><br><span class="line">        lhs</span><br><span class="line">    &#125;</span><br><span class="line">    Token::<span class="title function_ invoke__">Op</span>(op) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> ((), r_bp) = <span class="title function_ invoke__">prefix_binding_power</span>(op);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">        S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[rhs])</span><br><span class="line">    &#125;</span><br><span class="line">    t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可惜，失败了：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s = expr(<span class="string">&quot;(((0)))&quot;</span>)<span class="comment">;</span></span><br><span class="line">assert_eq!(<span class="name">s</span>.to_string(), <span class="string">&quot;0&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>报错来自于下面的循环，我们的终止条件是达到eof，而不是)，所以解决方法是在遇到未知的标识符是返回None</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer, min_bp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;(&#x27;</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">lhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(lexer.<span class="title function_ invoke__">next</span>(), Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;)&#x27;</span>));</span><br><span class="line">            lhs</span><br><span class="line">        &#125;</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(op) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> ((), r_bp) = <span class="title function_ invoke__">prefix_binding_power</span>(op);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">            S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[rhs])</span><br><span class="line">        &#125;</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((l_bp, ())) = <span class="title function_ invoke__">postfix_binding_power</span>(op) &#123;</span><br><span class="line">            <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">            lhs = S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((l_bp, r_bp)) = <span class="title function_ invoke__">infix_binding_power</span>(op) &#123;</span><br><span class="line">            <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">            lhs = S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">prefix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> ((), <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; ((), <span class="number">5</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">postfix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">u8</span>, ())&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;!&#x27;</span> =&gt; (<span class="number">7</span>, ()),</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">infix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">u8</span>, <span class="type">u8</span>)&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        <span class="string">&#x27;.&#x27;</span> =&gt; (<span class="number">10</span>, <span class="number">9</span>),</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后继续，我们来添加数组索引操作符：a[i]。它属于什么缀呢？环绕型？如果只有a[]那就是后缀，如果是[i]，则可以像括号一样。我们可以发现i并没有参与优先级的计算，所以可以这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer, min_bp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;(&#x27;</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">lhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(lexer.<span class="title function_ invoke__">next</span>(), Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;)&#x27;</span>));</span><br><span class="line">            lhs</span><br><span class="line">        &#125;</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(op) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> ((), r_bp) = <span class="title function_ invoke__">prefix_binding_power</span>(op);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">            S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[rhs])</span><br><span class="line">        &#125;</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((l_bp, ())) = <span class="title function_ invoke__">postfix_binding_power</span>(op) &#123;</span><br><span class="line">            <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">            lhs = <span class="keyword">if</span> op == <span class="string">&#x27;[&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">assert_eq!</span>(lexer.<span class="title function_ invoke__">next</span>(), Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;]&#x27;</span>));</span><br><span class="line">                S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs])</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((l_bp, r_bp)) = <span class="title function_ invoke__">infix_binding_power</span>(op) &#123;</span><br><span class="line">            <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">            lhs = S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">prefix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> ((), <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; ((), <span class="number">5</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">postfix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">u8</span>, ())&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;!&#x27;</span> | <span class="string">&#x27;[&#x27;</span> =&gt; (<span class="number">7</span>, ()), </span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">infix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">u8</span>, <span class="type">u8</span>)&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        <span class="string">&#x27;.&#x27;</span> =&gt; (<span class="number">10</span>, <span class="number">9</span>),</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">tests</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;x[0][1]&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;([ ([ x 0) 1)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第57行：我们这里把!和[用作相同优先级。一般来说，优先级是不能相等的，否则可能的候选项就有2个或以上。而这里，我们比较的是右绑定能力和左绑定能力，而它们都只是右结合，不会出现多种可能，所以可以这样用。</li></ul><p>最后的boss是这个，三元表达式：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c ? e1 : <span class="type">e2</span></span><br></pre></td></tr></table></figure><p>如果这样就很好看了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c <span class="selector-attr">[ e1 ]</span> e2</span><br></pre></td></tr></table></figure><p>这和a[i]差不多，所以把它当作奇怪的括号也未尝不可。既然如此，直接用我们之前解决括号的方法来解决它。那结合性和优先级呢？</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a ? b : <span class="type">c</span> ? d : <span class="type">e</span></span><br></pre></td></tr></table></figure><p>就像刚刚说的，尝试把b和d看作括号的内容，而它不参与优先级的考虑：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="string">?:</span> c <span class="string">?:</span> e</span><br></pre></td></tr></table></figure><p>最后就变成这样：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a <span class="string">?:</span> c) <span class="string">?:</span> e</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="string">?:</span> (c <span class="string">?:</span> e)</span><br></pre></td></tr></table></figure><p>哪一个更有用呢？？链像这样：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a ? b :</span><br><span class="line"><span class="type">c</span> ? d :</span><br><span class="line"><span class="type">e</span></span><br></pre></td></tr></table></figure><p>右结合的方式更有用，就优先级而言，三元运算符优先级较低。C语言中，只有=和，的优先级比它低。那么，也添加一个=吧。</p><p>现在，得到了最后的版本：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;fmt, io::BufRead&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Atom</span>(<span class="type">char</span>),</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">char</span>, <span class="type">Vec</span>&lt;S&gt;),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            S::<span class="title function_ invoke__">Atom</span>(i) =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;&quot;</span>, i),</span><br><span class="line">            S::<span class="title function_ invoke__">Cons</span>(head, rest) =&gt; &#123;</span><br><span class="line">                <span class="built_in">write!</span>(f, <span class="string">&quot;(&#123;&#125;&quot;</span>, head)?;</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> rest &#123;</span><br><span class="line">                    <span class="built_in">write!</span>(f, <span class="string">&quot; &#123;&#125;&quot;</span>, s)?</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">write!</span>(f, <span class="string">&quot;)&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Token</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Atom</span>(<span class="type">char</span>),</span><br><span class="line">    <span class="title function_ invoke__">Op</span>(<span class="type">char</span>),</span><br><span class="line">    Eof,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Lexer</span> &#123;</span><br><span class="line">    tokens: <span class="type">Vec</span>&lt;Token&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Lexer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Lexer &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tokens</span> = input</span><br><span class="line">            .<span class="title function_ invoke__">chars</span>()</span><br><span class="line">            .<span class="title function_ invoke__">filter</span>(|it| !it.<span class="title function_ invoke__">is_ascii_whitespace</span>())</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|c| <span class="keyword">match</span> c &#123;</span><br><span class="line">                <span class="string">&#x27;0&#x27;</span>..=<span class="string">&#x27;9&#x27;</span></span><br><span class="line">                | <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> | <span class="string">&#x27;A&#x27;</span>..=<span class="string">&#x27;Z&#x27;</span> =&gt; Token::<span class="title function_ invoke__">Atom</span>(c),</span><br><span class="line">                _ =&gt; Token::<span class="title function_ invoke__">Op</span>(c),</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">        tokens.<span class="title function_ invoke__">reverse</span>();</span><br><span class="line">        Lexer &#123; tokens &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Token &#123;</span><br><span class="line">        <span class="keyword">self</span>.tokens.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap_or</span>(Token::Eof)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">peek</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Token &#123;</span><br><span class="line">        <span class="keyword">self</span>.tokens.<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(Token::Eof)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expr</span>(input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lexer</span> = Lexer::<span class="title function_ invoke__">new</span>(input);</span><br><span class="line">    <span class="title function_ invoke__">expr_bp</span>(&amp;<span class="keyword">mut</span> lexer, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expr_bp</span>(lexer: &amp;<span class="keyword">mut</span> Lexer, min_bp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lhs</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Atom</span>(it) =&gt; S::<span class="title function_ invoke__">Atom</span>(it),</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;(&#x27;</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">lhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(lexer.<span class="title function_ invoke__">next</span>(), Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;)&#x27;</span>));</span><br><span class="line">            lhs</span><br><span class="line">        &#125;</span><br><span class="line">        Token::<span class="title function_ invoke__">Op</span>(op) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> ((), r_bp) = <span class="title function_ invoke__">prefix_binding_power</span>(op);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">            S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[rhs])</span><br><span class="line">        &#125;</span><br><span class="line">        t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">op</span> = <span class="keyword">match</span> lexer.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            Token::Eof =&gt; <span class="keyword">break</span>,</span><br><span class="line">            Token::<span class="title function_ invoke__">Op</span>(op) =&gt; op,</span><br><span class="line">            t =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad token: &#123;:?&#125;&quot;</span>, t),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((l_bp, ())) = <span class="title function_ invoke__">postfix_binding_power</span>(op) &#123;</span><br><span class="line">            <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">            lhs = <span class="keyword">if</span> op == <span class="string">&#x27;[&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">assert_eq!</span>(lexer.<span class="title function_ invoke__">next</span>(), Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;]&#x27;</span>));</span><br><span class="line">                S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs])</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((l_bp, r_bp)) = <span class="title function_ invoke__">infix_binding_power</span>(op) &#123;</span><br><span class="line">            <span class="keyword">if</span> l_bp &lt; min_bp &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lexer.<span class="title function_ invoke__">next</span>();</span><br><span class="line">            lhs = <span class="keyword">if</span> op == <span class="string">&#x27;?&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">mhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">assert_eq!</span>(lexer.<span class="title function_ invoke__">next</span>(), Token::<span class="title function_ invoke__">Op</span>(<span class="string">&#x27;:&#x27;</span>));</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">                S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, mhs, rhs])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">rhs</span> = <span class="title function_ invoke__">expr_bp</span>(lexer, r_bp);</span><br><span class="line">                S::<span class="title function_ invoke__">Cons</span>(op, <span class="built_in">vec!</span>[lhs, rhs])</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lhs</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">prefix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> ((), <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; ((), <span class="number">9</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;bad op: &#123;:?&#125;&quot;</span>, op),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">postfix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">u8</span>, ())&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;!&#x27;</span> =&gt; (<span class="number">11</span>, ()),</span><br><span class="line">        <span class="string">&#x27;[&#x27;</span> =&gt; (<span class="number">11</span>, ()),</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">infix_binding_power</span>(op: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">u8</span>, <span class="type">u8</span>)&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> op &#123;</span><br><span class="line">        <span class="string">&#x27;=&#x27;</span> =&gt; (<span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="string">&#x27;?&#x27;</span> =&gt; (<span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> =&gt; (<span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> =&gt; (<span class="number">7</span>, <span class="number">8</span>),</span><br><span class="line">        <span class="string">&#x27;.&#x27;</span> =&gt; (<span class="number">14</span>, <span class="number">13</span>),</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">tests</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;1 + 2 * 3&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(+ 1 (* 2 3))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;a + b * c * d + e&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(+ (+ a (* (* b c) d)) e)&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;f . g . h&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(. f (. g h))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot; 1 + 2 + f . g . h * 3 * 4&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        s.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        <span class="string">&quot;(+ (+ 1 2) (* (* (. f (. g h)) 3) 4))&quot;</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;--1 * 2&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(* (- (- 1)) 2)&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;--f . g&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(- (- (. f g)))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;-9!&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(- (! 9))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;f . g !&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(! (. f g))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;(((0)))&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;x[0][1]&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;([ ([ x 0) 1)&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(</span><br><span class="line">        <span class="string">&quot;a ? b :</span></span><br><span class="line"><span class="string">         c ? d</span></span><br><span class="line"><span class="string">         : e&quot;</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(? a b (? c d e))&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(<span class="string">&quot;a = 0 ? b : c = d&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;(= a (= (? 0 b c) d))&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> std::io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">line</span> = line.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">expr</span>(&amp;line);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码也可以在<a href="https://github.com/matklad/minipratt">这个仓库</a>中找到。</p><p>Eof :-)</p>]]></content>
    
    
    <summary type="html">非原创，翻译</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="数据结构与算法" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Pratt" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/Pratt/"/>
    
    
    <category term="算法" scheme="https://www.pri87.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="解析" scheme="https://www.pri87.vip/tags/%E8%A7%A3%E6%9E%90/"/>
    
    <category term="字符串" scheme="https://www.pri87.vip/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="递归" scheme="https://www.pri87.vip/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>病毒分析基本流程</title>
    <link href="https://www.pri87.vip/posts/8d9e4631.html"/>
    <id>https://www.pri87.vip/posts/8d9e4631.html</id>
    <published>2025-04-17T13:18:49.000Z</published>
    <updated>2025-04-17T14:02:47.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预分析">预分析</h2><p>这个阶段主要在于收集样本信息。</p><h3 id="静态分析">静态分析</h3><p>分析样本是由什么语言编译的，分析出对应的调用约定，有无现成的符号表，签名文件等，为后续分析减少困难。</p><p>如果有壳，要知道是什么壳，一般病毒的壳都是强壳，我还不会分析。</p><p>分析导入表，如果壳隐藏了，只有后续看。大致看出有没有干文件操作，有没有干网络操作，有没有干驻留操作（注册表和服务）。判断出病毒类型。之后在对应的逻辑中仔细分析。</p><h3 id="动态分析">动态分析</h3><p>在线沙箱中检测/虚拟机中检测。沙箱可以直接分析，如果是自己的虚拟机，则需要打开一个可以检测进程的(ARK)工具，获取样本的所有操作，尤其是：是否有文件创建和写入？网络连接的ip是多少？网络中读取的内容是什么？注册了哪些服务和注册表？Hook了哪些模块，用了哪些API等等。</p><h2 id="分析">分析</h2><p>打开程序，根据预分析的内容定位关键位置然后具体分析。</p><p>跟CTF的逆向题差不多。</p>]]></content>
    
    
    <summary type="html">基本的病毒分析流程总结</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ida基本使用操作</title>
    <link href="https://www.pri87.vip/posts/dc1142ef.html"/>
    <id>https://www.pri87.vip/posts/dc1142ef.html</id>
    <published>2025-04-12T07:07:46.000Z</published>
    <updated>2025-04-15T01:49:28.487Z</updated>
    
    <content type="html"><![CDATA[<ul><li></li></ul><h2 id="自定义调用约定">自定义调用约定</h2><p>ida支持用户显式指定参数和返回值所使用的寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall func@&lt;ebx&gt;(<span class="type">int</span> x, <span class="type">int</span> y@&lt;esi&gt;);</span><br></pre></td></tr></table></figure><p>这表明x用堆栈传递，y用esi传递，返回值用ebx传递</p><p>返回值必须位于寄存器中<br>如果返回值类型是void，不能指定返回值的位置<br>如果参数的位置没有指定，假设参数通过堆栈传递<br>可以允许嵌套声明，如: int **__usercall func16@&lt;eax&gt;(int *(__usercall *x)@&lt;ebx&gt; (int, long@&lt;ecx&gt;, int)@&lt;esi&gt;);<br>用于指定位置名的寄存器必须在当前处理器中有效<br>寄存器对可以像这样 &lt;edx:eax&gt; 用冒号的形式指定</p><p>__usercall 调用者清理堆栈</p><p>__userpurge 被调用者清理堆栈</p><p>__spoils指定函数破坏的寄存器列表，比如int __spoils&lt;eax, bh&gt; func(int x);</p><h2 id="汇编下寄存器命名指定范围">汇编下寄存器命名指定范围</h2><p>很多时候一个寄存器在同个函数中作用不同，按n后，可以在start address和end addres中指定寄存器在某个范围中的名字从而更方便地重命名</p>]]></content>
    
    
    <summary type="html">本篇介绍部分基本ida使用操作</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>自动化代码混淆</title>
    <link href="https://www.pri87.vip/posts/e00631f.html"/>
    <id>https://www.pri87.vip/posts/e00631f.html</id>
    <published>2025-04-08T01:34:00.000Z</published>
    <updated>2025-04-08T01:59:09.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近在写shellcode。发现shellcode生成的代码十分简单，也没有绝对跳转或者之类的需要重定位的东西，所以我感觉用这个来练手自动化加花还是很不错的</p><h2 id="使用的库">使用的库</h2><p>Zydis和keystone</p><p>前者作为反汇编工具，后者作为从字符串生成机器码的工具。</p><h2 id="原理">原理</h2><p>通过Zydis对代码进行解析，装入一个list中，然后执行混淆，这里我干了两个事：</p><ol><li>判断是否有直接字符串数据压栈，有的话加密原内容，然后解密再压栈</li><li>打乱整个代码结构</li></ol><p>1的话，通过Zydis生成字符串来检测，keystone生成机器码然后创建对应代码插入/修改list即可</p><p>2的话，通过分块每个块最后加jmp然后交换块的位置即可，但是好像cpp原生的list交换会导致一些bug，所以我准备之后重新写一下</p><h2 id="实现">实现</h2><p>见github</p>]]></content>
    
    
    <summary type="html">本篇是进行代码混淆的练习</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向，自动化逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91%EF%BC%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E9%80%86%E5%90%91/"/>
    
    
    <category term="代码混淆" scheme="https://www.pri87.vip/tags/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    
  </entry>
  
  <entry>
    <title>X86-64汇编机器码格式</title>
    <link href="https://www.pri87.vip/posts/47eb1508.html"/>
    <id>https://www.pri87.vip/posts/47eb1508.html</id>
    <published>2025-03-31T07:29:42.000Z</published>
    <updated>2025-04-01T01:14:01.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本结构">基本结构</h2><p><img src="https://s2.loli.net/2025/03/31/vEYwI5kGshboazd.png" alt="image-20250331153157959"></p><p><img src="https://s2.loli.net/2025/03/31/r9fHQj3BgMu1mDL.png" alt="image-20250331155123077"></p><p>该图说明：主操作码一定有，由于其它内容不一定在一条指令中，所以指令长度不固定</p><h3 id="符号说明">符号说明</h3><p>G：寄存器<br>E：寄存器/内存<br>b：单字节<br>v：根据操作系统判断位数，一般数默认32位，地址默认64位</p><p>MOV Gv Ev：意思是把一个内存或寄存器的值放到一个寄存器中，大小根据操作系统决定</p><p>现在依次介绍这几个</p><h2 id="指令前缀（Instruction-Prefixes）">指令前缀（Instruction Prefixes）</h2><p>前缀分为 4 类，使用时，不区分前后顺序，且每组最多出现一个：</p><p>1.锁定和重复前缀</p><table><thead><tr><th>前缀</th><th>效果</th></tr></thead><tbody><tr><td>F0</td><td>使操作变为原子操作</td></tr><tr><td>F2</td><td>REPNE/REPNZ，重复前缀，用于串和 IO</td></tr><tr><td>F3</td><td>REP 或 REPE/REPZ，用于串和 IO</td></tr></tbody></table><p>2.段重载</p><table><thead><tr><th>前缀</th><th>效果</th></tr></thead><tbody><tr><td>2E</td><td>CS 段重载</td></tr><tr><td>36</td><td>SS 段重载</td></tr><tr><td>3E</td><td>DS 段重载</td></tr><tr><td>26</td><td>ES 段重载</td></tr><tr><td>64</td><td>FS 段重载</td></tr><tr><td>65</td><td>GS 段重载</td></tr><tr><td>2E</td><td>分支一般不跳转，用于提示 CPU 进行预测</td></tr><tr><td>3E</td><td>分支一般跳转，用于提示 CPU 进行预测</td></tr></tbody></table><p>3.操作数大小重载</p><table><thead><tr><th>前缀</th><th>效果</th></tr></thead><tbody><tr><td>66</td><td>将默认操作数大小从 32 位转为 16 位</td></tr></tbody></table><p>4.操作地址大小重载</p><table><thead><tr><th>前缀</th><th>效果</th></tr></thead><tbody><tr><td>67</td><td>将默认的 64 位地址大小转为 32 位</td></tr></tbody></table><h2 id="REX-前缀">REX 前缀</h2><p>REX 用来扩展指令从 32 位到 64 位，这一部分的内容需要先看后面的几个部分才能看懂</p><p>占一字节，可以没有</p><p><img src="https://s2.loli.net/2025/03/31/uBJv1dEkf8NXGpD.png" alt="image-20250331160405462"></p><p>将对应域置 1 就可以使目标扩展</p><p>其中经常使用的就是 48，让操作数变为 64 位大小</p><h2 id="操作码">操作码</h2><p>一般来说，主操作码长度为 1 到 3 字节，ModR/M 可能编码附加的 3 位操作码</p><p>双字节：0F+第二个操作码字节 或 一个前缀(66H, F2H, 或 F3H)+0F+第二个操作码字节<br>三字节：0F+后两个操作码字节 或 一个前缀(66H, F2H, 或 F3H)+0F+后两个操作码字节</p><p>部分内容需要先看后面的</p><p>下面为 1 到 3 字节指令的查表</p><p><img src="https://s2.loli.net/2025/03/31/JqnVpF7uomvaj4L.png" alt="image-20250331161314311"></p><p><img src="https://s2.loli.net/2025/03/31/LFVOx9YB4whqlIG.png" alt="image-20250331161329868"></p><p><img src="https://s2.loli.net/2025/03/31/y35PrtfsOdVNcZi.png" alt="image-20250331161339920"></p><p><img src="https://s2.loli.net/2025/03/31/MRiwKW1ZmSj83GQ.png" alt="image-20250331161350193"></p><p><img src="https://s2.loli.net/2025/03/31/hTMljvS2V6nPRXW.png" alt="image-20250331161359418"></p><p><img src="https://s2.loli.net/2025/03/31/rogQINylSKYHLJ3.png" alt="image-20250331161408747"></p><p><img src="https://s2.loli.net/2025/03/31/Ax95rqsP4VI3fNc.png" alt="image-20250331161419001"></p><p><img src="https://s2.loli.net/2025/03/31/LhElcWowv7MtYCi.png" alt="image-20250331161429738"></p><p><img src="https://s2.loli.net/2025/03/31/dDWFZ32bXHqLgQr.png" alt="image-20250331161439214"></p><p><img src="https://s2.loli.net/2025/03/31/sOSoX6rl5MiTzPf.png" alt="image-20250331161448469"></p><blockquote><p>以上截取自 IA32 手册 2024-12 版的 2929 页至 2938 页</p></blockquote><p>除了上面的查表方式，x86-64 指令还有另一种方式：通过组来查询，这种方式使用了一张新表，叫做单双字节操作码的操作码扩展</p><p>先附表</p><p><img src="https://s2.loli.net/2025/03/31/v3guPoV9xBY4HcI.png" alt="image-20250331163515951"></p><p><img src="https://s2.loli.net/2025/03/31/PflMsu9DHAa65Sg.png" alt="image-20250331163526702"></p><p><img src="https://s2.loli.net/2025/03/31/AWFud91GmSMNsYQ.png" alt="image-20250331165953065"></p><p><img src="https://s2.loli.net/2025/03/31/QaphGj7wUt8bKYs.png" alt="image-20250331170007852"></p><p><img src="https://s2.loli.net/2025/03/31/qKaURr7v9ew54cm.png" alt="image-20250331170031403"></p><p><img src="https://s2.loli.net/2025/03/31/ijDMHZgbCTVLUoQ.png" alt="image-20250331170044132"></p><p><img src="https://s2.loli.net/2025/03/31/glzF7n1DKhGYrE5.png" alt="image-20250331170056390"></p><p><img src="https://s2.loli.net/2025/03/31/tmDh75EdeKa93TC.png" alt="image-20250331170105301"></p><p><img src="https://s2.loli.net/2025/03/31/8ygvpfUW5sFHcMC.png" alt="image-20250331170116327"></p><p><img src="https://s2.loli.net/2025/03/31/9lIOjfepRrqGBLm.png" alt="image-20250331170126623"></p><p><img src="https://s2.loli.net/2025/03/31/2vhJ5iNDqRBG8bK.png" alt="image-20250331170135362"></p><p><img src="https://s2.loli.net/2025/03/31/STFlRIhLdAKUjnQ.png" alt="image-20250331170145112"></p><p><img src="https://s2.loli.net/2025/03/31/Mb8p9NrtxkF6imv.png" alt="image-20250331170154414"></p><p><img src="https://s2.loli.net/2025/03/31/2xaMiUDeQIPEln6.png" alt="image-20250331170205007"></p><p><img src="https://s2.loli.net/2025/03/31/2ICDLpAyMuXohHZ.png" alt="image-20250331170213809"></p><p><img src="https://s2.loli.net/2025/03/31/zChIJxtd6SDjqVQ.png" alt="image-20250331170226577"></p><p><img src="https://s2.loli.net/2025/03/31/ws6iqjJzf127Ktm.png" alt="image-20250331170241767"></p><p><img src="https://s2.loli.net/2025/03/31/v8ltPzSd52j1CxF.png" alt="image-20250331170254243"></p><blockquote><p>这里是 2940 到 2950</p></blockquote><p>考虑 80 C0 05</p><p>80 在表 A-6 中是 Group 1，然后看 ModR/M 字段的 5，4，3 位<br>C0:11000000，5，4，3 位为 000，即 0，查纵列得 ADD，根据之后的内容可以知道 ModR/M 指定了对应的内存和寄存器，所以得到 add al,5，这和第一种直接查表得到的 0405 的指令相同</p><h2 id="ModR-M">ModR/M</h2><p>如果一个操作码涉及内存，后面一般就会有一个寻址格式说明字节即 ModR/M，而如果 ModR/M 中提到了需要内存寻址，那么就需要 SIB 字节去进一步解释</p><p>ModR/M和SIB各涉及三个域：<br><img src="https://s2.loli.net/2025/03/31/RadXi6T4VHcKSOJ.png" alt="image-20250331171513102"></p><p><img src="https://s2.loli.net/2025/03/31/ZY7RDy4MJorbdUv.png" alt="image-20250331172923245"></p><h3 id="Mod寻址模式">Mod寻址模式</h3><p>指明操作码中的E是寄存器还是内存，11是内存，其它都是寄存器</p><table><thead><tr><th>Mod值</th><th>描述</th><th>偏移量</th></tr></thead><tbody><tr><td>00</td><td>内存，无偏移量(除非 R/M=101)</td><td>无或32</td></tr><tr><td>01</td><td>内存，有8位偏移</td><td>[base+8位偏移]</td></tr><tr><td>10</td><td>内存，有32位偏移</td><td>[base+32 位偏移]</td></tr><tr><td>11</td><td>寄存器操作数</td><td>寄存器</td></tr></tbody></table><p>前三个为内存，后一个为数</p><h3 id="Reg-Opcode寄存器或操作码扩展">Reg/Opcode寄存器或操作码扩展</h3><p>指定使用的reg或opcode扩展：</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">32 位寄存器</th><th style="text-align:left">16 位寄存器</th><th style="text-align:left">8 位寄存器</th><th style="text-align:left">用途 (操作码扩展)</th></tr></thead><tbody><tr><td style="text-align:left">000</td><td style="text-align:left">EAX</td><td style="text-align:left">AX</td><td style="text-align:left">AL</td><td style="text-align:left">ADD</td></tr><tr><td style="text-align:left">001</td><td style="text-align:left">ECX</td><td style="text-align:left">CX</td><td style="text-align:left">CL</td><td style="text-align:left">OR</td></tr><tr><td style="text-align:left">010</td><td style="text-align:left">EDX</td><td style="text-align:left">DX</td><td style="text-align:left">DL</td><td style="text-align:left">ADC</td></tr><tr><td style="text-align:left">011</td><td style="text-align:left">EBX</td><td style="text-align:left">BX</td><td style="text-align:left">BL</td><td style="text-align:left">SBB</td></tr><tr><td style="text-align:left">100</td><td style="text-align:left">ESP</td><td style="text-align:left">SP</td><td style="text-align:left">AH</td><td style="text-align:left">AND</td></tr><tr><td style="text-align:left">101</td><td style="text-align:left">EBP</td><td style="text-align:left">BP</td><td style="text-align:left">CH</td><td style="text-align:left">SUB</td></tr><tr><td style="text-align:left">110</td><td style="text-align:left">ESI</td><td style="text-align:left">SI</td><td style="text-align:left">DH</td><td style="text-align:left">XOR</td></tr><tr><td style="text-align:left">111</td><td style="text-align:left">EDI</td><td style="text-align:left">DI</td><td style="text-align:left">BH</td><td style="text-align:left">CMP</td></tr></tbody></table><h3 id="R-M寄存器或内存">R/M寄存器或内存</h3><table><thead><tr><th style="text-align:left">R/M 值</th><th style="text-align:left">Mod = 11（寄存器）</th><th style="text-align:left">Mod ≠ 11（内存基址/索引）</th></tr></thead><tbody><tr><td style="text-align:left">000</td><td style="text-align:left">EAX</td><td style="text-align:left">[RAX]</td></tr><tr><td style="text-align:left">001</td><td style="text-align:left">ECX</td><td style="text-align:left">[RCX]</td></tr><tr><td style="text-align:left">010</td><td style="text-align:left">EDX</td><td style="text-align:left">[RDX]</td></tr><tr><td style="text-align:left">011</td><td style="text-align:left">EBX</td><td style="text-align:left">[RBX]</td></tr><tr><td style="text-align:left">100</td><td style="text-align:left">ESP</td><td style="text-align:left">[SIB]（需要 SIB 字节）</td></tr><tr><td style="text-align:left">101</td><td style="text-align:left">EBP</td><td style="text-align:left">[RBP] 或无偏移/disp32</td></tr><tr><td style="text-align:left">110</td><td style="text-align:left">ESI</td><td style="text-align:left">[RSI]</td></tr><tr><td style="text-align:left">111</td><td style="text-align:left">EDI</td><td style="text-align:left">[RDI]</td></tr></tbody></table><p>内存索引的标准格式：<code>base+index*scale+disp</code></p><h2 id="SIB">SIB</h2><p>SIB用来确定具体的地址格式<br>如果ModR/M中Mod不为11，且R/M的值为100，则后一个字节为SIB</p><p>ModR/M和SIB各涉及三个域：<br><img src="https://s2.loli.net/2025/03/31/RadXi6T4VHcKSOJ.png" alt="image-20250331171513102"></p><p><img src="https://s2.loli.net/2025/03/31/bTHXZd9BnIeYQMw.png" alt="image-20250331190129120"></p><h3 id="Scale比例因子">Scale比例因子</h3><p>决定索引寄存器值的倍数</p><table><thead><tr><th>值</th><th>比例因子 (Scale)</th></tr></thead><tbody><tr><td>00</td><td>1</td></tr><tr><td>01</td><td>2</td></tr><tr><td>10</td><td>4</td></tr><tr><td>11</td><td>8</td></tr></tbody></table><h3 id="Index索引寄存器">Index索引寄存器</h3><table><thead><tr><th>值</th><th>寄存器 (64 位模式)</th><th>寄存器 (32 位模式)</th></tr></thead><tbody><tr><td>000</td><td>RAX</td><td>EAX</td></tr><tr><td>001</td><td>RCX</td><td>ECX</td></tr><tr><td>010</td><td>RDX</td><td>EDX</td></tr><tr><td>011</td><td>RBX</td><td>EBX</td></tr><tr><td>100</td><td>无索引寄存器</td><td>无索引寄存器</td></tr><tr><td>101</td><td>RBP</td><td>EBP</td></tr><tr><td>110</td><td>RSI</td><td>ESI</td></tr><tr><td>111</td><td>RDI</td><td>EDI</td></tr></tbody></table><h3 id="Base基址寄存器">Base基址寄存器</h3><table><thead><tr><th>值</th><th>寄存器 (64 位模式)</th><th>寄存器 (32 位模式)</th></tr></thead><tbody><tr><td>000</td><td>RAX</td><td>EAX</td></tr><tr><td>001</td><td>RCX</td><td>ECX</td></tr><tr><td>010</td><td>RDX</td><td>EDX</td></tr><tr><td>011</td><td>RBX</td><td>EBX</td></tr><tr><td>100</td><td>RSP（需 SIB 扩展）</td><td>ESP（需 SIB 扩展）</td></tr><tr><td>101</td><td>RBP 或 disp32(Mod=00)</td><td>EBP 或 disp32(Mod=00)</td></tr><tr><td>110</td><td>RSI</td><td>ESI</td></tr><tr><td>111</td><td>RDI</td><td>EDI</td></tr></tbody></table><h2 id="练习">练习</h2><p>8B 41 10</p><p>8B对应MOV Gv Ev</p><p>Gv说明目标操作数是寄存器，Ev表示源操作数为寄存器或地址<br>41是ModR/M<br>01 000 001<br>01说明这个指令的地址Ev为内存地址且有8bit偏移，000说明Gv为AX类，001说明目标操作数为CX类<br>由于没有SIB，10为立即数</p><p>所以指令为：MOV EAX, [RCX+0x10]</p><hr><p>04 FF</p><p>04对应ADD AL,Lb</p><p>已经指定寄存器，后面直接跟立即数，Lb表明是一个byte，所以是ADD AL ,0xff</p><hr><p>67 FF 34 88</p><p>67为指令前缀，表明把之后的地址值转为32位<br>FF表明要去Grp $5^{1A}$<br>34为ModR/M：00 110 100得到指令是PUSH Ev<br>00表明为使用地址无偏移，100表示根据SIB确定地址的值</p><p>SIB：10 001 000</p><p>10表明比例因子为4，001表明索引寄存器为RCX，000表明基址寄存器为RAX</p><p>根据指令前缀，将地址相关寄存器大小转为32位：push qword ptr [eax+ecx*4]</p>]]></content>
    
    
    <summary type="html">本篇介绍x86-64下指令结构</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="基础" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="机器码" scheme="https://www.pri87.vip/tags/%E6%9C%BA%E5%99%A8%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Zydis反编译库编译及使用方式</title>
    <link href="https://www.pri87.vip/posts/cbdd2395.html"/>
    <id>https://www.pri87.vip/posts/cbdd2395.html</id>
    <published>2025-03-28T13:27:56.000Z</published>
    <updated>2025-03-29T03:28:09.613Z</updated>
    
    <content type="html"><![CDATA[<p>Zydis是一个反汇编库，可以解析机器指令将其转为汇编代码，下面是使用方法</p><h2 id="下载">下载</h2><p><a href="https://github.com/zyantific/zydis">zyantific/zydis: Fast and lightweight x86/x86-64 disassembler and code generation library</a></p><p>可以直接下载releases也可以直接clone</p><h2 id="编译">编译</h2><p>标准的编译方法：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone </span>--recursive <span class="string">&#x27;https://github.com/zyantific/zydis.git&#x27;</span></span><br><span class="line">cd zydis</span><br><span class="line">cmake -<span class="keyword">B </span><span class="keyword">build</span></span><br><span class="line"><span class="keyword"></span>cmake --<span class="keyword">build </span><span class="keyword">build </span>-<span class="keyword">j4</span></span><br></pre></td></tr></table></figure><h2 id="配置">配置</h2><p>如果使用的是msvc，可以直接进入msvc目录使用vs编译，配置为release MT，直接生成。</p><p>如果是上面的方法，输出文件在build文件的debug目录下和Zycore\debug目录，如果是下面的方法，输出文件在bin\releaseX64下</p><p>取得生成的Zydis.lib和Zycore.lib，放在项目目录的lib文件夹下(新建)，然后在最外面的zydis目录下找到include复制到项目文件夹，在dependencies\zycore下找到include文件夹复制到项目文件夹</p><p>在项目属性中：</p><ul><li>C/C++<ul><li>常规：附加包含目录添加：$(ProjectDir)include</li><li>预处理器：预处理器定义添加：ZYDIS_STATIC_DEFINE</li></ul></li><li>链接器<ul><li>常规：附加库目录包含添加：$(ProjectDir)lib</li><li>输入：附加依赖项添加：Zycore.lib;Zydis.lib</li></ul></li></ul><h2 id="写代码">写代码</h2><p>引用头文件：<code>#include &lt;Zydis/Zydis.h&gt;</code></p><h2 id="解析器">解析器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ZydisDecoderDecodeFull</span>(&amp;decoder, buffer.<span class="built_in">data</span>() + offset, length - offset,&amp;instruction, operands)</span><br></pre></td></tr></table></figure><p>decoder是ZydisDecoder类型<br>instruction是ZydisDecodedInstruction保存基本指令数据<br>operands是ZydisDecodedOperand类型数组，保存一条指令的操作数</p><p>data是存放机器码的缓冲区</p><p>每次执行一次这个指令，就会对instruction和operands赋值，表示一条指令的解析</p><ul><li>instruction.mnemonic   助记符</li><li>instruction.length    指令总长度</li><li>instruction.opcode    机器码</li><li>instruction.operand_count_visible    显式操作数数量</li><li>operand.type    这个操作数的类型<ul><li>立即数(ZYDIS_OPERAND_TYPE_IMMEDIATE):<br>operand.imm.value数值</li><li>寄存器(ZYDIS_OPERAND_TYPE_REGISTER):<br>operand.reg.value寄存器名称</li><li>内存地址(ZYDIS_OPERAND_TYPE_MEMORY):<br>operand.mem.base表示内存的基址寄存器<br>operand.mem.index表示索引寄存器<br>operand.mem.disp地址偏移值</li></ul></li></ul><p>使用模板可以参考example和下面这个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cinttypes&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Zydis/Zydis.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">readFileToBuffer</span><span class="params">(<span class="type">const</span> std::string&amp; filepath, std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;&amp; buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::ifstream <span class="title">file</span><span class="params">(filepath, std::ios::binary | std::ios::ate)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Failed to open file: &quot;</span> &lt;&lt; filepath &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::streamsize fSize = file.<span class="built_in">tellg</span>();</span><br><span class="line">file.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::beg);</span><br><span class="line">buffer.<span class="built_in">resize</span>(fSize);</span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(buffer.<span class="built_in">data</span>()), fSize))</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Failed to read file: &quot;</span> &lt;&lt; filepath &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printInstructionStructure</span><span class="params">(<span class="type">const</span> ZydisDecodedInstruction&amp; instruction, <span class="type">const</span> ZydisDecodedOperand operands[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Instruction Structure:\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Mnemonic: &quot;</span> &lt;&lt; <span class="built_in">ZydisMnemonicGetString</span>(instruction.mnemonic) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Length: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(instruction.length) &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Opcode: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(instruction.opcode) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Operand Count Visible: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(instruction.operand_count_visible) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ZyanU8 i = <span class="number">0</span>; i &lt; instruction.operand_count_visible; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> ZydisDecodedOperand&amp; operand = operands[i];</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Operand &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(i) &lt;&lt; <span class="string">&quot;: \n&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (operand.type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ZYDIS_OPERAND_TYPE_REGISTER:</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Type: Register\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Register: &quot;</span> &lt;&lt; <span class="built_in">ZydisRegisterGetString</span>(operand.reg.value) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ZYDIS_OPERAND_TYPE_IMMEDIATE:</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Type: Immediate\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; operand.imm.value.u &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ZYDIS_OPERAND_TYPE_MEMORY:</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Type: Memory\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Base: &quot;</span> &lt;&lt; <span class="built_in">ZydisRegisterGetString</span>(operand.mem.base) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Index: &quot;</span> &lt;&lt; <span class="built_in">ZydisRegisterGetString</span>(operand.mem.index) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Displacement: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; operand.mem.disp.value &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; (operand.mem.disp.value &gt;= <span class="number">0</span> ? operand.mem.disp.value : -operand.mem.disp.value) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Type: Unknown\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;-----------------------------------\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ZydisDecoder decoder;</span><br><span class="line"><span class="built_in">ZydisDecoderInit</span>(&amp;decoder, ZYDIS_MACHINE_MODE_LONG_64, ZYDIS_STACK_WIDTH_64);</span><br><span class="line"></span><br><span class="line">ZydisFormatter formatter;</span><br><span class="line"><span class="built_in">ZydisFormatterInit</span>(&amp;formatter, ZYDIS_FORMATTER_STYLE_INTEL);</span><br><span class="line"></span><br><span class="line">std::string filePath = <span class="string">&quot;shellcode.bin&quot;</span>;</span><br><span class="line">std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; buffer;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">readFileToBuffer</span>(filePath, buffer))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZyanU64 runtime_address = <span class="number">0</span>;</span><br><span class="line">ZyanUSize offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> ZyanUSize length = buffer.<span class="built_in">size</span>();</span><br><span class="line">ZydisDecodedInstruction instruction;</span><br><span class="line">ZydisDecodedOperand operands[ZYDIS_MAX_OPERAND_COUNT];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">ZYAN_SUCCESS</span>(<span class="built_in">ZydisDecoderDecodeFull</span>(&amp;decoder, buffer.<span class="built_in">data</span>() + offset, length - offset,</span><br><span class="line">&amp;instruction, operands)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%016&quot;</span> PRIX64 <span class="string">&quot;  &quot;</span>, runtime_address);</span><br><span class="line"><span class="type">char</span> tmp[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">ZydisFormatterFormatInstruction</span>(&amp;formatter, &amp;instruction, operands,</span><br><span class="line">instruction.operand_count_visible, tmp, <span class="built_in">sizeof</span>(tmp),</span><br><span class="line">runtime_address, ZYAN_NULL);</span><br><span class="line"><span class="built_in">puts</span>(tmp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printInstructionStructure</span>(instruction, operands);</span><br><span class="line"></span><br><span class="line">offset += instruction.length;</span><br><span class="line">runtime_address += instruction.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Zydis是一个反汇编库，可以解析机器指令将其转为汇编代码，下面是使用方法&lt;/p&gt;
&lt;h2 id=&quot;下载&quot;&gt;下载&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zyantific/zydis&quot;&gt;zyantific/zydis: Fast and l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GO逆向入门</title>
    <link href="https://www.pri87.vip/posts/356e98d9.html"/>
    <id>https://www.pri87.vip/posts/356e98d9.html</id>
    <published>2025-03-23T14:40:56.000Z</published>
    <updated>2025-03-29T03:28:09.612Z</updated>
    
    <content type="html"><![CDATA[<h1>Golang</h1><p>golang 是谷歌开发的一个静态语言，现在有很多恶意程序使用Go语言开发</p><p><a href="https://www.anquanke.com/post/id/214940">Go二进制文件逆向分析从基础到进阶——综述-安全KER - 安全资讯平台</a></p><h2 id="Go语言基本结构">Go语言基本结构</h2><p>Go语言中有些信息会一直保留在程序中，用于实现单文件直接运行而不需要环境，同时由于反射和stack trace，所以保留的信息非常多，如果找到了这些信息，就可以直接恢复符号表</p><p><a href="https://github.com/0xjiayu/go_parser/blob/master/README_cn.md">go_parser/README_cn.md at master · 0xjiayu/go_parser</a></p><p>用这里的介绍来说，基本信息如下：</p><ul><li>Meta information<ul><li>Go version</li><li>Build ID</li><li>GOROOT</li></ul></li><li>strings and string pointer（字符串指针）</li><li>runtime symbol infomation(pclntab)<ul><li>函数名称表</li><li>源代码路径表</li></ul></li><li>runtime type infomation</li><li>interface table<ul><li>接口类型</li><li>真实类型与绑定方法</li></ul></li></ul><h3 id="pclntab">pclntab</h3><p>Program Counter Line Table程序计数器行数映射表/运行时符号表。程序出错时，runtime将从中得到对应的包名，文件名，方法或函数以及出错的行，最后才能输出出来，所以这里有很多有用的信息</p><p>这里最重要的函数表和函数名称表，它们的偏移都是相对于pclntab进行的</p><h2 id="恢复符号表">恢复符号表</h2><p><a href="https://github.com/mandiant/GoReSym">mandiant/GoReSym: Go symbol recovery tool</a></p><p><a href="https://cloud.google.com/blog/topics/threat-intelligence/golang-internals-symbol-recovery/">Ready， Set， Go — Golang 内部原理和符号恢复 |Google Cloud 博客</a></p><p><a href="https://github.com/0xjiayu/go_parser">0xjiayu/go_parser: Yet Another Golang binary parser for IDAPro</a></p><p>一般来说，这几个就够了，但是如果加了混淆，把符号表和符号名称表的内容(偏移)删了，那就得手动还原了，就很麻烦，所以这种还是用bindiff和sig文件吧</p><h2 id="调用约定">调用约定</h2><p><a href="QAQ">施工中</a></p><h2 id="技巧">技巧</h2><p>对于这种根本看不懂的代码，对函数测试还是用黑盒吧，一般来说一个用户函数后面就有一个库调用函数，用汇编流程图反而好看一点</p>]]></content>
    
    
    <summary type="html">Go的笔记</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="语言" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Go" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E8%AF%AD%E8%A8%80/Go/"/>
    
    
    <category term="Go" scheme="https://www.pri87.vip/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>VMP壳学习笔记</title>
    <link href="https://www.pri87.vip/posts/1a88f77f.html"/>
    <id>https://www.pri87.vip/posts/1a88f77f.html</id>
    <published>2025-03-18T13:02:41.000Z</published>
    <updated>2025-03-29T03:28:09.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近想尝试写个代码混淆器，所以尝试先看看市面上的壳有哪些操作可以学一下，防止走歪路</p><p><a href="https://www.52pojie.cn/thread-1564978-1-1.html">快速认识 VMP 3.x 第一部分 壳代码篇 - 吾爱破解 - 52pojie.cn</a></p><p><a href="https://www.52pojie.cn/thread-1565126-1-1.html">快速认识VMP 3.x 第二部分 代码变异篇 - 吾爱破解 - 52pojie.cn</a></p><p><a href="https://whereisr0da.github.io/blog/posts/2021-02-16-vmp-3/">🔥 Quick look around VMP 3.x - Part 3 : Virtualization | r0da’s Blog</a></p><p>看的主要是这三篇博客</p><h2 id="基本操作">基本操作</h2><h3 id="加壳">加壳</h3><p>这个部分是一般的壳都会做的操作，对可执行文件的节区进行压缩和加密防止被静态分析</p><p>原始节区的内容被放入.vmp1节区，含有被加密的节区内容，壳代码，节区信息</p><p>VMP使用ZwProtectVirtualMemory函数来修改节区权限从而执行解密代码</p><h3 id="IAT混淆">IAT混淆</h3><p>原始IAT还存在，但是不会被使用，所有调用API的操作，都会被转换为运算时动态执行</p><p>具体是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call dword ptr ds:[&lt;&amp;targetFunction&gt;]</span><br></pre></td></tr></table></figure><p>变为等长的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push reg</span><br><span class="line">call api解析器</span><br></pre></td></tr></table></figure><p>api解析器中通过一些计算得到地址然后用ret跳转到api函数中</p><h2 id="代码变异">代码变异</h2><p>VMP会向代码中加入垃圾代码，等效替换，控制流保护</p><p>关于插入垃圾代码和代码替换这部分不是很清楚它是怎么做的。</p><p>控制流中，VMP添加了更多无条件跳转，同时拆分了代码块，让函数和函数交错在一起，代码块不一定是对齐的，这导致了顺序的反汇编器很可能失效</p>]]></content>
    
    
    <summary type="html">VMP壳特征相关的学习笔记</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="技能" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/"/>
    
    <category term="反静态分析" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/%E5%8F%8D%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
    <category term="压缩器" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/%E5%8F%8D%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/%E5%8E%8B%E7%BC%A9%E5%99%A8/"/>
    
    
    <category term="壳" scheme="https://www.pri87.vip/tags/%E5%A3%B3/"/>
    
    <category term="反调试" scheme="https://www.pri87.vip/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    
    <category term="虚拟机" scheme="https://www.pri87.vip/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="代码混淆" scheme="https://www.pri87.vip/tags/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    
  </entry>
  
  <entry>
    <title>组合模式</title>
    <link href="https://www.pri87.vip/posts/df879792.html"/>
    <id>https://www.pri87.vip/posts/df879792.html</id>
    <published>2025-03-17T15:00:32.000Z</published>
    <updated>2025-03-17T15:52:47.500Z</updated>
    
    <content type="html"><![CDATA[<p>如果你要实现以下功能：<br>一个卡牌类，有不同的效果，很自然地可以想到以下实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">std::string name;</span><br><span class="line">std::string description;</span><br><span class="line"><span class="type">size_t</span> id;</span><br><span class="line">dword cost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onHandTurnStart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onTurnStart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onUse</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onHandTurnEnd</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onTurnEnd</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">dword <span class="title">onAttacked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">afterAttacked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">dword <span class="title">onAttack</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">afterAttack</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myCard</span> : <span class="keyword">public</span> BaseCard&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onUse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.<span class="built_in">heal</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">player</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">useCard</span><span class="params">(BaseCard&amp; card)</span></span>&#123;</span><br><span class="line">        card.<span class="built_in">onUse</span>();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TurnStart</span><span class="params">(BaseCard&amp; card)</span></span>&#123;</span><br><span class="line">        card.<span class="built_in">onTurnStart</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样，如果要创造更多的不一样的卡牌，就要一直添加Card，同时，如果考虑人物技能，道具能力，也许一个效果要重写多次，所以，完全可以将效果单独拿出来当作新类，然后在对应人物/道具/卡牌中添加不同的效果模块</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Effect</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTurnStart</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onUse</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Effect</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AEffect</span> : <span class="keyword">public</span> Effect &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onUse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.<span class="built_in">heal</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CaposEffect</span> : <span class="keyword">public</span> Effect&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Effect&gt;&gt; ce;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onUse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> effect:ce)&#123;</span><br><span class="line">            effect-&gt;<span class="built_in">onUse</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEffect</span><span class="params">(std::shared_ptr&lt;Effect&gt;&amp;x)</span></span>&#123;</span><br><span class="line">        ce.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">std::string name;</span><br><span class="line">std::string description;</span><br><span class="line"><span class="type">size_t</span> id;</span><br><span class="line">dword cost;</span><br><span class="line">std::shared_ptr&lt;CaposEffect&gt; effects;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onHandTurnStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        effects-&gt;<span class="built_in">onHandTurnStart</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onUse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        effects-&gt;<span class="built_in">onUse</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEffect</span><span class="params">(std::shared_ptr&lt;Effect&gt;&amp;x)</span></span>&#123;</span><br><span class="line">        effects.<span class="built_in">addEffect</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myCard</span> : <span class="keyword">public</span> BaseCard&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onUse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.<span class="built_in">heal</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现了两种对象之间的解耦，且可以为effect创建effect组，实现多种效果的组合。</p>]]></content>
    
    
    <summary type="html">组合模式</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="开发" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/"/>
    
    <category term="面向对象基础" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="OOP" scheme="https://www.pri87.vip/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>驱动开发入门</title>
    <link href="https://www.pri87.vip/posts/d2620136.html"/>
    <id>https://www.pri87.vip/posts/d2620136.html</id>
    <published>2025-03-09T10:17:34.000Z</published>
    <updated>2025-03-10T14:40:41.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="驱动">驱动</h2><p>在Windows中，驱动是运行在内核(R0层)的软件。由于运行在内核层，所以可以做操作系统可以做的绝大多数事情，比如和硬件进行交互，就必须在内核中执行。一般来说，驱动都是用来实现某设备的IO操作的。</p><h3 id="分类">分类</h3><p>驱动分为如下几种类型：</p><ul><li>设备函数驱动程序<ul><li>实现硬件设备的逻辑，比如设备的初始化和数据传输等</li><li>一般为硬件制造商开发</li><li>例：键盘驱动程序，显示驱动程序，打印机驱动程序</li></ul></li><li>设备筛选器驱动程序<ul><li>设备筛选器是用来修改或扩展设备函数驱动的行为的驱动，分为上层过滤器和下层过滤器</li><li>可以拦截或修改设备的操作，类似与钩子</li><li>例：拦截和记录USB设备通信的驱动程序</li></ul></li><li>软件驱动程序<ul><li>为逻辑设备服务的驱动程序，实现虚拟设备或系统功能</li><li>实现虚拟功能并处理高层逻辑而非硬件交互。</li><li>例：虚拟磁盘，虚拟网卡</li></ul></li><li>文件系统筛选器驱动程序<ul><li>用来监控，修改或增强文件系统的行为的驱动，附加在文件系统驱动堆栈中，可以拦截文件操作的IO操作</li><li>检查修改文件操作，打开读取写入等，执行权限控制，加密，数据压缩等</li><li>例：防止未授权访问文件</li></ul></li><li>文件系统驱动程序<ul><li>实现文件操作逻辑的驱动(NTFS,FAT32等)，文件系统堆栈中的核心部分，直接管理磁盘上的文件</li><li>实现文件读写，路径解析，目录管理</li><li>例：Windows中的ntfs.sys和fat32.sys</li></ul></li></ul><h3 id="驱动对象和设备对象">驱动对象和设备对象</h3><h4 id="驱动对象">驱动对象</h4><p>操作系统标识一个驱动的数据结构</p><p>该对象由操作系统自动生成(下面是WDM)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pdriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">DbgPrint(<span class="string">&quot;DriverUnload\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject,</span></span><br><span class="line"><span class="params">PUNICODE_STRING pRegPath<span class="comment">//注册表路径</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">DbgPrint(<span class="string">&quot;DriverEntry\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">pDriverObject-&gt;DriverUnload = DriverUnload;<span class="comment">//指定驱动卸载函数</span></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这之中pDriverObject是操作系统为这个驱动创建的驱动对象，部分内容需要在DriverEntry中由用户添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> &#123;</span></span><br><span class="line">    CSHORT Type;</span><br><span class="line">    CSHORT Size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The following links all of the devices created by a single driver</span></span><br><span class="line">    <span class="comment">// together on a list, and the Flags word provides an extensible flag</span></span><br><span class="line">    <span class="comment">// location for driver objects.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    PDEVICE_OBJECT DeviceObject;</span><br><span class="line">    ULONG Flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The following section describes where the driver is loaded.  The count</span></span><br><span class="line">    <span class="comment">// field is used to count the number of times the driver has had its</span></span><br><span class="line">    <span class="comment">// registered reinitialization routine invoked.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    PVOID DriverStart;</span><br><span class="line">    ULONG DriverSize;</span><br><span class="line">    PVOID DriverSection;</span><br><span class="line">    PDRIVER_EXTENSION DriverExtension;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The driver name field is used by the error log thread</span></span><br><span class="line">    <span class="comment">// determine the name of the driver that an I/O request is/was bound.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    UNICODE_STRING DriverName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The following section is for registry support.  This is a pointer</span></span><br><span class="line">    <span class="comment">// to the path to the hardware information in the registry</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    PUNICODE_STRING HardwareDatabase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The following section contains the optional pointer to an array of</span></span><br><span class="line">    <span class="comment">// alternate entry points to a driver for &quot;fast I/O&quot; support.  Fast I/O</span></span><br><span class="line">    <span class="comment">// is performed by invoking the driver routine directly with separate</span></span><br><span class="line">    <span class="comment">// parameters, rather than using the standard IRP call mechanism.  Note</span></span><br><span class="line">    <span class="comment">// that these functions may only be used for synchronous I/O, and when</span></span><br><span class="line">    <span class="comment">// the file is cached.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    PFAST_IO_DISPATCH FastIoDispatch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The following section describes the entry points to this particular</span></span><br><span class="line">    <span class="comment">// driver.  Note that the major function dispatch table must be the last</span></span><br><span class="line">    <span class="comment">// field in the object so that it remains extensible.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    PDRIVER_INITIALIZE DriverInit;</span><br><span class="line">    PDRIVER_STARTIO DriverStartIo;</span><br><span class="line">    PDRIVER_UNLOAD DriverUnload;</span><br><span class="line">    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125; DRIVER_OBJECT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> *<span class="title">PDRIVER_OBJECT</span>;</span> </span><br></pre></td></tr></table></figure><p>在c中，它的定义和可行的操作如上</p><p>可以看出操作系统用一个单链表连接了所有的设备对象。且使用了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PDRIVER_INITIALIZE DriverInit;</span><br><span class="line">PDRIVER_STARTIO DriverStartIo;</span><br><span class="line">PDRIVER_UNLOAD DriverUnload;</span><br><span class="line">PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>来为操作系统调用驱动中的函数提供了基础。</p><p>一般来说，一个驱动注册好了后，会和其它同类驱动组合成驱动栈，它们从高到低地处理不同层级的问题，每当引发一个请求，都会从高到低询问要不要处理，如果不处理就会继续向下，如果处理，那么就此终止，不会继续传递。</p><h4 id="设备对象">设备对象</h4><p>设备对象是操作对象用来描述一个设备的核心数据结构。可以标识并管理硬件设备或逻辑设备。</p><p>需要自创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PDRIVER_OBJECT DriverObject,</span></span><br><span class="line"><span class="params">    _In_ PUNICODE_STRING RegistryPath</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    PDEVICE_OBJECT DeviceObject = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = IoCreateDevice(</span><br><span class="line">        DriverObject,            <span class="comment">// 所属驱动对象</span></span><br><span class="line">        <span class="keyword">sizeof</span>(DEVICE_EXTENSION), <span class="comment">// 设备扩展的大小</span></span><br><span class="line">        &amp;DeviceName,             <span class="comment">// 设备名称</span></span><br><span class="line">        FILE_DEVICE_UNKNOWN,     <span class="comment">// 设备类型</span></span><br><span class="line">        <span class="number">0</span>,                       <span class="comment">// 特性标志</span></span><br><span class="line">        FALSE,                   <span class="comment">// 是否为独占设备</span></span><br><span class="line">        &amp;DeviceObject            <span class="comment">// 输出设备对象</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status; <span class="comment">// 创建失败时返回错误状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PDRIVER_OBJECT pDriverObject,</span></span><br><span class="line"><span class="params">    _In_ PUNICODE_STRING pRegistryPath</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    PDEVICE_OBJECT pDeviceObject = <span class="literal">NULL</span>;</span><br><span class="line">    UNICODE_STRING deviceName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\FileFilter&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建设备对象</span></span><br><span class="line">    status = IoCreateDevice(</span><br><span class="line">        pDriverObject,          <span class="comment">// 驱动对象</span></span><br><span class="line">        <span class="number">0</span>,                      <span class="comment">// 没有设备扩展</span></span><br><span class="line">        &amp;deviceName,            <span class="comment">// 设备名</span></span><br><span class="line">        FILE_DEVICE_DISK_FILE_SYSTEM, <span class="comment">// 指定为文件系统类型</span></span><br><span class="line">        <span class="number">0</span>,                      <span class="comment">// 无特殊特性</span></span><br><span class="line">        FALSE,                  <span class="comment">// 非独占</span></span><br><span class="line">        &amp;pDeviceObject          <span class="comment">// 输出设备对象指针</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;Failed to create device object\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置卸载函数和其他初始化逻辑</span></span><br><span class="line">    pDriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = FileCreateHandler; <span class="comment">// 处理文件创建</span></span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_READ] = FileReadHandler;     <span class="comment">// 处理文件读取</span></span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;Device object created successfully\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(_In_ PDRIVER_OBJECT pDriverObject)</span> &#123;</span><br><span class="line">    UNICODE_STRING deviceName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\FileFilter&quot;</span>);</span><br><span class="line">    IoDeleteDevice(pDriverObject-&gt;DeviceObject); <span class="comment">// 删除设备对象</span></span><br><span class="line">    DbgPrint(<span class="string">&quot;Driver unloaded\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IRP_MJ_CREATE 和 IRP_MJ_READ 是 I/O 请求包（IRP）的主功能码，分别对应文件/设备的创建（或打开）操作和读取操作。当用户层调用相关 I/O 操作（如 CreateFile 或 ReadFile）时，操作系统的 I/O 管理器会生成对应的 IRP，并将其传递到目标设备的驱动栈中。驱动程序通过在驱动对象中注册的调度例程（Dispatch Routine）处理这些 IRP 请求。调度例程会把主功能码映射为MajorFunction的索引，然后驱动指定对应索引的函数来实现功能。</p>]]></content>
    
    
    <summary type="html">介绍驱动基本概念</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="开发" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/"/>
    
    <category term="驱动开发" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="驱动" scheme="https://www.pri87.vip/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Win11虚拟机配置</title>
    <link href="https://www.pri87.vip/posts/a848d09.html"/>
    <id>https://www.pri87.vip/posts/a848d09.html</id>
    <published>2025-03-05T09:31:13.000Z</published>
    <updated>2025-03-10T05:57:59.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ios下载">ios下载</h2><p><a href="https://next.itellyou.cn/Original/Index">Itellyou</a></p><h2 id="虚拟机">虚拟机</h2><p><a href="https://www.vmware.com/products">VMware</a></p><h2 id="安装vmware-tools">安装vmware tools</h2><p>虚拟机整个安装好之后(进入桌面)</p><p><img src="https://s2.loli.net/2025/03/05/q1o7PB8HZGiuNV6.png" alt="image-20250305212801916"></p><p>没有安装的话不会是重新安装，点击后，按虚拟机中的提示安装即可。</p><h2 id="激活">激活</h2><p>管理员powershell:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">irm</span> https://get.activated.win | <span class="built_in">iex</span></span><br></pre></td></tr></table></figure><h2 id="连接主机网络">连接主机网络</h2><p>虚拟机网络选择net模式、关闭虚拟机防火墙</p><p>win+x然后i执行ipconfig：Ethernet0就是虚拟机本地ip</p><p>主机用同理方法可以得到ip地址，相互ping来测试</p><p>或者直接<code>ping 计算机名</code> 也可以</p><h2 id="配置虚拟机wdk和连接">配置虚拟机wdk和连接</h2><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/provision-a-target-computer-wdk-8-1">预配计算机以便进行驱动程序部署和测试 (WDK 10) - Windows drivers | Microsoft Learn</a></p><p>在虚拟机中安装wdk，执行<code>C:\Program Files (x86)\Windows Kits\10\Remote\x64\WDK Test Target Setup x64-x64_en-us.msi</code>这个文件</p><p>然后vs打开项目的扩展-driver-Test-Configure Devices…添加对应主机名或ip</p><p>然后设置为目标计算机</p><p><img src="https://s2.loli.net/2025/03/06/xT5iMW9stkQ6uJd.png" alt="image-20250306153628068"></p><h3 id="调试">调试</h3><p>虚拟机中开启测试模式</p><p>对于上面显示的key和port，宿主机中</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Windbg <span class="literal">-k</span> net:port=xxx,key=xxx</span><br></pre></td></tr></table></figure><p>在C:\Program Files (x86)\Windows Kits\10\Debuggers\x64下执行</p><h2 id="关于部署驱动和在vs中调试的报错">关于部署驱动和在vs中调试的报错</h2><h3 id="编译期报错：需要缓解库或者语法错误">编译期报错：需要缓解库或者语法错误</h3><p>确保缓解库版本和工具链版本一致，如果是最新，需要在项目属性中找到MVCS版本，调整为所有可选版本中最新的版本，而不是默认</p><p>语法错误需要检查编码，尝试以UTF8存储或者GBK，多试几个应该就好了</p><h3 id="报错：第三方inf不包含数字签名信息">报错：第三方inf不包含数字签名信息</h3><p>需要生成crt证书文件，项目，属性，Inf2Cat，Run Inf2Cat 改为是<br>属性，Driver Signing中Sign Mode改为Test Sign<br>虚拟机开启测试模式</p><h3 id="Windbg无法调试，打开一直显示Waiting-to-reconnect…">Windbg无法调试，打开一直显示Waiting to reconnect…</h3><p>首先确保虚拟机调试模式一打开，如果vs中设置好了port和key，且虚拟机中<br><code>bcdedit /dbgsettings</code>查看设置是否相同，如果相同，尝试关闭虚拟机的调试模式再打开，重复两三次，然后再尝试（这个被坑了好久，最后还是学长帮我配好的）</p><h3 id="driverquery无法看到对应的驱动">driverquery无法看到对应的驱动</h3><p>查看当前驱动是不是硬件驱动，在设备管理器中选择按驱动分类，可以找到自己安装的驱动，想要看这种驱动的值，可以通过驱动注入程序强制安装，然后在dbgview中看到效果。如果是微软写的抽象helloworld代码，因为没写卸载函数，所以不能卸载。不如用下面这个做测试(用wdm项目)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pdriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">DbgPrint(<span class="string">&quot;DriverUnload\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject,</span></span><br><span class="line"><span class="params">PUNICODE_STRING pRegPath<span class="comment">//注册表路径</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">DbgPrint(<span class="string">&quot;DriverEntry\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pDriverObject-&gt;DriverUnload = DriverUnload;<span class="comment">//指定驱动卸载函数</span></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太抽象了，这个环境配了6天TAT，感谢 <span class='nota' data-nota='卡密'>学长</span> 帮我。</p>]]></content>
    
    
    <summary type="html">配置win11虚拟机以适配调试驱动环境</summary>
    
    
    
    <category term="实践" scheme="https://www.pri87.vip/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="记录" scheme="https://www.pri87.vip/categories/%E5%AE%9E%E8%B7%B5/%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>IDA自动化调试</title>
    <link href="https://www.pri87.vip/posts/9be53c83.html"/>
    <id>https://www.pri87.vip/posts/9be53c83.html</id>
    <published>2025-03-04T14:52:26.000Z</published>
    <updated>2025-03-05T09:29:15.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>之前一直想找个方法实现IDA调试的时候自动执行操作，现在终于找到了</p><p>ida里面有一个api：ida_dbg.step_into()，效果是执行一次步入，通过循环这个指令就可以实现自动步入的效果，在步过后写自己需要的效果就好</p><h2 id="实现">实现</h2><p>下面是一个对于dasctf，BabyEnc的指令还原脚本，这个题将真的逻辑用汇编写了出来，并把每句汇编放在格式相同的花指令中，通过下面这个脚本可以提取每组汇编中的真实代码，组合成一个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idc <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> ida_dbg</span><br><span class="line"></span><br><span class="line">statx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_address</span>(<span class="params">target_ea</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;trace_output.bin&quot;</span>, <span class="string">&quot;ab&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            ida_dbg.wait_for_next_event(ida_dbg.WFNE_SUSP, -<span class="number">1</span>)<span class="comment">#在获取内存/寄存器/状态和执行(f4,f7,f8,f9)之间必须有这行，ida是单线程，必须等待调试器获取到状态之后再取内容</span></span><br><span class="line">            current_ea = ida_dbg.get_reg_val(<span class="string">&quot;EIP&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> current_ea == target_ea:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                handle_instruction(current_ea, f)</span><br><span class="line">                ida_dbg.step_into()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_instruction</span>(<span class="params">ea, file</span>):</span><br><span class="line">    <span class="keyword">global</span> statx</span><br><span class="line">    statx-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(statx &lt;= <span class="number">0</span>):<span class="comment">#减少时间，ida指令需要时间</span></span><br><span class="line">        instr = idc.GetDisasm(ea)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;jmp     ebx&quot;</span> <span class="keyword">in</span> instr:<span class="comment">#在每块的结尾执行</span></span><br><span class="line">            statx = <span class="number">11</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            ea_temp = ea</span><br><span class="line">            prev_instr = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; <span class="number">11</span>:<span class="comment">#向上找第十一行代码</span></span><br><span class="line">                ea_temp = idc.prev_head(ea_temp)</span><br><span class="line">                prev_instr = idc.GetDisasm(ea_temp)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;popa&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> prev_instr <span class="keyword">and</span> <span class="string">&quot;cmp&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> prev_instr:<span class="comment">#过滤跳转指令</span></span><br><span class="line">                machine_code = ida_bytes.get_bytes(ea_temp, idc.get_item_size(ea_temp))</span><br><span class="line">                file.write(machine_code)</span><br><span class="line">                <span class="built_in">print</span>(prev_instr)</span><br><span class="line"></span><br><span class="line">check_address(<span class="number">0x0041F082</span>)</span><br></pre></td></tr></table></figure><p>另一种实现是依赖断点的实现，继承DBG_hooks实现断点钩子，需要准确知道在哪里下断点才行，感觉有点麻烦，不过要是能算出来具体的位置，那也很简单，速度也更快</p><h2 id="缺点">缺点</h2><p>需要的时间太长了，尤其是在有长花指令的情况下，这段代码大概执行了90分钟左右，但是没有花指令一般好像也不需要这种操作(也许控制流混淆需要？)。不过另外一方面，编写这种脚本不需要脑子，不需要主动获取寄存器的值，模拟执行可能写的有偏差，但是这种就肯定不会错。</p>]]></content>
    
    
    <summary type="html">IDA的自动化调试</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="自动化逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%80%86%E5%90%91/"/>
    
    
    <category term="IDA" scheme="https://www.pri87.vip/tags/IDA/"/>
    
  </entry>
  
  <entry>
    <title>MASM汇编</title>
    <link href="https://www.pri87.vip/posts/dfd755e7.html"/>
    <id>https://www.pri87.vip/posts/dfd755e7.html</id>
    <published>2025-02-28T10:42:42.000Z</published>
    <updated>2025-04-28T15:44:58.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="x16基本格式">x16基本格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment;指定段</span><br><span class="line"></span><br><span class="line">int 21h;退出</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="x86基本格式">x86基本格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">.586;指定指令集版本</span><br><span class="line">.model flat,stdcall;设置内存模型和调用约定:_edecl,_stdcall,_fastcall，_thiscall</span><br><span class="line">option casemap:none;区分大小写</span><br><span class="line"></span><br><span class="line">includelib ucrt.lib;导入c相关标准库</span><br><span class="line">includelib legacy_stdio_definitions.lib;导入c相关库</span><br><span class="line"></span><br><span class="line">includelib Kernel32.lib</span><br><span class="line">includelib User32.lib</span><br><span class="line"></span><br><span class="line">MessageBoxA proto hwnd:DWORD,lpText:BYTE,lpCaption:BYTE,uType:DWORD</span><br><span class="line">ExitProcess proto uCode:DWORD</span><br><span class="line"></span><br><span class="line">extern printf:proc;声明外部函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.data;指定段</span><br><span class="line">szFormat db &#x27;%d&#x27;, 0</span><br><span class="line"></span><br><span class="line">.code;指定段</span><br><span class="line">main proc</span><br><span class="line">mov eax,64h</span><br><span class="line">push eax;函数调用</span><br><span class="line">lea ecx,szFormat</span><br><span class="line">push ecx</span><br><span class="line">call printf</span><br><span class="line">add esp,8;c标准</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">push 0</span><br><span class="line">push 0</span><br><span class="line">push 0</span><br><span class="line">call MessageBoxA;</span><br><span class="line">push 0</span><br><span class="line">call ExitProcess;win标准 或者可以写invoke ExitProcess,0</span><br><span class="line">main endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="汇编头文件-inc">汇编头文件(.inc)</h3><p>包含头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include header.inc</span><br></pre></td></tr></table></figure><h3 id="伪指令">伪指令</h3><h4 id="invoke">invoke</h4><p>使用前必须先定义，比如上面的<code>ExitProcess proto uCode:DWORD</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke farproc,para1,para2,...</span><br></pre></td></tr></table></figure><p>只能用于win32 api</p><p><a href="https://masm32.com/download.htm">Download The MASM32 SDK</a>下载MASM32SDK</p><p>效果是可以直接导入已经定义好的函数，可以直接invoke</p><p>在项目属性中Microsoft Macro Assembler-include Paths中附加MASM中的include目录，然后可以直接这样使用函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.586;指定指令集版本</span><br><span class="line">.model flat,stdcall;设置内存模型和调用约定:_edecl,_stdcall,_fastcall，_thiscall</span><br><span class="line">option casemap:none;区分大小写</span><br><span class="line"></span><br><span class="line">includelib ucrt.lib;导入c相关标准库</span><br><span class="line">includelib legacy_stdio_definitions.lib;导入c相关库</span><br><span class="line"></span><br><span class="line">include Kernel32.inc</span><br><span class="line">include User32.inc</span><br><span class="line"></span><br><span class="line">includelib Kernel32.lib</span><br><span class="line">includelib User32.lib</span><br><span class="line"></span><br><span class="line">extern printf:proc;声明外部函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.data;指定段</span><br><span class="line">szFormat db &#x27;%d&#x27;, 0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">mov eax,64h</span><br><span class="line">push eax;函数调用</span><br><span class="line">lea ecx,szFormat</span><br><span class="line">push ecx</span><br><span class="line">call printf</span><br><span class="line">add esp,8;c标准</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">push 0</span><br><span class="line">push 0</span><br><span class="line">push 0</span><br><span class="line">call MessageBoxA;</span><br><span class="line">push 0</span><br><span class="line">call ExitProcess;win标准 或者可以写invoke ExitProcess,0</span><br><span class="line">main endp</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>对于自己定义的函数，使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addx proc numA:dword,numB:dword</span><br><span class="line">xor eax,eax</span><br><span class="line">add eax,numA</span><br><span class="line">add eax,numB</span><br><span class="line">ret</span><br><span class="line">addx endp</span><br></pre></td></tr></table></figure><p>这样的格式，也可以用invoke调用，对于C库的cstd函数，可以通过这个方式进行一次std的封装。</p><h4 id="if">if</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main proc</span><br><span class="line">mov dwIndex,11</span><br><span class="line">    .if dwIndex== 10</span><br><span class="line">    mov dwNumber,10</span><br><span class="line">    invoke printNumber,dwNumber</span><br><span class="line">    .elseif deIndex &gt;= 12</span><br><span class="line">    mov dwNumber,12</span><br><span class="line">    invoke printNumber,dwNumber</span><br><span class="line">    .else</span><br><span class="line">    mov dwNumber,0</span><br><span class="line">    invoke printNumber,dwNumber</span><br><span class="line">    .endif</span><br><span class="line">main endp</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">.break;跳出循环</span><br><span class="line">.continue;跳到条件检查</span><br></pre></td></tr></table></figure><h4 id="while">while</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dwIndex,100</span><br><span class="line">.while dwIndex&gt;0</span><br><span class="line">dec deIndex</span><br><span class="line">.endw</span><br></pre></td></tr></table></figure><h3 id="宏">宏</h3><p>无参宏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAA EQU 100</span><br></pre></td></tr></table></figure><p>将AAA当100</p><p>有参宏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;定义</span><br><span class="line">MyAdd MACRO n1</span><br><span class="line">add eax,n1</span><br><span class="line">endm</span><br><span class="line">;使用</span><br><span class="line">MyAdd &lt;1&gt;;简单参数也可以直接MyAdd 1</span><br><span class="line"></span><br><span class="line">MyAdd2 MACRO reg,n1</span><br><span class="line">add reg,n1</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">MyAdd eax,10</span><br></pre></td></tr></table></figure><h3 id="结构体">结构体</h3><p>在data段外声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Point struct;声明</span><br><span class="line">x word ?</span><br><span class="line">y word ?</span><br><span class="line">Point ends</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">MyPoint Point&lt;?&gt;;不初始化定义</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">    mov MyPoint.x,123</span><br><span class="line">    mov MyPoint.y,456</span><br><span class="line">main endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="内联汇编">内联汇编</h3><p>vs中可以在c和cpp中使用内联汇编</p><p>x86：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_asm&#123;</span><br><span class="line">push MB_OK;可以直接传宏</span><br><span class="line">call myFunc;可以直接调用定义的函数</span><br><span class="line">_emit 1;立即数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x64：</p><p>在生成依赖项中勾选masm，新建asm文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.code</span><br><span class="line">Myadd proc</span><br><span class="line">mov ecx,edx</span><br><span class="line">mov eax,ecx</span><br><span class="line">ret</span><br><span class="line">Myadd endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>再声明head.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exten <span class="string">&quot;C&quot;</span> DWORD <span class="title function_">Myadd</span><span class="params">(DWORD a,DWORD b)</span>;</span><br></pre></td></tr></table></figure><p>包含这个文件即可直接使用</p><h2 id="x64基本格式">x64基本格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">sub rsp,28h</span><br><span class="line">add rsp,28h</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>可以直接写代码，调用函数用fastcall</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">.data?;定义未初始化数据</span><br><span class="line">.const;定义常量</span><br></pre></td></tr></table></figure><p>通过修改编译器为inter，可以继续使用内联汇编</p><p>可以直接使用vs或者ida查看c/cpp代码然后取得相应的汇编代码，避免麻烦<br>VS中需要先取消符号</p>]]></content>
    
    
    <summary type="html">MASM下的汇编学习</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="基础" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="汇编" scheme="https://www.pri87.vip/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>《逆核》0C-向会话0注入DLL</title>
    <link href="https://www.pri87.vip/posts/9dacfd2d.html"/>
    <id>https://www.pri87.vip/posts/9dacfd2d.html</id>
    <published>2025-02-27T07:30:04.000Z</published>
    <updated>2025-02-27T10:19:14.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="会话">会话</h2><p>会话是登录后的用户环境</p><p>在进程管理器中详细信息的空栏中右键，可以打开会话属性：</p><p><img src="https://s2.loli.net/2025/02/27/NUsmc2Vodyr4CLP.png" alt="image-20250227180553270"></p><p>它用来隔离不同用户的操作环境，会话ID的先后顺序取决于系统启动后哪个用户先登录，会话0一般为系统进程，和用户进程隔离来提高安全性。（但是看起来似乎没什么用）</p><p>如果要注入系统进程，直接使用CreateRemoteThread会被拦截下来，所以需要用另外的办法。最简单的就是换一个API：NtCreateThreadEx</p><p>定义如下，与CreateRemoteThread差不多</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* PFNTCREATETHREADEX)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">PHANDLE ThreadHandle,<span class="comment">//创建的线程的线程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">ACCESS_MASK DesiredAccess,<span class="comment">//线程权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID ObjectAttributes,<span class="comment">//属性，一般nullptr</span></span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE ProcessHandle,<span class="comment">//目标进程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPTHREAD_START_ROUTINE lpStartAddress,<span class="comment">//起始函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpParameter,<span class="comment">//参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">ULONG CreateThreadFlags,<span class="comment">//好像和挂起有关，填FALSE即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T ZeroBits,<span class="comment">//0即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T StackSize,<span class="comment">//0即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T MaximumStackSize,<span class="comment">//0即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID pUnkown<span class="comment">//nullptr即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>直接用这个注入就好</p><p>注入器代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">modifiedCreateRemoteThread</span><span class="params">(HANDLE hProcess, LPTHREAD_START_ROUTINE pThreadProc, LPVOID pRemoteBuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FARPROC pNtCreateThreadEx = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtCreateThreadEx&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pNtCreateThreadEx)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NtCreateThreadEx not found&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* PFNTCREATETHREADEX)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID pUnkown</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line">PFNTCREATETHREADEX crt = <span class="built_in">reinterpret_cast</span>&lt;PFNTCREATETHREADEX&gt;(pNtCreateThreadEx);</span><br><span class="line">HANDLE hThread;</span><br><span class="line"><span class="built_in">crt</span>(&amp;hThread, THREAD_ALL_ACCESS, <span class="literal">nullptr</span>, hProcess, pThreadProc, pRemoteBuf, FALSE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (!hThread) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create thread failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);<span class="comment">//等待线程结束</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inject</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span> </span>&#123;</span><br><span class="line">HANDLE hProcess = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> status = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!(hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPID)))<span class="comment">//取得对应PID句柄</span></span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;open %d failed\n&quot;</span>), dwPID);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(TCHAR);</span><br><span class="line">LPVOID pBuf = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);<span class="comment">//申请内存</span></span><br><span class="line"><span class="keyword">if</span> (pBuf == <span class="number">0</span>) &#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;memory alloc failed\n&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess, pBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);<span class="comment">//写入地址</span></span><br><span class="line">HMODULE kernel = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (kernel == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">LPTHREAD_START_ROUTINE pThreadProc = (LPTHREAD_START_ROUTINE)<span class="built_in">GetProcAddress</span>(kernel, <span class="string">&quot;LoadLibraryW&quot;</span>);<span class="comment">//获取LodaLibrary地址</span></span><br><span class="line">status = <span class="built_in">modifiedCreateRemoteThread</span>(hProcess,</span><br><span class="line">pThreadProc,<span class="comment">//线程回调函数</span></span><br><span class="line">pBuf<span class="comment">//传参</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, TCHAR* argv[]) &#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;USAGE: %s pid dll_path\n&quot;</span>), argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">inject</span>((DWORD)_tstol(argv[<span class="number">1</span>]), argv[<span class="number">2</span>]))</span><br><span class="line">_tprintf(_T(<span class="string">&quot;inject %s success!\n&quot;</span>), argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;inject %s failed! \n&quot;</span>), argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/02/27/ExOAXnoB3Lyhp2d.png" alt="image-20250227181313876"></p><p>可以看到进程查看器中显示已经注入成功</p>]]></content>
    
    
    <summary type="html">WIN7以上直接createRemoteThread不可以注入会话0的进程</summary>
    
    
    
    <category term="逆向工程核心原理" scheme="https://www.pri87.vip/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="技能" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/"/>
    
    <category term="DLL注入" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/DLL%E6%B3%A8%E5%85%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>《逆核》0B-进程隐藏</title>
    <link href="https://www.pri87.vip/posts/88758528.html"/>
    <id>https://www.pri87.vip/posts/88758528.html</id>
    <published>2025-02-24T07:09:37.000Z</published>
    <updated>2025-02-27T04:17:33.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理">原理</h2><p>每个进程可以通过ZwQuerySystemInformation API函数获取运行中所有有关进程的结构体链表，<br>通过Hook其它所有进程的ZwQuerySystemInformation API，使其在返回前先删掉想要隐藏进程的结构体，从而实现隐藏进程</p><p>但是如果只有这样，那么后创建的进程依然能识别到，所以除了直接hook ZwQuerySystemInformation ，还要hook创建进程的函数，这里选择的是ZwResumeThread api，通过hook这个api，任何一个进程在执行它时先执行hook新进程的ZwQuerySystemInformation 实现新进程也被hook的效果。</p><h2 id="具体流程">具体流程</h2><p>写一个dll，效果是</p><ul><li>hook本进程的ZwQuerySystemInformation函数，隐藏结构体</li><li>hook本进程的ZwResumeThread函数，注入这个DLL</li></ul><p>写一个全进程注入器，把这个dll注入所有进程</p><p>隐藏结构体的方式是</p><p>NtQuerySystemInformation函数在SystemInformationClass参数为5时会在SystemInformation返回PSYSTEM_PROCESS_INFORMATION型结构体链表头，每个结构体都保存了一个当前正在运行的进程，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">    ULONG NextEntryOffset;</span><br><span class="line">    ULONG NumberOfThreads;</span><br><span class="line">    BYTE Reserved1[<span class="number">48</span>];</span><br><span class="line">    UNICODE_STRING ImageName;</span><br><span class="line">    KPRIORITY BasePriority;</span><br><span class="line">    HANDLE UniqueProcessId;</span><br><span class="line">    PVOID Reserved2;</span><br><span class="line">    ULONG HandleCount;</span><br><span class="line">    ULONG SessionId;</span><br><span class="line">    PVOID Reserved3;</span><br><span class="line">    SIZE_T PeakVirtualSize;</span><br><span class="line">    SIZE_T VirtualSize;</span><br><span class="line">    ULONG Reserved4;</span><br><span class="line">    SIZE_T PeakWorkingSetSize;</span><br><span class="line">    SIZE_T WorkingSetSize;</span><br><span class="line">    PVOID Reserved5;</span><br><span class="line">    SIZE_T QuotaPagedPoolUsage;</span><br><span class="line">    PVOID Reserved6;</span><br><span class="line">    SIZE_T QuotaNonPagedPoolUsage;</span><br><span class="line">    SIZE_T PagefileUsage;</span><br><span class="line">    SIZE_T PeakPagefileUsage;</span><br><span class="line">    SIZE_T PrivatePageCount;</span><br><span class="line">    LARGE_INTEGER Reserved7[<span class="number">6</span>];</span><br><span class="line">&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;</span><br></pre></td></tr></table></figure><p>其中ImageName.buffer为wchar_t类型的进程名，NextEntryOffset为和下一个结构体节点相差的字节数，通过这个来连接，如果为0说明没有后继节点，只要通过这个把想要隐藏的隐藏掉即可</p><p>第二点，勾取ZwResumeThread时，应该先注入后恢复，同时注意注入时并不是在新线程内部注入，而是作为父进程远程线程注入</p><h2 id="实现">实现</h2><p>dll代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstatus.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/SECTION:.SHARED,RWS&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg(<span class="string">&quot;.SHARE&quot;</span>)</span></span><br><span class="line">TCHAR g_szProcName[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">__declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">setProcName</span><span class="params">(LPCTSTR szProcName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_tcscpy_s(g_szProcName, szProcName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//PZwQuerySystemInformation</span></span><br><span class="line"><span class="comment">//00007FFBF7E50A70  mov         r10, rcx</span></span><br><span class="line"><span class="comment">//00007FFBF7E50A73  mov         eax, 36h</span></span><br><span class="line"><span class="comment">//00007FFBF7E50A78  test        byte ptr[7FFE0308h], 1</span></span><br><span class="line"><span class="comment">//00007FFBF7E50A80  jne         00007FFBF7E50A85</span></span><br><span class="line"><span class="comment">//00007FFBF7E50A82  syscall</span></span><br><span class="line"><span class="comment">//00007FFBF7E50A84  ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BYTE orgBytesA[<span class="number">14</span>];</span><br><span class="line">BYTE orgBytesB[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* PZwQuerySystemInformation)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG SystemInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID SystemInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG SystemInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">PULONG ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* PZwResumeThread)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE threadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">PULONG SuspendCount</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_THREAD_BASIC_INFORMATION</span> &#123;</span><br><span class="line">NTSTATUS ExitStatus;</span><br><span class="line">PVOID TebBaseAddress;</span><br><span class="line">CLIENT_ID ClientId;</span><br><span class="line">KAFFINITY AffinityMask;</span><br><span class="line">KPRIORITY Priority;</span><br><span class="line">KPRIORITY BasePriority;</span><br><span class="line">&#125; THREAD_BASIC_INFORMATION;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">FARPROC <span class="title">getProc</span><span class="params">(std::string moduleName, std::string processName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(moduleName.<span class="built_in">c_str</span>()), processName.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hookByCode</span><span class="params">(std::string moduleName, std::string processName, PROC pFuncNew, PBYTE orgBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BYTE jmpcode[<span class="number">14</span>] = &#123; <span class="number">0xff</span>,<span class="number">0x25</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span> &#125;;</span><br><span class="line">FARPROC orgFunc = <span class="built_in">getProc</span>(moduleName, processName);</span><br><span class="line">PBYTE pOrgFunc = <span class="built_in">reinterpret_cast</span>&lt;PBYTE&gt;(orgFunc);</span><br><span class="line"><span class="keyword">if</span> (pOrgFunc[<span class="number">0</span>] == <span class="number">0xff</span> &amp;&amp; pOrgFunc[<span class="number">1</span>] == <span class="number">0x25</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD dwOldProtect;</span><br><span class="line"></span><br><span class="line"><span class="built_in">VirtualProtect</span>(pOrgFunc, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//保存原始代码</span></span><br><span class="line"><span class="built_in">memcpy</span>(orgBytes, pOrgFunc, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//8BYTE跳转为绝对地址</span></span><br><span class="line">DWORD64 targetAddr = <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(pFuncNew);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;jmpcode[<span class="number">6</span>], &amp;targetAddr, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(pOrgFunc, jmpcode, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">VirtualProtect</span>(pOrgFunc, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">unhookByCode</span><span class="params">(std::string moduleName, std::string processName, PBYTE orgBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FARPROC orgFunc = <span class="built_in">getProc</span>(moduleName, processName);</span><br><span class="line">PBYTE pOrgFunc = <span class="built_in">reinterpret_cast</span>&lt;PBYTE&gt;(orgFunc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(pOrgFunc[<span class="number">0</span>] == <span class="number">0xff</span> &amp;&amp; pOrgFunc[<span class="number">1</span>] == <span class="number">0x25</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD dwOldProtect;</span><br><span class="line"></span><br><span class="line"><span class="built_in">VirtualProtect</span>(pOrgFunc, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(pOrgFunc, orgBytes, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">VirtualProtect</span>(pOrgFunc, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">myZwQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG SystemInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID SystemInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG SystemInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">PULONG ReturnLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">unhookByCode</span>(<span class="string">&quot;ntdll.dll&quot;</span>, <span class="string">&quot;NtQuerySystemInformation&quot;</span>, &amp;orgBytesA[<span class="number">0</span>]);</span><br><span class="line">PZwQuerySystemInformation pZwQuerySystemInformation = <span class="built_in">reinterpret_cast</span>&lt;PZwQuerySystemInformation&gt;(<span class="built_in">getProc</span>(<span class="string">&quot;ntdll.dll&quot;</span>, <span class="string">&quot;ZwQuerySystemInformation&quot;</span>));</span><br><span class="line">NTSTATUS status = <span class="built_in">pZwQuerySystemInformation</span>(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);</span><br><span class="line"><span class="keyword">if</span> (status != STATUS_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (SystemInformationClass == <span class="number">5</span> &amp;&amp; g_szProcName[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">PSYSTEM_PROCESS_INFORMATION pInfo = <span class="built_in">static_cast</span>&lt;PSYSTEM_PROCESS_INFORMATION&gt;(SystemInformation);</span><br><span class="line">PSYSTEM_PROCESS_INFORMATION pNextInfo = <span class="built_in">reinterpret_cast</span>&lt;PSYSTEM_PROCESS_INFORMATION&gt;(<span class="built_in">reinterpret_cast</span>&lt;PBYTE&gt;(pInfo) + pInfo-&gt;NextEntryOffset);</span><br><span class="line"><span class="keyword">while</span> (pNextInfo-&gt;NextEntryOffset)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!_tcsicmp(pNextInfo-&gt;ImageName.Buffer, g_szProcName))</span><br><span class="line">&#123;</span><br><span class="line">pInfo-&gt;NextEntryOffset += pNextInfo-&gt;NextEntryOffset;</span><br><span class="line">&#125;</span><br><span class="line">pInfo = pNextInfo;</span><br><span class="line">pNextInfo = <span class="built_in">reinterpret_cast</span>&lt;PSYSTEM_PROCESS_INFORMATION&gt;(<span class="built_in">reinterpret_cast</span>&lt;PBYTE&gt;(pInfo) + pInfo-&gt;NextEntryOffset);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line"><span class="built_in">hookByCode</span>(<span class="string">&quot;ntdll.dll&quot;</span>, <span class="string">&quot;ZwQuerySystemInformation&quot;</span>, <span class="built_in">reinterpret_cast</span>&lt;PROC&gt;(myZwQuerySystemInformation), &amp;orgBytesA[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inject</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span> </span>&#123;</span><br><span class="line">HANDLE hProcess = <span class="number">0</span>, hThread = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!(hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPID))) &#123; <span class="comment">// 取得对应 PID 句柄</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;Open process %d failed\n&quot;</span>), dwPID);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(TCHAR);</span><br><span class="line"></span><br><span class="line">LPVOID pBuf = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pBuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//_tprintf(_T(&quot;Memory allocation failed in process %d\n&quot;), dwPID);</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hProcess, pBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="comment">//_tprintf(_T(&quot;WriteProcessMemory failed in process %d\n&quot;), dwPID);</span></span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pBuf, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HMODULE hKernel32 = <span class="built_in">GetModuleHandle</span>(_T(<span class="string">&quot;kernel32.dll&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (hKernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//_tprintf(_T(&quot;GetModuleHandle failed\n&quot;));</span></span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pBuf, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LPTHREAD_START_ROUTINE pThreadProc = (LPTHREAD_START_ROUTINE)<span class="built_in">GetProcAddress</span>(hKernel32, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pThreadProc == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//_tprintf(_T(&quot;GetProcAddress failed\n&quot;));</span></span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pBuf, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//_tprintf(_T(&quot;CreateRemoteThread failed in process %d\n&quot;), dwPID);</span></span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pBuf, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pBuf, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"></span><br><span class="line"><span class="comment">//_tprintf(_T(&quot;DLL injected successfully into process %d\n&quot;), dwPID);</span></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">myZwResumeThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE threadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">PULONG SuspendCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* ZwQueryInformationThread_t)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD ThreadInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID ThreadInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG ThreadInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">PULONG ReturnLength OPTIONAL</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line">THREAD_BASIC_INFORMATION tbi;</span><br><span class="line">FARPROC pqit = <span class="built_in">getProc</span>(<span class="string">&quot;ntdll.dll&quot;</span>, <span class="string">&quot;ZwQueryInformationThread&quot;</span>);</span><br><span class="line">NTSTATUS statusThread = <span class="built_in">reinterpret_cast</span>&lt;ZwQueryInformationThread_t&gt;(pqit)(threadHandle, <span class="number">0</span>, &amp;tbi, <span class="built_in">sizeof</span>(tbi), <span class="literal">NULL</span>);</span><br><span class="line">DWORD dwPid = <span class="built_in">reinterpret_cast</span>&lt;DWORD&gt;(tbi.ClientId.UniqueProcess);</span><br><span class="line">DWORD dwPrevPid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dwPid != <span class="built_in">GetCurrentProcessId</span>() &amp;&amp; dwPid != dwPrevPid)</span><br><span class="line">&#123;</span><br><span class="line">dwPrevPid = dwPid;</span><br><span class="line"><span class="built_in">inject</span>(dwPid, <span class="string">L&quot;C:\\Users\\a2879\\source\\repos\\HideProcess\\x64\\Debug\\HideProcess.dll&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unhookByCode</span>(<span class="string">&quot;ntdll.dll&quot;</span>, <span class="string">&quot;ZwResumeThread&quot;</span>, &amp;orgBytesB[<span class="number">0</span>]);</span><br><span class="line">PZwResumeThread pZwResumeThread = <span class="built_in">reinterpret_cast</span>&lt;PZwResumeThread&gt;(<span class="built_in">getProc</span>(<span class="string">&quot;ntdll.dll&quot;</span>, <span class="string">&quot;ZwResumeThread&quot;</span>));</span><br><span class="line">NTSTATUS status = <span class="built_in">pZwResumeThread</span>(threadHandle, SuspendCount);</span><br><span class="line"></span><br><span class="line"><span class="built_in">hookByCode</span>(<span class="string">&quot;ntdll.dll&quot;</span>, <span class="string">&quot;ZwResumeThread&quot;</span>, <span class="built_in">reinterpret_cast</span>&lt;PROC&gt;(myZwResumeThread), &amp;orgBytesB[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">setProcName</span>(<span class="string">L&quot;Notepad.exe&quot;</span>);</span><br><span class="line"><span class="function">std::string <span class="title">curProc</span><span class="params">(MAX_PATH, <span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line"><span class="type">char</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">GetModuleFileNameA</span>(<span class="literal">nullptr</span>, &amp;curProc[<span class="number">0</span>], curProc.<span class="built_in">size</span>());</span><br><span class="line">p = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="built_in">strrchr</span>(curProc.<span class="built_in">c_str</span>(), <span class="string">&#x27;\\&#x27;</span>));</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">nullptr</span> &amp;&amp; !_stricmp(p + <span class="number">1</span>, <span class="string">&quot;DLL_inject.exe&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line"><span class="comment">/*CreateThread(nullptr, 0, startHide, nullptr, 0, nullptr);*/</span></span><br><span class="line"><span class="built_in">hookByCode</span>(<span class="string">&quot;ntdll.dll&quot;</span>, <span class="string">&quot;ZwQuerySystemInformation&quot;</span>, <span class="built_in">reinterpret_cast</span>&lt;PROC&gt;(myZwQuerySystemInformation), &amp;orgBytesA[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">hookByCode</span>(<span class="string">&quot;ntdll.dll&quot;</span>, <span class="string">&quot;ZwResumeThread&quot;</span>, <span class="built_in">reinterpret_cast</span>&lt;PROC&gt;(myZwResumeThread), &amp;orgBytesB[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注入器本来应该实现全局注入，但是由于我这边不知道为什么一注就挂，所以就没有全局，只单独选择了exploer，这里的代码和之前的是一样的，如果想继续测试全局注入，可以试试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Is64BitProcess</span><span class="params">(DWORD dwPID)</span> </span>&#123;</span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwPID);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL isWow64 = FALSE;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsWow64Process</span>(hProcess, &amp;isWow64)) &#123;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !isWow64;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inject</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span> </span>&#123;</span><br><span class="line">HANDLE hProcess = <span class="number">0</span>, hThread = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!(hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPID))) &#123; <span class="comment">// 取得对应 PID 句柄</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;Open process %d failed\n&quot;</span>), dwPID);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(TCHAR);</span><br><span class="line"></span><br><span class="line">LPVOID pBuf = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pBuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Memory allocation failed in process %d\n&quot;</span>), dwPID);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hProcess, pBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;WriteProcessMemory failed in process %d\n&quot;</span>), dwPID);</span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pBuf, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HMODULE hKernel32 = <span class="built_in">GetModuleHandle</span>(_T(<span class="string">&quot;kernel32.dll&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (hKernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;GetModuleHandle failed\n&quot;</span>));</span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pBuf, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LPTHREAD_START_ROUTINE pThreadProc = (LPTHREAD_START_ROUTINE)<span class="built_in">GetProcAddress</span>(hKernel32, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pThreadProc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;GetProcAddress failed\n&quot;</span>));</span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pBuf, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;CreateRemoteThread failed in process %d\n&quot;</span>), dwPID);</span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pBuf, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pBuf, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;DLL injected successfully into process %d\n&quot;</span>), dwPID);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">injectAllProcesses</span><span class="params">(LPCTSTR szDllPath)</span> </span>&#123;</span><br><span class="line">HANDLE hSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;CreateToolhelp32Snapshot failed\n&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROCESSENTRY32 pe;</span><br><span class="line">pe.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Process32First</span>(hSnapshot, &amp;pe)) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (pe.th32ProcessID &lt;= <span class="number">100</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Is64BitProcess</span>(pe.th32ProcessID)) &#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Skipping 32-bit process: %s (PID: %d)\n&quot;</span>), pe.szExeFile, pe.th32ProcessID);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!_tcsicmp(pe.szExeFile, <span class="string">L&quot;StartMenuExperienceHost.exe&quot;</span>) ||</span><br><span class="line">!_tcsicmp(pe.szExeFile, <span class="string">L&quot;ShellExperienceHost.exe&quot;</span>) ||</span><br><span class="line">!_tcsicmp(pe.szExeFile, <span class="string">L&quot;LockApp.exe&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Skipping process: %s (PID: %d)\n&quot;</span>), pe.szExeFile, pe.th32ProcessID);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;Attempting to inject into 64-bit process: %s (PID: %d)\n&quot;</span>), pe.szExeFile, pe.th32ProcessID);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">inject</span>(pe.th32ProcessID, szDllPath)) &#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Successfully injected into process: %s (PID: %d)\n&quot;</span>), pe.szExeFile, pe.th32ProcessID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Failed to inject into process: %s (PID: %d)\n&quot;</span>), pe.szExeFile, pe.th32ProcessID);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(hSnapshot, &amp;pe));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Process32First failed\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, TCHAR* argv[]) &#123;</span><br><span class="line"><span class="comment">//if (argc != 2) &#123;</span></span><br><span class="line"><span class="comment">//_tprintf(_T(&quot;USAGE: %s dll_path\n&quot;), argv[0]);</span></span><br><span class="line"><span class="comment">//return 1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">TCHAR dllpath[] = <span class="string">L&quot;xxx\\source\\repos\\HideProcess\\x64\\Debug\\HideProcess.dll&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">injectAllProcesses</span>(dllpath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是64位，不能用taskmgr测试QAQ，所以写了一个测试程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取 ZwQuerySystemInformation 函数地址</span></span><br><span class="line"><span class="comment">//setProcName(L&quot;notepad.exe&quot;);</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">PZwQuerySystemInformation pZwQuerySystemInformation = <span class="built_in">reinterpret_cast</span>&lt;PZwQuerySystemInformation&gt;(</span><br><span class="line"><span class="built_in">getProc</span>(<span class="string">&quot;Ntdll.dll&quot;</span>, <span class="string">&quot;ZwQuerySystemInformation&quot;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (pZwQuerySystemInformation == <span class="literal">NULL</span>) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Failed to get ZwQuerySystemInformation address!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hookByCode(&quot;Ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, reinterpret_cast&lt;PROC&gt;(myZwQuerySystemInformation), &amp;orgBytesA[0]);</span></span><br><span class="line"><span class="comment">// 定义缓冲区大小</span></span><br><span class="line">ULONG bufferSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 初始缓冲区大小（1MB）</span></span><br><span class="line">PVOID buffer = <span class="built_in">malloc</span>(bufferSize);</span><br><span class="line"><span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Failed to allocate memory!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 ZwQuerySystemInformation</span></span><br><span class="line">NTSTATUS status;</span><br><span class="line"><span class="keyword">while</span> ((status = <span class="built_in">pZwQuerySystemInformation</span>(</span><br><span class="line"><span class="number">5</span>, <span class="comment">// SystemProcessInformation</span></span><br><span class="line">buffer,</span><br><span class="line">bufferSize,</span><br><span class="line">&amp;bufferSize</span><br><span class="line">)) == STATUS_INFO_LENGTH_MISMATCH) &#123;</span><br><span class="line"><span class="comment">// 如果缓冲区不够大，重新分配更大的缓冲区</span></span><br><span class="line"><span class="built_in">free</span>(buffer);</span><br><span class="line">bufferSize *= <span class="number">2</span>;</span><br><span class="line">buffer = <span class="built_in">malloc</span>(bufferSize);</span><br><span class="line"><span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Failed to allocate memory!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;ZwQuerySystemInformation failed with status: &quot;</span> &lt;&lt; status &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">free</span>(buffer);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历进程信息</span></span><br><span class="line">PSYSTEM_PROCESS_INFORMATION pProcessInfo = <span class="built_in">reinterpret_cast</span>&lt;PSYSTEM_PROCESS_INFORMATION&gt;(buffer);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 输出进程ID和进程名</span></span><br><span class="line">std::wcout &lt;&lt; <span class="string">&quot;Process ID: &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;DWORD&gt;(pProcessInfo-&gt;UniqueProcessId)</span><br><span class="line">&lt;&lt; <span class="string">&quot;, Process Name: &quot;</span> &lt;&lt; (pProcessInfo-&gt;ImageName.Buffer ? pProcessInfo-&gt;ImageName.Buffer : <span class="string">L&quot;Unknown&quot;</span>)</span><br><span class="line">&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动到下一个进程</span></span><br><span class="line"><span class="keyword">if</span> (pProcessInfo-&gt;NextEntryOffset == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pProcessInfo = <span class="built_in">reinterpret_cast</span>&lt;PSYSTEM_PROCESS_INFORMATION&gt;(</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;BYTE*&gt;(pProcessInfo) + pProcessInfo-&gt;NextEntryOffset</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放缓冲区</span></span><br><span class="line"><span class="built_in">free</span>(buffer);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试，notepad可以隐藏</p>]]></content>
    
    
    <summary type="html">本篇说明进程隐藏的工作原理</summary>
    
    
    
    <category term="逆向工程核心原理" scheme="https://www.pri87.vip/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="技能" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/"/>
    
    <category term="Hook" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/%E6%8A%80%E8%83%BD/Hook/"/>
    
    
    <category term="win" scheme="https://www.pri87.vip/tags/win/"/>
    
  </entry>
  
  <entry>
    <title>网路编程2-SELECT</title>
    <link href="https://www.pri87.vip/posts/574e749a.html"/>
    <id>https://www.pri87.vip/posts/574e749a.html</id>
    <published>2025-02-23T13:01:42.000Z</published>
    <updated>2025-02-27T04:18:18.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="select">select</h2><p>select维护了一个监测队列，当我们把需要的文件描述符传入时，它就会主动监测其中的内容。</p><p>一般格式为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fd_set fdRead;<span class="comment">//监测队列</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdRead);</span><br><span class="line"><span class="built_in">FD_SET</span>(servSock, &amp;fdRead);<span class="comment">//sock加入监测队列</span></span><br><span class="line"><span class="keyword">for</span> (SOCKET client : clientList)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">FD_SET</span>(client, &amp;fdRead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> selectRes = <span class="built_in">select</span>(<span class="number">0</span>, &amp;fdRead, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;tv);<span class="comment">//selectRes表明select是否监测到sock的活动</span></span><br></pre></td></tr></table></figure><p>由于服务器socket活动时表明有新连接<br>客户端socket活动时表明有数据发送，<br>所以通过这个区别来添加新客户端和发送信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Server::coreFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(servSock != INVALID_SOCKET);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;  <span class="comment">// 无限循环，持续处理事件</span></span><br><span class="line">        <span class="comment">// 1. 初始化 fd_set，添加服务端套接字和所有客户端套接字</span></span><br><span class="line">        fd_set fdRead;</span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;fdRead);</span><br><span class="line">        <span class="built_in">FD_SET</span>(servSock, &amp;fdRead);  <span class="comment">// 监控服务端套接字（新连接）</span></span><br><span class="line">        <span class="keyword">for</span> (SOCKET client : clientList) &#123;</span><br><span class="line">            <span class="built_in">FD_SET</span>(client, &amp;fdRead);  <span class="comment">// 监控所有客户端套接字（数据到达）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 调用 select，设置超时时间为 1 秒</span></span><br><span class="line">        timeval tv&#123; <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">int</span> selectRes = <span class="built_in">select</span>(<span class="number">0</span>, &amp;fdRead, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;tv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 处理 select 结果</span></span><br><span class="line">        <span class="keyword">if</span> (selectRes &gt; <span class="number">0</span>) &#123;  <span class="comment">// 有套接字活动</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; fdRead.fd_count; ++i) &#123;  <span class="comment">// 遍历活跃的套接字</span></span><br><span class="line">                SOCKET activeSock = fdRead.fd_array[i];</span><br><span class="line">                <span class="keyword">if</span> (activeSock == servSock) &#123;  <span class="comment">// 服务端套接字活跃：新连接</span></span><br><span class="line">                    SOCKET clntSock = <span class="built_in">accept</span>(servSock, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">                    <span class="keyword">if</span> (clntSock == INVALID_SOCKET) &#123;</span><br><span class="line">                        std::cout &lt;&lt; <span class="string">&quot;accept error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    clientList.<span class="built_in">push_back</span>(clntSock);  <span class="comment">// 将新客户端加入列表</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 客户端套接字活跃：数据到达</span></span><br><span class="line">                    <span class="built_in">recvMsg</span>(fdRead, activeSock);  <span class="comment">// 接收并处理数据</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectRes == <span class="number">0</span>) &#123;  <span class="comment">// 超时，无活动</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;do something else&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// select 错误</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;select func error&quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此服务端完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Server.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WS2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Message.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">SOCKET servSock;</span><br><span class="line">std::list&lt;SOCKET&gt; clientList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">coreFunc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Server</span>() :<span class="built_in">servSock</span>(INVALID_SOCKET) &#123;&#125;;</span><br><span class="line">~<span class="built_in">Server</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">recvMsg</span><span class="params">(fd_set&amp; fdRead, SOCKET&amp; clientSock)</span></span>;</span><br><span class="line"><span class="comment">//bool conductMsg();</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Server.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">Server::~<span class="built_in">Server</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (servSock != INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">closesocket</span>(servSock);</span><br><span class="line"><span class="keyword">for</span> (SOCKET client : clientList)</span><br><span class="line"><span class="built_in">closesocket</span>(client);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Server::init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WSADATA data&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;data) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;startup error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">servSock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (servSock == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;socket error&quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">sockaddr_in servAddr&#123;&#125;;</span><br><span class="line"></span><br><span class="line">servAddr.sin_family = AF_INET;</span><br><span class="line">servAddr.sin_port = <span class="built_in">htons</span>(<span class="number">2345</span>);</span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;servAddr.sin_addr.S_un.S_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(servSock, (sockaddr*)&amp;servAddr, <span class="built_in">sizeof</span>(sockaddr)) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;bind error&quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">listen</span>(servSock, <span class="number">128</span>) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;listen error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Server::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">coreFunc</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Server::coreFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(servSock != INVALID_SOCKET);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">fd_set fdRead;</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdRead);</span><br><span class="line"><span class="built_in">FD_SET</span>(servSock, &amp;fdRead);</span><br><span class="line"><span class="keyword">for</span> (SOCKET client : clientList)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">FD_SET</span>(client, &amp;fdRead);</span><br><span class="line">&#125;</span><br><span class="line">timeval tv&#123; <span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> selectRes = <span class="built_in">select</span>(<span class="number">0</span>, &amp;fdRead, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;tv);</span><br><span class="line"><span class="keyword">if</span> (selectRes &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; fdRead.fd_count; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fdRead.fd_array[i] == servSock)</span><br><span class="line">&#123;</span><br><span class="line">SOCKET clntSock = <span class="built_in">accept</span>(servSock, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (clntSock == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;accept error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">clientList.<span class="built_in">push_back</span>(clntSock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">recvMsg</span>(fdRead, fdRead.fd_array[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (selectRes == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;do something else&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;select func error&quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Server::recvMsg</span><span class="params">(fd_set&amp; fdRead, SOCKET&amp; clientSock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Header header;</span><br><span class="line"><span class="type">int</span> recvRes = <span class="built_in">recv</span>(clientSock, (<span class="type">char</span>*)&amp;header, <span class="built_in">sizeof</span>(Header), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (recvRes &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Client disconnected:&quot;</span> &lt;&lt; clientSock &lt;&lt; std::endl;</span><br><span class="line">clientList.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(clientList.<span class="built_in">begin</span>(), clientList.<span class="built_in">end</span>(), clientSock), clientList.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">closesocket</span>(clientSock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (header.cmd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> CMD::LOGIN:</span><br><span class="line">&#123;</span><br><span class="line">Login login;</span><br><span class="line"><span class="type">int</span> recvRes2 = <span class="built_in">recv</span>(clientSock, (<span class="type">char</span>*)&amp;login + <span class="built_in">sizeof</span>(Header),</span><br><span class="line"><span class="built_in">sizeof</span>(Login) - <span class="built_in">sizeof</span>(Header), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (recvRes2 &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recv error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LoginResult <span class="title">loginResult</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">send</span>(clientSock, (<span class="type">char</span>*)&amp;loginResult, <span class="built_in">sizeof</span>(LoginResult), <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;send error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD::LOGOUT:</span><br><span class="line">&#123;</span><br><span class="line">Logout logout;</span><br><span class="line"><span class="type">int</span> recvRes2 = <span class="built_in">recv</span>(clientSock, (<span class="type">char</span>*)&amp;logout + <span class="built_in">sizeof</span>(Header),</span><br><span class="line"><span class="built_in">sizeof</span>(Logout) - <span class="built_in">sizeof</span>(Header), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (recvRes2 &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recv error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LogoutResult <span class="title">logoutResult</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">send</span>(clientSock, (<span class="type">char</span>*)&amp;logoutResult, <span class="built_in">sizeof</span>(LoginResult), <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;send error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD::LOGIN_RESULT:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CMD::LOGOUT_RESULT:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bool Server::conductMsg() &#123;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Server server;</span><br><span class="line"><span class="keyword">if</span> (!server.<span class="built_in">init</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">2345</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">server.<span class="built_in">start</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//message.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">CMD</span></span><br><span class="line">&#123;</span><br><span class="line">LOGIN,</span><br><span class="line">LOGOUT,</span><br><span class="line">LOGIN_RESULT,</span><br><span class="line">LOGOUT_RESULT,</span><br><span class="line">NO_CMD</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Header</span></span><br><span class="line">&#123;</span><br><span class="line">CMD cmd;</span><br><span class="line"><span class="type">unsigned</span> dataLength;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Header</span>() : <span class="built_in">cmd</span>(CMD::NO_CMD)</span><br><span class="line">, <span class="built_in">dataLength</span>(<span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Header</span>(CMD cmd_, <span class="type">unsigned</span> dataLength_) : <span class="built_in">cmd</span>(cmd_)</span><br><span class="line">, <span class="built_in">dataLength</span>(dataLength_) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> :<span class="keyword">public</span> Header</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> usrName[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span> passwd[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">Login</span>(<span class="type">const</span> <span class="type">char</span>* userName_, <span class="type">const</span> <span class="type">char</span>* passwd_) :<span class="built_in">Header</span>(CMD::LOGIN, <span class="built_in">sizeof</span>(Login))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy_s</span>(usrName, <span class="number">32</span>, userName_);</span><br><span class="line"><span class="built_in">strcpy_s</span>(passwd, <span class="number">32</span>, passwd_);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Login</span>() :<span class="built_in">Header</span>(CMD::LOGIN, <span class="built_in">sizeof</span>(Login)), usrName&#123; <span class="number">0</span> &#125;, passwd&#123; <span class="number">0</span> &#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> Header</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> logoutNum;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Logout</span>(<span class="type">unsigned</span> logoutNum_) : <span class="built_in">Header</span>(CMD::LOGOUT, <span class="built_in">sizeof</span>(Logout))</span><br><span class="line">, <span class="built_in">logoutNum</span>(logoutNum_) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Logout</span>() :<span class="built_in">Header</span>(CMD::LOGOUT, <span class="built_in">sizeof</span>(Logout)), <span class="built_in">logoutNum</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> :<span class="keyword">public</span> Header</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> loginResultNum;</span><br><span class="line"><span class="built_in">LoginResult</span>(<span class="type">unsigned</span> loginResultNum_) :<span class="built_in">Header</span>(CMD::LOGIN_RESULT, <span class="built_in">sizeof</span>(LoginResult)), <span class="built_in">loginResultNum</span>(loginResultNum_) &#123;&#125;</span><br><span class="line"><span class="built_in">LoginResult</span>() :<span class="built_in">Header</span>(CMD::LOGIN_RESULT, <span class="built_in">sizeof</span>(LoginResult)), <span class="built_in">loginResultNum</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> :<span class="keyword">public</span> Header</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> logoutResultNum;</span><br><span class="line"><span class="built_in">LogoutResult</span>(<span class="type">unsigned</span> logoutResultNum_) :<span class="built_in">Header</span>(CMD::LOGOUT_RESULT, <span class="built_in">sizeof</span>(LogoutResult)), <span class="built_in">logoutResultNum</span>(logoutResultNum_) &#123;&#125;</span><br><span class="line"><span class="built_in">LogoutResult</span>() :<span class="built_in">Header</span>(CMD::LOGOUT_RESULT, <span class="built_in">sizeof</span>(LogoutResult)), <span class="built_in">logoutResultNum</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WS2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Message.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WSADATA data&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;data) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;WSAstartup error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">SOCKET servSock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (servSock == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;socket error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sockaddr_in servAddr&#123;&#125;;</span><br><span class="line">servAddr.sin_family = AF_INET;</span><br><span class="line">servAddr.sin_port = <span class="built_in">htons</span>(<span class="number">2345</span>);</span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;servAddr.sin_addr.S_un.S_addr);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(servSock, (sockaddr*)&amp;servAddr, <span class="built_in">sizeof</span>(sockaddr)) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;connect error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">closesocket</span>(servSock);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;connect success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Login <span class="title">login</span><span class="params">(<span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbbb&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">send</span>(servSock, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;login), <span class="built_in">sizeof</span>(Login), <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;send error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">LoginResult loginResult;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">recv</span>(servSock, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;loginResult), <span class="built_in">sizeof</span>(LoginResult), <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recv error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; loginResult.loginResultNum &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Select可以让服务端链接多个客户端</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="开发" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/"/>
    
    <category term="语言学习" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="网络编程" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="CPP" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/CPP/"/>
    
    <category term="网络编程" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/CPP/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="cpp" scheme="https://www.pri87.vip/tags/cpp/"/>
    
    <category term="网络" scheme="https://www.pri87.vip/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="cs" scheme="https://www.pri87.vip/tags/cs/"/>
    
  </entry>
  
  <entry>
    <title>吾爱2025解题领红包5windows高级题简要分析</title>
    <link href="https://www.pri87.vip/posts/43ad3f3c.html"/>
    <id>https://www.pri87.vip/posts/43ad3f3c.html</id>
    <published>2025-02-16T12:56:18.000Z</published>
    <updated>2025-03-18T12:17:05.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这个题很有意思<br>但是第一关就卡了我很久<br>这里记录一下我是怎么分析的</p><h2 id="壳">壳</h2><p>这个壳的反调试部分在TlsCallback_0函数的第二次call rax中<br>7FF708E27DB0这个函数,通过7FF708E26280判断是否有调试和7FF708E244A0判断是否有hook,然后获得一个标志位放到flag_a中</p><p><img src="https://s2.loli.net/2025/02/16/WV1t7PzX5OiGBDK.png" alt="image-20250216210356149"></p><p>在jmp rax中跳转到7FF708E24400执行setThreadInfomation函数的位置,传参是-(flag_a != 1) ^ 0x11<br>如果标志位为1说明是调试,会直接触发hidefromdebug效果,如果标志为2则会传入错误的setInfomatinon值,最后会传出0xC000003导致显示环境异常.如果标志为5,表明正常不会进行检查.</p><p>第二点,这里调试的时候如果对后面SMC解密的代码下了断点0xcc,则会导致它还原失败,所以这里是不能提前下断点的</p><h2 id="脱壳">脱壳</h2><p>将程序的动态基址关掉，然后来到jmp之后的位置。用xdbg脱壳，IAT表没有还原，所以不能运行，但是这样可以直接看到加密流程了</p><p>就是一个TEA</p>]]></content>
    
    
    <summary type="html">一道好题</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>win-调试原理</title>
    <link href="https://www.pri87.vip/posts/6e648a52.html"/>
    <id>https://www.pri87.vip/posts/6e648a52.html</id>
    <published>2025-02-10T06:12:33.000Z</published>
    <updated>2025-02-27T07:03:08.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="X86的主要调试设施">X86的主要调试设施</h2><p>INT 3 指令   软件断点基础<br>追踪标志TF   单步追踪的基础<br>调试寄存器   硬件寄存器的基础<br>分支监视和记录   按分支单步的基础</p><h2 id="软件断点">软件断点</h2><p>0xCC int3指令<br>机器码为1字节，无数量限制，只支持代码段(可执行的段)，且不支持在只读存储器中使用</p><p>将一个int 3 写入，触发异常break之后会被恢复，再执行后会再次写入</p><h2 id="硬件断点">硬件断点</h2><p>通过调试寄存器实现，DR0到DR3 的四个寄存器中存放目标地址<br>DR7有8组设置标志位，每组分别有2个2位标志，其中一个标志表示R/W，另一个标志表示长度<br>CPU每执行1步就进行一次匹配，如果是这个地址，模式正确，就会写入DR6的标志位，然后触发断点(产生1号异常)，操作系统通过检查标志位知道哪一个命中了断点</p><p>由于每个线程的寄存器信息独立保存，所以每个线程都可以设4个地址</p><h2 id="陷阱标志">陷阱标志</h2><p>标志寄存器efl(ag)的TF位<br>单步异常在efl的最低位。每当efl最后一位是1，系统会自动置0，然后触发单步异常</p><h2 id="异常">异常</h2><p>前面几节已经差不多说明了，这里就不赘述了。不过在程序中，尤其是VS生成的代码，一般来说低级的异常往往会封装成Cxx异常。</p><h3 id="中断向量表">中断向量表</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>除零异常</span><br><span class="line"><span class="symbol">1 </span>调试异常</span><br><span class="line"><span class="symbol">3 </span>断点异常</span><br><span class="line"><span class="symbol">4 </span>溢出异常</span><br><span class="line"><span class="symbol">5 </span>数组越界异常</span><br><span class="line"><span class="symbol">6 </span>非法指令异常</span><br><span class="line"><span class="symbol">13 </span>保护异常</span><br><span class="line"><span class="symbol">14 </span>缺页异常</span><br><span class="line"><span class="symbol">18 </span>机器检查异常</span><br><span class="line"><span class="number">32</span>-<span class="number">255</span> 用户自定义，很多是中断，而不是异常</span><br></pre></td></tr></table></figure><h3 id="来源">来源</h3><p>CPU产生 执行指令检测到的错误，机器异常，调试异常等<br>程序产生，RaiseException win32api<br>C++ throw E</p><h2 id="JTAG">JTAG</h2><p>硬件调试标准</p><h2 id="用户态调试模型XP">用户态调试模型XP</h2><p>断点命中时，CPU立即切换到内核执行一系列异常处理函数。其中KISystemService调用KiRaiseException()产生异常KiDebugService和KiTrap04~00做分发准备。KiDispatchException()是分发中枢，会通知用户态调试子系统Dbgk，然后触发DbgkForwardExcption()，如果有调试器执行DbgkpSendApiMessages()继续传递，到DbgkQueueMessage()生成调试事件并将产生的调试对象挂到内核调试对象队列中。调试器一直等待这个队列，有调试对象时就会取出并处理。</p><h3 id="调试器的载入程序">调试器的载入程序</h3><p>一般情况下，会在目标进程创建一个线程执行int 3，但是系统在分发异常时会冻结所有线程</p><h2 id="KiDisPatchException">KiDisPatchException</h2><p>用户态异常内含2轮异常分发：<br>第一轮：</p><p>如果没有用户态调试器，尝试分发给内核调试器<br>DbgkForwardException尝试交给用户态调试器<br>复制栈帧然后改程序指针到KeUserExceptionDispatcher到用户态</p><p>第二轮：</p><p>DbgkForwardException尝试交给用户态调试器<br>然后尝试交给服务进程，让服务进程做最后处理，一般直接杀死<br>如果还是不处理，直接调用ZwTerminateProcess在内核态杀死</p><blockquote><p>产生硬件异常通过 IDT调用异常处理例程， 产生软件异常通过 API的层层调用产地异常信息。而异常又由于发生位置不同，分为内核异常和用户态异常，二者最后都会靠 <code>kiDispathException</code>函数来进行异常分发；<br>当内核产生异常时，程序处理流程进入到 <code>KiDispatchException</code>函数，在该函数内备份当前线程 R3 的 <code>TrapFrame</code>（即栈帧的基址）。异常处理首先判断这是否是第一次异常，判断是否存在内核调试器，如果有内核调试器，则把当前的异常信息发送给内核调试器；如果没有内核调试器或者内核调试器没有处该异常 ， 则进入步骤3，调用 <code>RtlDispatchException</code>。<br>内核异常进入 <code>RtlDispatchException</code> 函 数， 如果<code>RtlDispatchException</code> 函数没有处理该异常，那么将再次尝试将异常发送到内核调试器，如果此时内核调试器仍然不存在或者没有处理该异常，那么此时系统会直接蓝屏；<br>如果是用户态异常则经过 <code>KiDispatchException</code>进行用户态异常分发和处理。如果是第一次分发异常，则调用 <code>DbgKForwardException</code>将异常分发到内核调试器；如果内核调试器不存在或没有处理异常，则尝试将异常分发给用户态调试器；如果异常被处理，则进入步骤10；如果用户态调试器不存在或未处理异常，则检测是否是第一次处理异常，如果是第一次处理异常则进入第5步中的异常数据准备；<br>准备一个返回ntdll!<code>KiUserExceptionDispatcher</code> 函数的应用层调用栈，结束本次<code>KiDispatchException</code> 函数的运行，调用<code>KiServiceExit</code> 返回用户层。此时函数栈帧是ntdll!<code>KiUserExceptionDispatcher</code>的执行环境，用户态线程从执行 ntdll!<code>KiUserExceptionDispatcher</code> 开始执行。该函数调用 ntdll!RtlDispatchException进行异常的分发，进入第 6 步；<br>通过 <code>RtlCallVectoredExceptionHandlers</code>遍历 VEH链表尝试查找异常处理函数；如果 VEH未处理异常。则从 fs[0]读取 ExceptionList并开始执行 SEH 函数处理，进入步骤7；<br>如果SEH没有处理函数处理该异常，则检查用户是否通过<code>SetUnhandledExceptionFilter</code>函数注册过进程的异常处理函数，如果用户注册过异常处理函数，调用该异常处理函数，如果异常没有被成功处理或没有自定义的异常处理函数，则进入步骤3；<br>如果最后仍没有处理该异常，便会主动调用 <code>NtRaiseException</code>将该异常重新跑出来，但是此时不是第一次分发，此时 <code>NtRaiseException</code>流程重新调用了 ntdll!<code>KiDispatchException</code>，并再次进入用户态异常的处理分支，进入步骤9；<br>第二次进入用户态异常处理时，不会再尝试发送到内核调试器，也不会再进行异常分发，而是直接尝试发送到用户态体异常调试器，如果最后异常仍未被处理则进入步骤11；<br>异常被处理，调用 NtContine，将之前保存的 TrapFrame还原，程序继续从异常处正常运行；<br>异常不能被处理，系统调用 ntdll!<code>KiDispatchException</code> 调用 ZeTerminateProcess结束进程。</p></blockquote><hr><h2 id="WinDbg常见指令">WinDbg常见指令</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">t step into</span><br><span class="line">p step over</span><br><span class="line">g run</span><br><span class="line">g <span class="keyword">addr </span>转到指定位置</span><br><span class="line"><span class="keyword">bp </span><span class="keyword">addr </span>下软件断点</span><br><span class="line"><span class="keyword">ba </span><span class="keyword">addr </span>下硬件断点</span><br><span class="line">r 显示寄存器</span><br><span class="line">r register 显示指定寄存器</span><br><span class="line">u 显示下一条指令</span><br><span class="line">u <span class="keyword">addr </span>看对应地址指令</span><br><span class="line">u L10 显示下<span class="number">10</span>行指令</span><br><span class="line">ub 显示上一条指令</span><br><span class="line">k 看栈回溯</span><br><span class="line">~* 看当前线程</span><br><span class="line">~num k 看某个（序号为num）线程的栈回溯</span><br><span class="line">x moduleName!*funcName 在对应位置设置断点</span><br><span class="line"><span class="keyword">bp </span>moduleName!funcName <span class="string">&quot;指令&quot;</span> 断点命中后执行指令,比如<span class="string">&quot;.echo *********;k;gc&quot;</span>自动k然后go</span><br><span class="line">sxe ld 模块加载时停止</span><br><span class="line">lm 显示加载的模块</span><br><span class="line">dt (<span class="keyword">display </span>type)显示类型</span><br><span class="line">dt struct name 显示结构成员</span><br><span class="line">dt struct name <span class="keyword">address </span>将目标地址当作结构体显示</span><br></pre></td></tr></table></figure><p>以Noninvasive模式可以只读的形式附加</p><h2 id="参考资料">参考资料</h2><p><a href="https://www.bilibili.com/video/BV1A4411D7xx?p=2">2.概览和软件断点_哔哩哔哩_bilibili</a></p><p><a href="https://zhuanlan.zhihu.com/p/573449712">windows SEH分析 - 知乎</a></p><p><a href="https://blog.csdn.net/LPWSTR/article/details/78714486?spm=1001.2014.3001.5501">Windows异常世界历险记（二）——Win32用户层下SEH机制之对RtlUnwind的逆向分析-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">调试的原理</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="逆向" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/"/>
    
    <category term="Win内核" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E9%80%86%E5%90%91/Win%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="windows" scheme="https://www.pri87.vip/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>区块链安全0-入门</title>
    <link href="https://www.pri87.vip/posts/3cedd4ae.html"/>
    <id>https://www.pri87.vip/posts/3cedd4ae.html</id>
    <published>2025-02-09T06:42:19.000Z</published>
    <updated>2025-02-19T19:45:32.264Z</updated>
    
    <content type="html"><![CDATA[<h1>交互</h1><h2 id="以太坊生态">以太坊生态</h2><p>以太坊是一个去中心化,开源且具备智能合约功能的公共区块链平台.</p><h2 id="MetaMask">MetaMask</h2><p>钱包</p><h2 id="助记词-Seed-私钥-公钥-地址">助记词/Seed/私钥/公钥/地址</h2><p>助记词—Seed种子(可逆)<br>生成私钥(单向)<br>生成公钥<br>生成地址</p><h2 id="转账">转账</h2><h2 id="智能合约">智能合约</h2><p>使以太网生态有图灵完备性</p><h3 id="REMIX">REMIX</h3><p>使用的语言:solidity</p><p>inject Provider - MetaMask<br>连接Remix和MetaMask</p><h1>刷题</h1><p><a href="https://ethernaut.openzeppelin.com/level/1">The Ethernaut - Fallback</a></p><h3 id="Fallback">Fallback</h3><p>智能合约也是账户，可以直接转账</p><h3 id="Fallout">Fallout</h3><p>除了constructor函数以外，所有函数都可以调用，在0.8版本之前，如果拼错了构造函数，会导致这个函数可以被直接调用</p><h3 id="Coin-Flip">Coin Flip</h3><p>由于区块链中的很多数据是对所有人可见的，基于这些可见数据进行的伪随机可以很轻松地被预测到下一个随机数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">    uint256 public consecutiveWins;</span><br><span class="line">    uint256 lastHash;</span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        consecutiveWins = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line"></span><br><span class="line">        if (lastHash == blockValue) &#123;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastHash = blockValue;</span><br><span class="line">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">        if (side == _guess) &#123;</span><br><span class="line">            consecutiveWins++;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            consecutiveWins = 0;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract PoC &#123;</span><br><span class="line">    CoinFlip target;</span><br><span class="line">    uint256 lastHash;</span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">    constructor(address _target)&#123;</span><br><span class="line">        target = CoinFlip(_target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function flip() public &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line"></span><br><span class="line">        lastHash = blockValue;</span><br><span class="line">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line">        target.flip(side);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">区块链入门</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="区块链" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链" scheme="https://www.pri87.vip/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Solidity" scheme="https://www.pri87.vip/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>区块链安全1-做题</title>
    <link href="https://www.pri87.vip/posts/2967681d.html"/>
    <id>https://www.pri87.vip/posts/2967681d.html</id>
    <published>2025-02-09T06:42:19.000Z</published>
    <updated>2025-02-19T19:45:32.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="level4-Telephone">level4 Telephone</h2><p>tx.addr是原始调用者<br>msg.sender是调用这个合约的调用者</p><p>可以通过让合约调用合约来实现tx.origin不等于msg.sender</p><h2 id="level5-Token">level5 Token</h2><p>减法和加法有溢出，但是0.8版本有内置的检查</p><h2 id="level6-Delegation">level6 Delegation</h2><p>fallback函数<br>函数选择器<br>底层通过不同的值选择不同的函数执行，从而实现执行不同的合约的函数</p><p>委托调用，直接执行目标代码的机器码</p><h2 id="level7-Force">level7 Force</h2><p>如果一个合约没有receive函数，那么就不能向这个合约转账</p><p>但是有一个自毁函数可以把本合约销毁然后将自身以太币发送到指定地址</p><p>selfdestruct(payable _(_to))</p><h2 id="level8-Vault">level8 Vault</h2><p>合约上的所有内容都是公开的，所以可以直接通过查看交易记录得到每一个存放的值</p><h3 id="solidity内存排布">solidity内存排布</h3><p>由变量声明顺序由上至下申请空间，每个插槽32byte，如果插槽位置不够了，就新申请一个，放在新申请的里面</p><p>数组，通过计算keccak§得到初始地址，然后再增加index值</p><h2 id="重入攻击">重入攻击</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.20;</span><br><span class="line"></span><br><span class="line">interface IWrappedEther &#123;</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 amount);</span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed owner,</span><br><span class="line">        address indexed spender,</span><br><span class="line">        uint256 amount</span><br><span class="line">    );</span><br><span class="line">    event Deposit(address indexed from, uint256 amount);</span><br><span class="line">    event Withdraw(address indexed to, uint256 amount);</span><br><span class="line"></span><br><span class="line">    function deposit(address to) external payable;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) external;</span><br><span class="line"></span><br><span class="line">    function withdrawAll() external;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 amount) external;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 amount) external;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 amount) external;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    function allowance(</span><br><span class="line">        address owner,</span><br><span class="line">        address spender</span><br><span class="line">    ) external view returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract WrappedEther is IWrappedEther &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    function deposit(address to) external payable &#123;</span><br><span class="line">        balanceOf[to] += msg.value;</span><br><span class="line">        emit Deposit(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) external &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= amount, &quot;insufficient balance&quot;);</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        sendEth(payable(msg.sender), amount);</span><br><span class="line">        emit Withdraw(msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdrawAll() external &#123;</span><br><span class="line">        sendEth(payable(msg.sender), balanceOf[msg.sender]);</span><br><span class="line">        balanceOf[msg.sender] = 0;</span><br><span class="line">        emit Withdraw(msg.sender, balanceOf[msg.sender]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 amount) external &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= amount, &quot;insufficient balance&quot;);</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        balanceOf[to] += amount;</span><br><span class="line">        emit Transfer(msg.sender, to, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 amount) external &#123;</span><br><span class="line">        require(balanceOf[from] &gt;= amount, &quot;insufficient balance&quot;);</span><br><span class="line">        require(</span><br><span class="line">            allowance[from][msg.sender] &gt;= amount,</span><br><span class="line">            &quot;insufficient allowance&quot;</span><br><span class="line">        );</span><br><span class="line">        balanceOf[from] -= amount;</span><br><span class="line">        balanceOf[to] += amount;</span><br><span class="line">        allowance[from][msg.sender] -= amount;</span><br><span class="line">        emit Transfer(from, to, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 amount) external &#123;</span><br><span class="line">        allowance[msg.sender][spender] = amount;</span><br><span class="line">        emit Approval(msg.sender, spender, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sendEth(address payable to, uint256 amount) private &#123;</span><br><span class="line">        (bool success, ) = to.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;failed to send ether&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在withdrawAll的时候触发，先转账，后withdraw，所以可以在receive再调用这个withdrawAll函数导致多次执行操作。</p>]]></content>
    
    
    <summary type="html">区块链入门</summary>
    
    
    
    <category term="知识集" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/"/>
    
    <category term="区块链" scheme="https://www.pri87.vip/categories/%E7%9F%A5%E8%AF%86%E9%9B%86/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链" scheme="https://www.pri87.vip/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Solidity" scheme="https://www.pri87.vip/tags/Solidity/"/>
    
  </entry>
  
</feed>
